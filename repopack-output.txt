This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-11-02T18:13:52.089Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
app/
  api/
    auth/
      [...nextauth]/
        route.ts
      db/
        route.ts
      error/
        page.tsx
      signin/
        page.tsx
    decks/
      [id]/
        route.ts
      due-count/
        route.ts
      route.ts
    flashcards/
      [id]/
        route.ts
      route.ts
    labels/
      route.ts
    marketplace/
      [id]/
        clone/
          route.ts
        comments/
          route.ts
        ratings/
          route.ts
        route.ts
      check/
        [deckId]/
          route.ts
      user/
        [userId]/
          route.ts
      route.ts
    review-log/
      route.ts
    stats/
      route.ts
    study-sessions/
      route.ts
    translate/
      route.ts
  dashboard/
    DashboardClient.tsx
    page.tsx
    StudyStatsChart.tsx
  decks/
    [id]/
      DeckPageClient.tsx
      page.tsx
    DecksClient.tsx
    page.tsx
  marketplace/
    DeckCommentsDialog.tsx
    DeckRatingDialog.tsx
    MarketplaceClient.tsx
    page.tsx
  review/
    page.tsx
    ReviewCompletion.tsx
    ReviewDeckSelector.tsx
    ReviewPageClient.tsx
    ReviewSession.tsx
  globals.css
  HomeClient.tsx
  layout.tsx
  page.tsx
components/
  ui/
    accordion.tsx
    alert-dialog.tsx
    alert.tsx
    aspect-ratio.tsx
    avatar.tsx
    badge.tsx
    breadcrumb.tsx
    button.tsx
    calendar.tsx
    card.tsx
    carousel.tsx
    chart.tsx
    checkbox.tsx
    collapsible.tsx
    command.tsx
    context-menu.tsx
    dialog.tsx
    drawer.tsx
    dropdown-menu.tsx
    form.tsx
    hover-card.tsx
    input-otp.tsx
    input.tsx
    label.tsx
    menubar.tsx
    navigation-menu.tsx
    pagination.tsx
    popover.tsx
    progress.tsx
    radio-group.tsx
    resizable.tsx
    scroll-area.tsx
    select.tsx
    separator.tsx
    sheet.tsx
    skeleton.tsx
    slider.tsx
    sonner.tsx
    switch.tsx
    table.tsx
    tabs.tsx
    textarea.tsx
    toast.tsx
    toaster.tsx
    toggle-group.tsx
    toggle.tsx
    tooltip.tsx
  DeckLabelInput.tsx
  Flashcard.tsx
  FlipCard.tsx
  mode-toggle.tsx
  Navbar.tsx
  SessionProvider.tsx
  SignInButton.tsx
  theme-provider.tsx
  TranslationFlashcardDialog.tsx
hooks/
  use-toast.ts
lib/
  auth.ts
  db.ts
  error-handler.ts
  fsrs.ts
  huggingface.ts
  migrate.ts
  rate-limiter.ts
  schema.ts
  types.ts
  utils.ts
migrations/
  meta/
    _journal.json
    0000_snapshot.json
    0001_snapshot.json
    0002_snapshot.json
    0003_snapshot.json
    0004_snapshot.json
    0005_snapshot.json
    0006_snapshot.json
  0000_low_silver_fox.sql
  0001_outstanding_typhoid_mary.sql
  0002_cold_quentin_quire.sql
  0003_chubby_morph.sql
  0004_supreme_rocket_raccoon.sql
  0005_striped_ultron.sql
  0006_condemned_terror.sql
test-utils/
  db-mocks.ts
  mocks.ts
  setup.tsx
  wrapper.tsx
types/
  vitest.d.ts
.eslintrc.json
.gitignore
.npmrc
components.json
drizzle.config.ts
LICENSE
next.config.js
package.json
postcss.config.js
README.md
tailwind.config.ts
tsconfig.json
tsconfig.test.json
vercel.json
vite.config.ts
vitest.setup.ts

================================================================
Repository Files
================================================================

================
File: app/api/auth/[...nextauth]/route.ts
================
import NextAuth from "next-auth";
import { authOptions } from "@/lib/auth";

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };

================
File: app/api/auth/db/route.ts
================
import { NextResponse } from 'next/server';
import { getDb } from '@/lib/db';
import { deck, flashcard } from '@/lib/schema';
import { eq } from 'drizzle-orm/expressions';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const action = searchParams.get('action');
  const userId = searchParams.get('userId');

  const db = await getDb();

  if (action === 'getDecks' && userId) {
    const result = await db.select().from(deck).where(eq(deck.userId, userId));
    return NextResponse.json(result);
  }

  return NextResponse.json({ error: 'Invalid action' }, { status: 400 });
}

export async function POST(request: Request) {
  const body = await request.json();
  const { action, userId, title, description } = body;

  const db = await getDb();

  if (action === 'createDeck' && userId && title) {
    const now = Date.now(); // Get current timestamp as number
    const newDeck = {
      id: crypto.randomUUID(),
      userId: userId,
      title: title,
      description: description || '',
      createdAt: now,  // Use number timestamp instead of Date object
      updatedAt: now,  // Use number timestamp instead of Date object
    };

    const result = await db.insert(deck).values(newDeck);
    return NextResponse.json({ ...newDeck, ...result });
  }

  return NextResponse.json({ error: 'Invalid action' }, { status: 400 });
}

================
File: app/api/auth/error/page.tsx
================
'use client'

import { useSearchParams } from 'next/navigation'
import { Card, CardHeader, CardTitle, CardContent, CardFooter } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import Link from 'next/link'

export default function ErrorPage() {
  const searchParams = useSearchParams()
  const error = searchParams.get('error')

  const getErrorMessage = (error: string) => {
    switch (error) {
      case 'OAuthAccountNotLinked':
        return 'This email is already associated with an account. Please sign in using the original provider.'
      case 'AccessDenied':
        return 'Access denied. You do not have permission to access this resource.'
      case 'Verification':
        return 'The verification token has expired or has already been used.'
      default:
        return 'An error occurred during authentication. Please try again.'
    }
  }

  return (
    <div className="container flex items-center justify-center min-h-screen py-8">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle className="text-2xl font-semibold text-center text-red-600 dark:text-red-400">
            Authentication Error
          </CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-center text-gray-600 dark:text-gray-400">
            {error ? getErrorMessage(error) : 'An unknown error occurred'}
          </p>
        </CardContent>
        <CardFooter className="flex justify-center">
          <Button asChild>
            <Link href="/">
              Return to Home
            </Link>
          </Button>
        </CardFooter>
      </Card>
    </div>
  )
}

================
File: app/api/auth/signin/page.tsx
================
'use client'

import { signIn } from 'next-auth/react'
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card"
import { Button } from "@/components/ui/button"

export default function SignInPage() {
  return (
    <div className="container flex items-center justify-center min-h-screen py-8">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle className="text-2xl font-semibold text-center">
            Sign In
          </CardTitle>
        </CardHeader>
        <CardContent className="flex flex-col gap-4">
          <Button 
            onClick={() => signIn('google', { callbackUrl: '/dashboard' })}
            className="w-full"
          >
            Sign in with Google
          </Button>
        </CardContent>
      </Card>
    </div>
  )
}

================
File: app/api/decks/[id]/route.ts
================
import { NextResponse } from "next/server";
import { getDeck, updateDeck, deleteDeck } from '@/lib/db';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { z } from "zod";

const updateDeckSchema = z.object({
  title: z.string().min(1, "Title is required"),
  description: z.string().optional(),
  labels: z.array(z.string()).optional()
});

export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const deck = await getDeck(params.id);
    
    if (!deck) {
      return NextResponse.json(
        { error: 'Deck not found' },
        { status: 404 }
      );
    }

    return NextResponse.json(deck);
  } catch (error) {
    console.error('Error fetching deck:', error);
    return NextResponse.json(
      { error: 'Failed to fetch deck' },
      { status: 500 }
    );
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const validatedData = updateDeckSchema.parse(body);

    const updatedDeck = await updateDeck(
      params.id,
      validatedData.title,
      validatedData.description || '',
      validatedData.labels || []
    );

    return NextResponse.json(updatedDeck);
  } catch (error) {
    console.error('Error updating deck:', error);
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid request data', details: error.errors },
        { status: 400 }
      );
    }
    return NextResponse.json(
      { error: 'Failed to update deck' },
      { status: 500 }
    );
  }
}

export async function DELETE(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    await deleteDeck(params.id);
    return NextResponse.json({ message: 'Deck deleted successfully' });
  } catch (error) {
    console.error('Error deleting deck:', error);
    return NextResponse.json(
      { error: 'Failed to delete deck' },
      { status: 500 }
    );
  }
}

================
File: app/api/decks/due-count/route.ts
================
import { getDb } from "@/lib/db";
import { deck, flashcard } from "@/lib/schema";
import { and, eq, isNull, lte, or, sql } from "drizzle-orm";
import { NextResponse } from "next/server";

export async function GET(request: Request) {
    const { searchParams } = new URL(request.url);
    const userId = searchParams.get('userId');
  
    if (!userId) {
      return NextResponse.json({ error: 'UserId is required' }, { status: 400 });
    }
  
    const db = await getDb();
    const now = Date.now();
  
    const dueCards = await db
      .select({ count: sql<number>`count(*)` })
      .from(flashcard)
      .leftJoin(deck, eq(deck.id, flashcard.deckId))
      .where(
        and(
          eq(deck.userId, userId),
          or(
            isNull(flashcard.nextReview),
            lte(flashcard.nextReview, now)
          )
        )
      )
      .get();
  
    return NextResponse.json({ count: dueCards?.count || 0 });
  }

================
File: app/api/decks/route.ts
================
import { NextResponse } from 'next/server';
import { getDecks, createDeck } from '@/lib/db';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { z } from 'zod';

const createDeckSchema = z.object({
  title: z.string().min(1, "Title is required"),
  description: z.string().optional(),
  labels: z.array(z.string()).optional()
});

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const userId = searchParams.get('userId');

    if (!userId) {
      return NextResponse.json(
        { error: 'UserId is required' },
        { status: 400 }
      );
    }

    const decks = await getDecks(userId);
    return NextResponse.json(decks);
  } catch (error) {
    console.error('Error fetching decks:', error);
    return NextResponse.json(
      { error: 'Failed to fetch decks' },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized - Please sign in' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const validatedData = createDeckSchema.parse(body);

    const newDeck = await createDeck(
      session.user.id,
      validatedData.title,
      validatedData.description || '',
      validatedData.labels || []
    );

    return NextResponse.json(newDeck);
  } catch (error) {
    console.error('Error in POST /api/decks:', error);
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid request data', details: error.errors },
        { status: 400 }
      );
    }
    return NextResponse.json(
      { error: 'Failed to create deck' },
      { status: 500 }
    );
  }
}

================
File: app/api/flashcards/[id]/route.ts
================
// app/api/flashcards/[id]/route.ts
import { NextResponse } from 'next/server';
import { getDb, updateFlashcard } from '@/lib/db';
import { z } from 'zod';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { deck, deckRating, flashcard } from '@/lib/schema';
import { eq, and } from 'drizzle-orm'
// Validation schema for review data

const reviewDataSchema = z.object({
  lastReviewed: z.number(),
  nextReview: z.number().nullable(), // Allow null
  state: z.enum(['new', 'learning', 'review', 'relearning']),
  stability: z.number().transform(n => {
    // Clamp extremely large numbers to a reasonable maximum
    return Math.min(n, Number.MAX_SAFE_INTEGER);
  }),
  difficulty: z.number(),
  elapsedDays: z.number(),
  scheduledDays: z.number().transform(n => {
    // Clamp extremely large numbers to a reasonable maximum
    return Math.min(n, Number.MAX_SAFE_INTEGER);
  }),
  reps: z.number(),
  lapses: z.number()
});

const updateSchema = z.object({
  front: z.string().min(1, "Front content is required"),
  back: z.string().min(1, "Back content is required"),
  reviewData: reviewDataSchema
});


export async function PUT(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const body = await request.json();
    console.log('Received update request:', {
      id: params.id,
      body: JSON.stringify(body, null, 2)
    });

    // Validate session
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Transform the data to handle state updates
    const reviewData = {
      ...body.reviewData,
      // Ensure nextReview is properly calculated
      nextReview: body.reviewData.nextReview !== null ? 
        body.reviewData.nextReview : 
        Date.now() + (body.reviewData.scheduledDays * 24 * 60 * 60 * 1000),
      // Clamp values to prevent overflow
      stability: Math.min(Number(body.reviewData.stability), 365 * 10), // Max 10 years
      scheduledDays: Math.min(Number(body.reviewData.scheduledDays), 365) // Max 1 year
    };

    const updatedCard = await updateFlashcard(
      params.id,
      body.front,
      body.back,
      reviewData
    );

    return NextResponse.json(updatedCard);

  } catch (error) {
    console.error('Server error:', error);
    return NextResponse.json({
      error: 'Server error',
      message: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}
export async function GET(request: Request) {
  try {
    // Get the authenticated session
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized - Please sign in' },
        { status: 401 }
      );
    }

    // Get deck ID from query params
    const { searchParams } = new URL(request.url);
    const deckId = searchParams.get('deckId');

    if (!deckId) {
      return NextResponse.json(
        { error: 'DeckId is required' },
        { status: 400 }
      );
    }

    const db = await getDb();

    // First verify the deck exists and belongs to the user
    const deckExists = await db
      .select()
      .from(deck)
      .where(eq(deck.id, deckId))
      .get();

    if (!deckExists) {
      return NextResponse.json(
        { error: `Deck ${deckId} not found` },
        { status: 404 }
      );
    }

    if (deckExists.userId !== session.user.id) {
      return NextResponse.json(
        { error: 'You do not have permission to access this deck' },
        { status: 403 }
      );
    }

    // Fetch flashcards
    const flashcards = await db
      .select()
      .from(flashcard)
      .where(eq(flashcard.deckId, deckId));

    // Return the flashcards
    return NextResponse.json(flashcards);

  } catch (error) {
    console.error('Error fetching flashcards:', error);
    return NextResponse.json(
      { 
        error: 'Failed to fetch flashcards',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

export async function POST(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const { rating } = await request.json();
    
    if (!rating || rating < 1 || rating > 5) {
      return NextResponse.json(
        { error: 'Invalid rating value' },
        { status: 400 }
      );
    }

    const db = await getDb();

    // Check if user has already rated this deck
    const existingRating = await db
      .select()
      .from(deckRating)
      .where(
        and(
          eq(deckRating.sharedDeckId, params.id),
          eq(deckRating.userId, session.user.id)
        )
      )
      .get();

    if (existingRating) {
      // Update existing rating
      await db
        .update(deckRating)
        .set({
          rating,
          updatedAt: Date.now()
        })
        .where(eq(deckRating.id, existingRating.id));
    } else {
      // Create new rating
      await db.insert(deckRating).values({
        id: crypto.randomUUID(),
        sharedDeckId: params.id,
        userId: session.user.id,
        rating,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    }

    // Calculate new average rating
    const ratings = await db
      .select({
        rating: deckRating.rating
      })
      .from(deckRating)
      .where(eq(deckRating.sharedDeckId, params.id));

    const average = ratings.reduce((acc, curr) => acc + curr.rating, 0) / ratings.length;

    return NextResponse.json({
      message: 'Rating submitted successfully',
      averageRating: average,
      ratingCount: ratings.length
    });

  } catch (error) {
    console.error('Error submitting rating:', error);
    return NextResponse.json(
      { error: 'Failed to submit rating' },
      { status: 500 }
    );
  }
}

================
File: app/api/flashcards/route.ts
================
// app/api/flashcards/route.ts
import { NextResponse } from 'next/server';
import { getFlashcards, createFlashcard } from '@/lib/db';
import { z } from 'zod';
import { authOptions } from '@/lib/auth';
import { getServerSession } from 'next-auth';
import { getDb } from '@/lib/db';
import { deck, flashcard } from '@/lib/schema';
import { eq } from 'drizzle-orm';

const createFlashcardSchema = z.object({
  deckId: z.string().min(1, "Deck ID is required"),
  front: z.string().min(1, "Front content is required"),
  back: z.string().min(1, "Back content is required")
});

export async function GET(request: Request) {
  try {
    // Get the authenticated session
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized - Please sign in' },
        { status: 401 }
      );
    }

    // Get deck ID from query params
    const { searchParams } = new URL(request.url);
    const deckId = searchParams.get('deckId');

    if (!deckId) {
      return NextResponse.json(
        { error: 'DeckId is required' },
        { status: 400 }
      );
    }

    const db = await getDb();

    // First verify the deck exists and belongs to the user
    const deckExists = await db
      .select()
      .from(deck)
      .where(eq(deck.id, deckId))
      .get();

    if (!deckExists) {
      return NextResponse.json(
        { error: `Deck ${deckId} not found` },
        { status: 404 }
      );
    }

    if (deckExists.userId !== session.user.id) {
      return NextResponse.json(
        { error: 'You do not have permission to access this deck' },
        { status: 403 }
      );
    }

    // Fetch flashcards
    const flashcards = await db
      .select()
      .from(flashcard)
      .where(eq(flashcard.deckId, deckId));

    // Return the flashcards
    return NextResponse.json(flashcards);

  } catch (error) {
    console.error('Error fetching flashcards:', error);
    return NextResponse.json(
      { 
        error: 'Failed to fetch flashcards',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  try {
    const { deckId, front, back } = await request.json();

    if (!deckId || !front || !back) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    const newFlashcard = await createFlashcard(deckId, front, back);
    return NextResponse.json(newFlashcard);

  } catch (error) {
    console.error('Error creating flashcard:', error);
    return NextResponse.json(
      { error: 'Failed to create flashcard' },
      { status: 500 }
    );
  }
}

================
File: app/api/labels/route.ts
================
// app/api/labels/route.ts
import { NextResponse } from 'next/server';
import { getDb } from '@/lib/db';
import { label } from '@/lib/schema';
import { eq } from 'drizzle-orm';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function GET(request: Request) {
  try {
    const db = await getDb();
    const labels = await db
      .select({
        id: label.id,
        name: label.name,
        createdAt: label.createdAt
      })
      .from(label)
      .orderBy(label.name);

    return NextResponse.json(labels);
  } catch (error) {
    console.error('Error fetching labels:', error);
    return NextResponse.json(
      { error: 'Failed to fetch labels' },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const { name } = await request.json();
    
    if (!name) {
      return NextResponse.json(
        { error: 'Label name is required' },
        { status: 400 }
      );
    }

    const db = await getDb();

    // Check if label already exists
    const existingLabel = await db
      .select()
      .from(label)
      .where(eq(label.name, name))
      .get();

    if (existingLabel) {
      return NextResponse.json(existingLabel);
    }

    // Create new label
    const newLabel = {
      id: crypto.randomUUID(),
      name,
      createdAt: Date.now()
    };

    await db.insert(label).values(newLabel);
    return NextResponse.json(newLabel);

  } catch (error) {
    console.error('Error creating label:', error);
    return NextResponse.json(
      { error: 'Failed to create label' },
      { status: 500 }
    );
  }
}

================
File: app/api/marketplace/[id]/clone/route.ts
================
import { NextResponse } from 'next/server';
import { getDb } from '@/lib/db';
import { sharedDeck, deck, flashcard } from '@/lib/schema';
import { eq, and } from 'drizzle-orm';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function POST(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const db = await getDb();

    // First check if user already has this deck
    const existingDeck = await db
      .select()
      .from(deck)
      .where(
        and(
          eq(deck.userId, session.user.id),
          eq(deck.originalSharedDeckId, params.id)
        )
      )
      .get();

    if (existingDeck) {
      return NextResponse.json(
        { error: 'You already have this deck in your collection' },
        { status: 400 }
      );
    }

    const sharedDeckData = await db
      .select()
      .from(sharedDeck)
      .where(eq(sharedDeck.id, params.id))
      .get();

    if (!sharedDeckData) {
      return NextResponse.json(
        { error: 'Deck not found' },
        { status: 404 }
      );
    }

    const originalFlashcards = await db
      .select()
      .from(flashcard)
      .where(eq(flashcard.deckId, sharedDeckData.originalDeckId));

    let newDeckId: string | null = null;

    await db.transaction(async (tx) => {
      // Create the new deck, now including originalSharedDeckId to track its origin
      const newDeck = {
        id: crypto.randomUUID(),
        userId: session.user.id,
        title: `${sharedDeckData.title} (Copied)`,
        description: sharedDeckData.description || '',
        createdAt: Date.now(),
        updatedAt: Date.now(),
        originalSharedDeckId: params.id, // Store the ID of the shared deck it was copied from
      };

      await tx.insert(deck).values(newDeck);
      newDeckId = newDeck.id;

      if (originalFlashcards.length > 0) {
        const newFlashcards = originalFlashcards.map(card => ({
          id: crypto.randomUUID(),
          deckId: newDeck.id,
          front: card.front,
          back: card.back,
          audio: card.audio,
          createdAt: Date.now(),
          updatedAt: Date.now(),
          lastReviewed: null,
          nextReview: null,
          state: 'new' as const,
          stability: 1,
          difficulty: 5,
          elapsedDays: 0,
          scheduledDays: 0,
          reps: 0,
          lapses: 0,
          interval: 0,
          easeFactor: 250,
        }));

        if (newFlashcards.length > 0) {
          await tx.insert(flashcard).values(newFlashcards);
        }
      }

      await tx
        .update(sharedDeck)
        .set({
          downloads: sharedDeckData.downloads + 1,
          updatedAt: Date.now()
        })
        .where(eq(sharedDeck.id, params.id));
    });

    return NextResponse.json({
      message: 'Deck cloned successfully',
      deckId: newDeckId
    });

  } catch (error) {
    console.error('Error cloning deck:', error);
    return NextResponse.json(
      { error: 'Failed to clone deck' },
      { status: 500 }
    );
  }
}


export async function DELETE(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const db = await getDb();

    const sharedDeckData = await db
      .select()
      .from(sharedDeck)
      .where(
        eq(sharedDeck.id, params.id)
      )
      .get();

    if (!sharedDeckData) {
      return NextResponse.json(
        { error: 'Deck not found' },
        { status: 404 }
      );
    }

    if (sharedDeckData.userId !== session.user.id) {
      return NextResponse.json(
        { error: 'You can only remove your own shared decks' },
        { status: 403 }
      );
    }

    await db
      .delete(sharedDeck)
      .where(eq(sharedDeck.id, params.id));

    return NextResponse.json({
      message: 'Deck removed from marketplace successfully'
    });

  } catch (error) {
    console.error('Error removing shared deck:', error);
    return NextResponse.json(
      { error: 'Failed to remove deck from marketplace' },
      { status: 500 }
    );
  }
}

================
File: app/api/marketplace/[id]/comments/route.ts
================
import { getDb } from "@/lib/db";
import { deckComment, user } from "@/lib/schema";
import { NextResponse } from "next/server";
import { eq } from "drizzle-orm";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";

export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const db = await getDb();

    // Join with user table to get commenter information
    const comments = await db
      .select({
        id: deckComment.id,
        content: deckComment.content,
        createdAt: deckComment.createdAt,
        user: {
          id: user.id,
          name: user.name,
          image: user.image,
        }
      })
      .from(deckComment)
      .leftJoin(user, eq(deckComment.userId, user.id))
      .where(eq(deckComment.sharedDeckId, params.id))
      .orderBy(deckComment.createdAt);

    return NextResponse.json(comments);
  } catch (error) {
    console.error('Error fetching comments:', error);
    return NextResponse.json(
      { error: 'Failed to fetch comments' },
      { status: 500 }
    );
  }
}

export async function POST(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const { content } = await request.json();

    if (!content?.trim()) {
      return NextResponse.json(
        { error: 'Comment content is required' },
        { status: 400 }
      );
    }

    const db = await getDb();

    const newComment = {
      id: crypto.randomUUID(),
      sharedDeckId: params.id,
      userId: session.user.id,
      content: content.trim(),
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };

    await db.insert(deckComment).values(newComment);

    // Fetch the complete comment with user information
    const commentWithUser = await db
      .select({
        id: deckComment.id,
        content: deckComment.content,
        createdAt: deckComment.createdAt,
        user: {
          id: user.id,
          name: user.name,
          image: user.image,
        }
      })
      .from(deckComment)
      .leftJoin(user, eq(deckComment.userId, user.id))
      .where(eq(deckComment.id, newComment.id))
      .get();

    return NextResponse.json(commentWithUser);
  } catch (error) {
    console.error('Error adding comment:', error);
    return NextResponse.json(
      { error: 'Failed to add comment' },
      { status: 500 }
    );
  }
}

================
File: app/api/marketplace/[id]/ratings/route.ts
================
// app/api/marketplace/[id]/ratings/route.ts
import { getDb } from "@/lib/db";
import { deckRating, sharedDeck } from "@/lib/schema";
import { NextResponse } from "next/server";
import { and, eq } from "drizzle-orm";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";

export async function POST(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const { rating } = await request.json();
    
    if (!rating || rating < 1 || rating > 5) {
      return NextResponse.json(
        { error: 'Invalid rating value' },
        { status: 400 }
      );
    }

    const db = await getDb();

    // Check if user has already rated this deck
    const existingRating = await db
      .select()
      .from(deckRating)
      .where(
        and(
          eq(deckRating.sharedDeckId, params.id),
          eq(deckRating.userId, session.user.id)
        )
      )
      .get();

    if (existingRating) {
      // Update existing rating
      await db
        .update(deckRating)
        .set({
          rating,
          updatedAt: Date.now()
        })
        .where(eq(deckRating.id, existingRating.id));
    } else {
      // Create new rating
      await db.insert(deckRating).values({
        id: crypto.randomUUID(),
        sharedDeckId: params.id,
        userId: session.user.id,
        rating,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    }

    // Calculate new average rating
    const ratings = await db
      .select({
        rating: deckRating.rating
      })
      .from(deckRating)
      .where(eq(deckRating.sharedDeckId, params.id));

    const average = ratings.reduce((acc, curr) => acc + curr.rating, 0) / ratings.length;

    return NextResponse.json({
      message: 'Rating submitted successfully',
      averageRating: average,
      ratingCount: ratings.length
    });

  } catch (error) {
    console.error('Error submitting rating:', error);
    return NextResponse.json(
      { error: 'Failed to submit rating' },
      { status: 500 }
    );
  }
}

================
File: app/api/marketplace/[id]/route.ts
================
// app/api/marketplace/[id]/route.ts
import { NextResponse } from "next/server";
import { getDb } from '@/lib/db';
import { sharedDeck, deck, flashcard } from '@/lib/schema';
import { eq } from 'drizzle-orm';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

// GET a specific shared deck
export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const db = await getDb();
    const sharedDeckData = await db
      .select()
      .from(sharedDeck)
      .where(eq(sharedDeck.id, params.id))
      .get();

    if (!sharedDeckData) {
      return NextResponse.json(
        { error: 'Deck not found' },
        { status: 404 }
      );
    }

    return NextResponse.json(sharedDeckData);
  } catch (error) {
    console.error('Error fetching shared deck:', error);
    return NextResponse.json(
      { error: 'Failed to fetch deck' },
      { status: 500 }
    );
  }
}

// DELETE a shared deck
export async function DELETE(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const db = await getDb();

    // Verify the deck exists and belongs to the user
    const sharedDeckData = await db
      .select()
      .from(sharedDeck)
      .where(eq(sharedDeck.id, params.id))
      .get();

    if (!sharedDeckData) {
      return NextResponse.json(
        { error: 'Deck not found' },
        { status: 404 }
      );
    }

    if (sharedDeckData.userId !== session.user.id) {
      return NextResponse.json(
        { error: 'You can only remove your own shared decks' },
        { status: 403 }
      );
    }

    // Delete the shared deck (cascading will handle related records)
    await db
      .delete(sharedDeck)
      .where(eq(sharedDeck.id, params.id));

    return NextResponse.json({
      success: true,
      message: 'Deck removed from marketplace successfully'
    });

  } catch (error) {
    console.error('Error removing shared deck:', error);
    return NextResponse.json(
      { error: 'Failed to remove deck from marketplace' },
      { status: 500 }
    );
  }
}

// Update a shared deck
export async function PATCH(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { title, description } = body;

    const db = await getDb();

    // Verify ownership
    const existingDeck = await db
      .select()
      .from(sharedDeck)
      .where(eq(sharedDeck.id, params.id))
      .get();

    if (!existingDeck) {
      return NextResponse.json(
        { error: 'Deck not found' },
        { status: 404 }
      );
    }

    if (existingDeck.userId !== session.user.id) {
      return NextResponse.json(
        { error: 'You can only update your own shared decks' },
        { status: 403 }
      );
    }

    // Update the deck
    await db
      .update(sharedDeck)
      .set({
        title: title || existingDeck.title,
        description: description || existingDeck.description,
        updatedAt: Date.now()
      })
      .where(eq(sharedDeck.id, params.id));

    const updatedDeck = await db
      .select()
      .from(sharedDeck)
      .where(eq(sharedDeck.id, params.id))
      .get();

    return NextResponse.json(updatedDeck);

  } catch (error) {
    console.error('Error updating shared deck:', error);
    return NextResponse.json(
      { error: 'Failed to update deck' },
      { status: 500 }
    );
  }
}

================
File: app/api/marketplace/check/[deckId]/route.ts
================
import { NextResponse } from 'next/server';
import { getDb } from '@/lib/db';
import { sharedDeck } from '@/lib/schema';
import { eq } from 'drizzle-orm';

export async function GET(
  request: Request,
  { params }: { params: { deckId: string } }
) {
  try {
    const db = await getDb();
    const shared = await db
      .select()
      .from(sharedDeck)
      .where(eq(sharedDeck.originalDeckId, params.deckId))
      .get();

    return NextResponse.json({ isShared: !!shared });
  } catch (error) {
    return NextResponse.json({ error: 'Failed to check shared status' }, { status: 500 });
  }
}

================
File: app/api/marketplace/user/[userId]/route.ts
================
import { NextResponse } from 'next/server';
import { getDb } from '@/lib/db';
import { sharedDeck, deckRating } from '@/lib/schema';
import { eq, and, sql } from 'drizzle-orm';

export async function GET(
  request: Request,
  { params }: { params: { userId: string } }
) {
  try {
    const db = await getDb();
    const decks = await db
      .select({
        id: sharedDeck.id,
        title: sharedDeck.title,
        description: sharedDeck.description,
        downloads: sharedDeck.downloads,
        createdAt: sharedDeck.createdAt,
        userId: sharedDeck.userId,
        averageRating: sql<number>`COALESCE(AVG(${deckRating.rating}), 0)`.as('averageRating'),
        ratingCount: sql<number>`COUNT(${deckRating.id})`.as('ratingCount'),
      })
      .from(sharedDeck)
      .leftJoin(deckRating, eq(sharedDeck.id, deckRating.sharedDeckId))
      .where(eq(sharedDeck.userId, params.userId))
      .groupBy(sharedDeck.id);

    return NextResponse.json(decks);
  } catch (error) {
    return NextResponse.json({ error: 'Failed to fetch shared decks' }, { status: 500 });
  }
}

================
File: app/api/marketplace/route.ts
================
import { NextResponse } from 'next/server';
import { getDb } from '@/lib/db';
import { sharedDeck, user, deckRating, deck, deckLabel, label } from '@/lib/schema';
import { eq, sql } from 'drizzle-orm';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function GET(request: Request) {
  try {
    const db = await getDb();
    
    const decks = await db
      .select({
        id: sharedDeck.id,
        title: sharedDeck.title,
        description: sharedDeck.description,
        downloads: sharedDeck.downloads,
        createdAt: sharedDeck.createdAt,
        userId: sharedDeck.userId,
        user: {
          name: user.name,
          image: user.image,
        },
        averageRating: sql<number>`COALESCE(AVG(${deckRating.rating}), 0)`.as('averageRating'),
        ratingCount: sql<number>`COUNT(${deckRating.id})`.as('ratingCount'),
        labels: sql<string[]>`JSON_GROUP_ARRAY(DISTINCT CASE WHEN ${label.name} IS NULL THEN NULL ELSE ${label.name} END)`.as('labels'),
      })
      .from(sharedDeck)
      .leftJoin(user, eq(sharedDeck.userId, user.id))
      .leftJoin(deckRating, eq(sharedDeck.id, deckRating.sharedDeckId))
      .leftJoin(deck, eq(sharedDeck.originalDeckId, deck.id))
      .leftJoin(deckLabel, eq(deck.id, deckLabel.deckId))
      .leftJoin(label, eq(deckLabel.labelId, label.id))
      .groupBy(sharedDeck.id, user.name, user.image);

    const transformedDecks = decks.map(deck => ({
      ...deck,
      labels: deck.labels[0] === null ? [] 
        : Array.from(new Set(JSON.parse(deck.labels.toString())))
    }));

    return NextResponse.json(transformedDecks);
  } catch (error) {
    console.error('Error fetching shared decks:', error);
    return NextResponse.json(
      { error: 'Failed to fetch decks' }, 
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const { deckId } = await request.json();

    if (!deckId) {
      return NextResponse.json(
        { error: 'Deck ID is required' },
        { status: 400 }
      );
    }

    const db = await getDb(); // Change this line

    // First check if the deck is already shared
    const existingShared = await db
      .select()
      .from(sharedDeck)
      .where(eq(sharedDeck.originalDeckId, deckId))
      .get();

    if (existingShared) {
      return NextResponse.json(
        { error: 'Deck is already shared' },
        { status: 400 }
      );
    }

    // Fetch the original deck to get its details
    const originalDeck = await db
      .select()
      .from(deck)
      .where(eq(deck.id, deckId))
      .get();

    if (!originalDeck) {
      return NextResponse.json(
        { error: 'Deck not found' },
        { status: 404 }
      );
    }

    if (originalDeck.userId !== session.user.id) {
      return NextResponse.json(
        { error: 'You can only share your own decks' },
        { status: 403 }
      );
    }

    // Check if the deck is a clone from marketplace
    if (originalDeck.originalSharedDeckId) {
      return NextResponse.json(
        { error: 'Cloned decks from the marketplace cannot be shared' },
        { status: 403 }
      );
    }

    const sharedDeckData = {
      id: crypto.randomUUID(),
      originalDeckId: deckId,
      userId: session.user.id,
      title: originalDeck.title,
      description: originalDeck.description,
      createdAt: Date.now(),
      updatedAt: Date.now(),
      downloads: 0,
      isPublic: true
    };

    await db.insert(sharedDeck).values(sharedDeckData);

    return NextResponse.json({
      message: 'Deck shared successfully',
      deck: sharedDeckData
    });

  } catch (error) {
    console.error('Error sharing deck:', error);
    return NextResponse.json(
      { 
        error: 'Failed to share deck',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

================
File: app/api/review-log/route.ts
================
// app/api/review-log/route.ts
import { NextResponse } from 'next/server';
import { createReviewLog } from '@/lib/db';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { 
      flashcardId, 
      rating, 
      reviewData: {
        stability,
        difficulty,
        elapsedDays,
        scheduledDays,
        responseTime
      }
    } = body;

    const result = await createReviewLog(
      session.user.id,
      flashcardId,
      rating,
      {
        stability,
        difficulty,
        elapsedDays,
        scheduledDays,
        responseTime
      }
    );

    return NextResponse.json(result);
  } catch (error) {
    console.error('Error creating review log:', error);
    return NextResponse.json(
      { error: 'Failed to create review log' },
      { status: 500 }
    );
  }
}

================
File: app/api/stats/route.ts
================
import { NextResponse } from 'next/server';
import { getStudyStats } from '@/lib/db';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const userId = searchParams.get('userId');

  if (!userId) {
    return NextResponse.json({ error: 'UserId is required' }, { status: 400 });
  }

  try {
    const stats = await getStudyStats(userId);
    console.log('API stats response:', stats); 
    return NextResponse.json(stats);
  } catch (error) {
    console.error('Error fetching stats:', error);
    
    if (error instanceof Error && error.message.includes('connect')) {
      return NextResponse.json(
        { error: 'Database connection error. Please try again later.' },
        { status: 503 }
      );
    }

    return NextResponse.json(
      { error: 'Failed to fetch stats. Please try again.' },
      { status: 500 }
    );
  }
}

================
File: app/api/study-sessions/route.ts
================
import { NextResponse } from 'next/server';
import { createStudySession } from '@/lib/db';

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { userId, cardsStudied, startTime, endTime, correctCount, incorrectCount, averageTime } = body;

    if (!userId || !cardsStudied || !startTime || !endTime) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    const result = await createStudySession(
      userId,
      cardsStudied,
      new Date(startTime),
      new Date(endTime),
      correctCount || 0,
      incorrectCount || 0,
      averageTime || 0
    );

    // Return the created session data
    return NextResponse.json({ success: true, data: result });
  } catch (error) {
    console.error('Error creating study session:', error);
    return NextResponse.json(
      { error: 'Failed to create study session' },
      { status: 500 }
    );
  }
}

================
File: app/api/translate/route.ts
================
import { NextResponse } from 'next/server';
import { getTranslation } from '@/lib/huggingface';
import { RateLimiter } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth';
import { authOptions } from "@/lib/auth";

export async function GET(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized', remaining: 0 },
        { status: 401 }
      );
    }

    const rateLimitStatus = await RateLimiter.getRemainingTranslations(session.user.id);

    return NextResponse.json({
      remaining: rateLimitStatus.remaining,
      isLimited: rateLimitStatus.isLimited,
      message: rateLimitStatus.message,
      resetIn: rateLimitStatus.resetIn
    });
  } catch (error) {
    console.error('Error checking translation limit:', error);
    return NextResponse.json(
      { error: 'Failed to check translation limit', remaining: 0 },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const rateLimitCheck = await RateLimiter.checkTranslationLimit(session.user.id);
    if (rateLimitCheck.isLimited) {
      return NextResponse.json(
        { 
          error: 'Rate limit exceeded',
          message: rateLimitCheck.message,
          resetIn: rateLimitCheck.resetIn
        },
        { status: 429 }
      );
    }

    const { text, sourceLang, targetLang } = await request.json();

    if (!text || !sourceLang || !targetLang) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    const result = await getTranslation(
      text,
      sourceLang,
      targetLang,
      process.env.HUGGINGFACE_API_TOKEN!
    );

    const remainingTranslations = await RateLimiter.getRemainingTranslations(session.user.id);

    return NextResponse.json({
      ...result,
      remaining: remainingTranslations.remaining
    });

  } catch (error) {
    console.error('Translation error:', error);
    return NextResponse.json(
      { 
        error: error instanceof Error ? error.message : 'Translation failed',
        details: process.env.NODE_ENV === 'development' ? error : undefined
      },
      { status: 500 }
    );
  }
}

================
File: app/dashboard/DashboardClient.tsx
================
'use client'
import React from 'react';
import { useSession } from "next-auth/react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Brain, Clock, Activity, Calendar, Settings2 } from "lucide-react";
import { StudySessionStats } from '@/lib/types';
import { formatStudyTime, formatTimeString } from '@/lib/utils';
import { toast } from '@/hooks/use-toast';
import StudyStatsChart from './StudyStatsChart';
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Button } from "@/components/ui/button";
import { Slider } from "@/components/ui/slider";
import { Label } from "@/components/ui/label";

export default function DashboardClient() {
  const { data: session } = useSession();
  const [studyStats, setStudyStats] = React.useState<StudySessionStats | null>(null);
  const [isLoading, setIsLoading] = React.useState(true);
  const [dailyGoal, setDailyGoal] = React.useState(100);
  const [dueCards, setDueCards] = React.useState(0);

  const fetchStats = React.useCallback(async () => {
    if (!session?.user?.id) return;

    try {
      const response = await fetch(`/api/stats?userId=${session.user.id}`);
      if (!response.ok) throw new Error('Failed to fetch stats');
      const data = await response.json();
      setStudyStats(data);

      // Fetch due cards count
      const dueResponse = await fetch(`/api/decks/due-count?userId=${session.user.id}`);
      if (dueResponse.ok) {
        const { count } = await dueResponse.json();
        setDueCards(count);
      }
    } catch (error) {
      console.error('Error fetching stats:', error);
      toast({
        title: "Error",
        description: "Failed to load statistics. Please try again later.",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [session?.user?.id]);

  React.useEffect(() => {
    fetchStats();
    const interval = setInterval(fetchStats, 30000);
    return () => clearInterval(interval);
  }, [fetchStats]);

  const studyTimeFormatted = React.useMemo(() => {
    return studyStats ? formatTimeString(formatStudyTime(studyStats.studyTimeToday)) : '0h 0m';
  }, [studyStats?.studyTimeToday]);

  const progressPercentage = Math.min(((studyStats?.totalCardsToday || 0) / dailyGoal) * 100, 100);
  const dueProgressPercentage = dueCards > 0 ? Math.min(((studyStats?.totalCardsToday || 0) / dueCards) * 100, 100) : 0;

  let content;

  if (isLoading) {
    content = (
      <div className="flex items-center justify-center min-h-[60vh]">
        <div className="text-lg text-neutral-600 dark:text-neutral-400">Loading...</div>
      </div>
    );
  } else if (!studyStats) {
    content = (
      <div className="flex items-center justify-center min-h-[60vh]">
        <div className="text-neutral-600 dark:text-neutral-400">No data available</div>
      </div>
    );
  } else {
    content = (
      <div className="container max-w-6xl mx-auto px-6 py-8">
        <div className="flex flex-col items-start gap-8">
          <div className="space-y-2">
            <h1 className="text-3xl font-light text-neutral-800 dark:text-white">
              Welcome back
            </h1>
            <p className="text-neutral-600 dark:text-neutral-400">
              Track your progress and keep up the momentum
            </p>
          </div>

          <div className="w-full flex flex-col gap-6">
            <Card className="dark:glass-card dark:border-white/5">
              <CardHeader className="pb-2">
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <Calendar className="h-5 w-5 text-blue-500" />
                    <CardTitle className="text-xl font-light">Today's Progress</CardTitle>
                  </div>
                  <Popover>
                    <PopoverTrigger asChild>
                      <Button variant="ghost" size="icon">
                        <Settings2 className="h-4 w-4" />
                      </Button>
                    </PopoverTrigger>
                    <PopoverContent className="w-80">
                      <div className="grid gap-4">
                        <div className="space-y-2">
                          <h4 className="font-medium leading-none">Daily Goal</h4>
                          <p className="text-sm text-muted-foreground">
                            Set your daily review target
                          </p>
                        </div>
                        <div className="grid gap-2">
                          <div className="grid grid-cols-3 items-center gap-4">
                            <Label htmlFor="goal">Cards</Label>
                            <Slider
                              id="goal"
                              max={300}
                              min={10}
                              step={10}
                              value={[dailyGoal]}
                              onValueChange={(value) => setDailyGoal(value[0])}
                              className="col-span-2"
                            />
                          </div>
                          <div className="text-right text-sm text-muted-foreground">
                            Target: {dailyGoal} cards
                          </div>
                        </div>
                      </div>
                    </PopoverContent>
                  </Popover>
                </div>
                <CardDescription>
                  {studyStats.studyTimeToday > 0
                    ? `${studyTimeFormatted} spent studying`
                    : 'No study time recorded today'}
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-6">
                <div className="space-y-2">
                  <div className="flex items-center justify-between text-sm">
                    <span className="text-neutral-600 dark:text-neutral-400">Daily Goal</span>
                    <span className="font-medium">{studyStats.totalCardsToday}/{dailyGoal} cards</span>
                  </div>
                  <Progress
                    value={progressPercentage}
                    className="h-2 dark:bg-white/5"
                  />
                </div>

                <div className="space-y-2">
                  <div className="flex items-center justify-between text-sm">
                    <span className="text-neutral-600 dark:text-neutral-400">Due Cards Progress</span>
                    {studyStats.totalCardsToday >= dueCards ? (
                      <span className="font-medium text-green-500">Completed!</span>
                    ) : (
                      <span className="font-medium">{studyStats.totalCardsToday}/{dueCards} cards</span>
                    )}
                  </div>
                  <Progress
                    value={dueProgressPercentage}
                    max={100}
                    className="h-2 dark:bg-white/5"
                  />
                </div>

                <div className="grid grid-cols-2 gap-8">
                  <div className="space-y-1">
                    <div className="flex items-center gap-2 text-sm text-neutral-600 dark:text-neutral-400">
                      <Brain className="w-4 h-4" />
                      Cards Reviewed
                    </div>
                    <p className="text-2xl font-light">{studyStats.totalCardsToday}</p>
                  </div>
                  <div className="space-y-1">
                    <div className="flex items-center gap-2 text-sm text-neutral-600 dark:text-neutral-400">
                      <Clock className="w-4 h-4" />
                      Study Time
                    </div>
                    <p className="text-2xl font-light">
                      {studyTimeFormatted}
                    </p>
                  </div>
                </div>
              </CardContent>
            </Card>

            <StudyStatsChart data={studyStats.lastThirtyDays} streak={studyStats.streak} />
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen">
      {content}
    </div>
  );
}

================
File: app/dashboard/page.tsx
================
import DashboardClient from './DashboardClient'

export default function DashboardPage() {
  return <DashboardClient />;
}

================
File: app/dashboard/StudyStatsChart.tsx
================
import React, { useMemo } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Activity, Target, Flame, BookOpen } from 'lucide-react';
import { 
  AreaChart, Area, XAxis, YAxis, Tooltip, 
  ResponsiveContainer, CartesianGrid
} from 'recharts';
import { StudyData } from '@/lib/types';
import { motion } from 'framer-motion';
import { formatStudyTime, formatTimeString } from '@/lib/utils';
import { Button } from "@/components/ui/button";
import Link from 'next/link';

interface StudyStatsChartProps {
  data: StudyData[];
  streak?: number;
}

const StatCard = ({ 
  icon: Icon, 
  label, 
  value, 
  subtext, 
  color = "text-primary",
}: { 
  icon: React.ElementType;
  label: string;
  value: string;
  subtext: string;
  color?: string;
}) => (
  <motion.div
    initial={{ opacity: 0, y: 20 }}
    animate={{ opacity: 1, y: 0 }}
    className="rounded-lg dark:bg-white/[0.02] border border-neutral-200/10 p-4"
  >
    <div className="flex items-center space-x-3">
      <div className={`p-3 ${color} bg-white/5 rounded-lg`}>
        <Icon className="h-5 w-5" />
      </div>
      <div>
        <p className="text-sm text-neutral-400">{label}</p>
        <p className="text-2xl font-light mt-0.5">{value}</p>
        <p className="text-sm text-neutral-500 mt-0.5">{subtext}</p>
      </div>
    </div>
  </motion.div>
);

const CustomTooltip = ({ active, payload }: any) => {
  if (!active || !payload?.[0]) return null;

  const data = payload[0].payload;
  const timeFormatted = formatTimeString(formatStudyTime(data.studyTime));
  const formattedDate = new Date(data.date).toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric'
  });

  return (
    <div className="dark:glass-card border border-white/10 p-4 shadow-xl rounded-lg">
      <div className="flex flex-col gap-2">
        <p className="text-sm font-medium dark:text-white">{formattedDate}</p>
        <div className="space-y-1">
          <div className="flex justify-between items-center gap-4">
            <span className="text-sm text-neutral-400">Cards Studied</span>
            <span className="text-sm font-medium text-blue-400">{data.count}</span>
          </div>
          <div className="flex justify-between items-center gap-4">
            <span className="text-sm text-neutral-400">Study Time</span>
            <span className="text-sm font-medium text-emerald-400">
              {timeFormatted}
            </span>
          </div>
        </div>
      </div>
    </div>
  );
};

const EmptyState = () => (
  <Card className="col-span-full dark:glass-card dark:border-white/5">
    <CardContent className="flex flex-col items-center justify-center py-16">
      <div className="w-16 h-16 bg-neutral-100 dark:bg-white/5 rounded-full flex items-center justify-center mb-6">
        <BookOpen className="w-8 h-8 text-neutral-500 dark:text-neutral-400" />
      </div>
      <h3 className="text-xl font-light text-neutral-800 dark:text-white mb-2">
        No Study Data Available
      </h3>
      <p className="text-neutral-600 dark:text-neutral-400 mb-6 text-center max-w-md">
        Start reviewing flashcards to see your study progress and statistics here.
      </p>
      <Button asChild className="dark:bg-white dark:text-black dark:hover:bg-neutral-200">
        <Link href="/decks">
          Start Studying
        </Link>
      </Button>
    </CardContent>
  </Card>
);

export default function StudyStatsChart({ data, streak = 0 }: StudyStatsChartProps) {
  // Check if there's no study data
  if (!data || data.length === 0) {
    return <EmptyState />;
  }

  // Check if there's any actual study activity in the data
  const hasStudyActivity = data.some(day => day.count > 0 || day.studyTime > 0);
  if (!hasStudyActivity) {
    return <EmptyState />;
  }

  const processedData = useMemo(() => {
    const today = new Date();
    const fourteenDaysAgo = new Date(today);
    fourteenDaysAgo.setDate(today.getDate() - 13);

    // Create a lookup object
    const dataLookup = Object.fromEntries(
      data.map(item => [item.date, item])
    );
    
    const dates = [];
    for (let d = new Date(fourteenDaysAgo); d <= today; d.setDate(d.getDate() + 1)) {
      const dateStr = d.toISOString().split('T')[0];
      const dayData = dataLookup[dateStr] || { count: 0, studyTime: 0 };
      
      dates.push({
        date: dateStr,
        displayDate: d.toLocaleDateString('en-US', { weekday: 'short' }),
        count: dayData.count,
        studyTime: dayData.studyTime,
        isToday: dateStr === today.toISOString().split('T')[0]
      });
    }
    
    return dates;
  }, [data]);

  const stats = useMemo(() => {
    const activeDays = data.filter(day => day.count > 0);
    const totalCards = activeDays.reduce((sum, day) => sum + day.count, 0);
    const bestDay = [...data].sort((a, b) => b.count - a.count)[0];
    const averageCards = activeDays.length > 0 ? Math.round(totalCards / activeDays.length) : 0;

    return {
      totalCards,
      bestDay: {
        date: bestDay ? new Date(bestDay.date).toLocaleDateString('en-US', {
          month: 'short',
          day: 'numeric'
        }) : 'N/A',
        count: bestDay?.count || 0,
      },
      averageCards,
      activeDays: activeDays.length
    };
  }, [data]);

  return (
    <Card className="col-span-full dark:glass-card dark:border-white/5">
      <CardHeader className="pb-4">
        <div className="flex flex-col space-y-4">
          <CardTitle className="flex items-center gap-2 text-xl font-light">
            <Activity className="h-5 w-5 text-blue-500" />
            Study Progress
          </CardTitle>
          <div className="grid grid-cols-3 gap-4">
            <StatCard
              icon={Target}
              label="Best Session"
              value={stats.bestDay.count.toString()}
              subtext={stats.bestDay.date}
              color="text-amber-500"
            />
            <StatCard
              icon={Flame}
              label="Current Streak"
              value={streak.toString()}
              subtext={`day${streak === 1 ? '' : 's'}`}
              color="text-blue-500"
            />
            <StatCard
              icon={Activity}
              label="Daily Average"
              value={stats.averageCards.toString()}
              subtext={`over ${stats.activeDays} active day${stats.activeDays === 1 ? '' : 's'}`}
              color="text-emerald-500"
            />
          </div>
        </div>
      </CardHeader>
      <CardContent className="pt-6">
        <div className="h-[300px]">
          <ResponsiveContainer width="100%" height="100%">
            <AreaChart data={processedData} margin={{ top: 20, right: 20, bottom: 20, left: 20 }}>
              <defs>
                <linearGradient id="colorCards" x1="0" y1="0" x2="0" y2="1">
                  <stop offset="5%" stopColor="#3B82F6" stopOpacity={0.3}/>
                  <stop offset="95%" stopColor="#3B82F6" stopOpacity={0}/>
                </linearGradient>
              </defs>
              <CartesianGrid
                strokeDasharray="3 3"
                vertical={false}
                stroke="rgba(255,255,255,0.05)"
              />
              <XAxis
                dataKey="displayDate"
                axisLine={false}
                tickLine={false}
                tick={{
                  fill: 'rgba(255,255,255,0.5)',
                  fontSize: 12
                }}
                dy={10}
              />
              <YAxis
                axisLine={false}
                tickLine={false}
                tick={{
                  fill: 'rgba(255,255,255,0.5)',
                  fontSize: 12
                }}
                width={40}
              />
              <Tooltip content={<CustomTooltip />} />
              <Area
                type="monotone"
                dataKey="count"
                stroke="#3B82F6"
                fillOpacity={1}
                fill="url(#colorCards)"
                strokeWidth={2}
              />
            </AreaChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
    </Card>
  );
}

================
File: app/decks/[id]/DeckPageClient.tsx
================
'use client';

import React, { useState, useEffect } from 'react';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { useRouter } from 'next/navigation';
import { Deck, Flashcard } from '@/lib/types';
import {
  Card, CardContent, CardDescription,
  CardFooter, CardHeader, CardTitle
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import {
  Dialog, DialogContent, DialogHeader,
  DialogTitle, DialogTrigger
} from "@/components/ui/dialog";
import {
  Form, FormField, FormItem,
  FormLabel, FormControl, FormMessage
} from "@/components/ui/form";
import { Textarea } from "@/components/ui/textarea";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { useToast } from "@/hooks/use-toast";
import { motion, AnimatePresence } from 'framer-motion';
import {
  Plus, Edit2, Trash2, PlayCircle,
  Book, Clock, ChevronRight, Globe
} from 'lucide-react';
import { cn } from '@/lib/utils';
import TranslationFlashcardDialog from '@/components/TranslationFlashcardDialog';
import { formatTimestamp } from '@/lib/utils';
import { useSession } from "next-auth/react";

const flashcardSchema = z.object({
  front: z.string().min(1, "Front side is required"),
  back: z.string().min(1, "Back side is required")
});

interface DeckPageClientProps {
  initialDeck: Deck;
  initialFlashcards: Flashcard[];
}

type FlashcardFormData = z.infer<typeof flashcardSchema>;

interface DeckPageClientProps {
  initialDeck: Deck;
  initialFlashcards: Flashcard[];
}

export default function DeckPageClient({
  initialDeck,
  initialFlashcards
}: DeckPageClientProps) {
  const { data: session } = useSession();
  const [deck, setDeck] = useState<Deck>(initialDeck);
  const [flashcards, setFlashcards] = useState<Flashcard[]>(initialFlashcards);
  const [isCreating, setIsCreating] = useState(false);
  const [editingCard, setEditingCard] = useState<Flashcard | null>(null);
  const [isTranslationDialogOpen, setIsTranslationDialogOpen] = useState(false);
  const { toast } = useToast();
  const [isShared, setIsShared] = useState(false);
  const router = useRouter();

  const form = useForm<FlashcardFormData>({
    resolver: zodResolver(flashcardSchema),
    defaultValues: {
      front: "",
      back: ""
    }
  });

  const fetchFlashcards = async () => {
    try {
      // First ensure we have a valid deck ID
      if (!deck?.id) {
        console.error("Missing deck ID");
        return;
      }
  
      const response = await fetch(`/api/flashcards?deckId=${deck.id}`);
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to fetch flashcards');
      }
  
      const fetchedFlashcards = await response.json();
      
      // Validate the response data
      if (!Array.isArray(fetchedFlashcards)) {
        throw new Error('Invalid flashcards data received');
      }
  
      // Convert timestamps to proper format
      const processedFlashcards = fetchedFlashcards.map(card => ({
        ...card,
        createdAt: Number(card.createdAt),
        updatedAt: Number(card.updatedAt),
        lastReviewed: card.lastReviewed ? Number(card.lastReviewed) : null,
        nextReview: card.nextReview ? Number(card.nextReview) : null,
        stability: Number(card.stability),
        difficulty: Number(card.difficulty),
        elapsedDays: Number(card.elapsedDays),
        scheduledDays: Number(card.scheduledDays),
        reps: Number(card.reps),
        lapses: Number(card.lapses),
        interval: Number(card.interval),
        easeFactor: Number(card.easeFactor)
      }));
  
      setFlashcards(processedFlashcards);
    } catch (error) {
      console.error("Failed to fetch flashcards:", error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Failed to load flashcards",
        variant: "destructive",
      });
    }
  };

  useEffect(() => {
    if (!deck?.id) return;
    fetchFlashcards();
  }, [deck?.id]);

  useEffect(() => {
    const checkSharedStatus = async () => {
      try {
        const response = await fetch(`/api/marketplace/check/${deck.id}`);
        if (!response.ok) throw new Error('Failed to check shared status');
        const data = await response.json();
        setIsShared(data.isShared);
      } catch (error) {
        console.error('Error checking shared status:', error);
      }
    };

    if (deck?.id) {
      checkSharedStatus();
    }
  }, [deck?.id]);

  const handleShareDeck = async () => {
    if (!session?.user?.id) {
      toast({
        title: "Error",
        description: "You must be signed in to share a deck",
        variant: "destructive"
      });
      return;
    }
  
    try {
      const response = await fetch('/api/marketplace', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          deckId: deck.id
        }),
      });
  
      const data = await response.json();
  
      if (!response.ok) {
        throw new Error(data.error || 'Failed to share deck');
      }
  
      setIsShared(true);
      toast({
        title: "Success",
        description: "Deck shared to marketplace successfully",
      });
  
    } catch (error) {
      console.error('Error sharing deck:', error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Failed to share deck",
        variant: "destructive",
      });
    }
  };

  const onSubmit = async (data: FlashcardFormData) => {
    if (!deck?.id) {
      toast({
        title: "Error",
        description: "Deck not found",
        variant: "destructive",
      });
      return;
    }

    try {
      if (editingCard) {
        const response = await fetch(`/api/flashcards/${editingCard.id}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            front: data.front,
            back: data.back
          })
        });

        if (!response.ok) {
          throw new Error('Failed to update flashcard');
        }

        const updatedCard = await response.json();
        setFlashcards(prevCards => prevCards.map(card =>
          card.id === editingCard.id ? updatedCard : card
        ));

        toast({
          title: "Success",
          description: "Flashcard updated successfully",
        });
      } else {
        const response = await fetch('/api/flashcards', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            deckId: deck.id,
            front: data.front,
            back: data.back
          })
        });

        if (!response.ok) {
          throw new Error('Failed to create flashcard');
        }

        const newCard = await response.json();
        setFlashcards(prevCards => [...prevCards, newCard]);

        toast({
          title: "Success",
          description: "New flashcard created successfully",
        });
      }

      form.reset();
      setIsCreating(false);
      setEditingCard(null);

    } catch (error) {
      console.error("Failed to save flashcard:", error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "An unexpected error occurred",
        variant: "destructive",
      });
    }
  };

  const handleDelete = async (id: string) => {
    if (!confirm("Are you sure you want to delete this flashcard?")) return;

    try {
      const response = await fetch(`/api/flashcards/${id}`, {
        method: 'DELETE'
      });

      if (!response.ok) throw new Error('Failed to delete flashcard');

      setFlashcards(prevCards => prevCards.filter(card => card.id !== id));
      toast({
        title: "Success",
        description: "Flashcard deleted successfully",
      });
    } catch (error) {
      console.error("Failed to delete flashcard:", error);
      toast({
        title: "Error",
        description: "Failed to delete flashcard. Please try again.",
        variant: "destructive",
      });
    }
  };

  const dueCards = flashcards.filter(card =>
    !card.nextReview || new Date(card.nextReview) <= new Date()
  );

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="max-w-5xl mx-auto">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
        >
          <Card className="dark:glass-card dark:border-white/5 bg-white border-neutral-200 mb-8 overflow-hidden">
            <CardHeader className="border-b border-neutral-100 dark:border-white/5 bg-neutral-50/50 dark:bg-white/[0.02]">
              <div className="flex items-center justify-between">
                <div>
                  <CardTitle className="text-3xl font-light text-neutral-800 dark:text-white">
                    {deck.title}
                  </CardTitle>
                  <CardDescription className="text-neutral-600 dark:text-neutral-400 mt-1">
                    {deck.description}
                  </CardDescription>
                </div>
                <Button
                  onClick={() => router.push(`/review?deckId=${deck.id}`)}
                  className="dark:bg-white dark:text-black dark:hover:bg-neutral-200 bg-neutral-900 text-white hover:bg-neutral-800"
                >
                  <PlayCircle className="mr-2 h-4 w-4" />
                  Start Review
                </Button>
              </div>
            </CardHeader>
            <CardContent className="py-6">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div className="flex items-center space-x-3">
                  <div className="p-3 bg-neutral-100 dark:bg-white/5 rounded-lg">
                    <Book className="h-5 w-5 text-neutral-600 dark:text-neutral-400" />
                  </div>
                  <div>
                    <p className="text-sm text-neutral-600 dark:text-neutral-400">
                      Total Cards
                    </p>
                    <p className="text-2xl font-light dark:text-white">
                      {flashcards.length}
                    </p>
                  </div>
                </div>
                <div className="flex items-center space-x-3">
                  <div className="p-3 bg-neutral-100 dark:bg-white/5 rounded-lg">
                    <Clock className="h-5 w-5 text-neutral-600 dark:text-neutral-400" />
                  </div>
                  <div>
                    <p className="text-sm text-neutral-600 dark:text-neutral-400">
                      Due Today
                    </p>
                    <p className="text-2xl font-light dark:text-white">
                      {dueCards.length}
                    </p>
                  </div>
                </div>
              </div>
            </CardContent>
            <CardFooter className="border-t border-neutral-100 dark:border-white/5 bg-neutral-50/50 dark:bg-white/[0.02]">
              <div className="flex pt-4 items-center gap-4 w-full">
                <Dialog open={isCreating} onOpenChange={setIsCreating}>
                  <DialogTrigger asChild>
                    <Button
                      variant="outline"
                      className="border-neutral-300 hover:border-neutral-400 dark:border-white/10 dark:hover:border-white/20 dark:text-white"
                    >
                      <Plus className="mr-2 h-4 w-4" />
                      Add Basic Card
                    </Button>
                  </DialogTrigger>
                  <DialogContent className="dark:glass-card bg-[#F5F2EA] border-neutral-200 dark:border-white/10 sm:max-w-[425px]">
                    <DialogHeader>
                      <DialogTitle className="text-xl font-light dark:text-white">
                        {editingCard ? "Edit Card" : "Add New Card"}
                      </DialogTitle>
                    </DialogHeader>
                    <Form {...form}>
                      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
                        <FormField
                          control={form.control}
                          name="front"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel className="dark:text-neutral-200">Front</FormLabel>
                              <FormControl>
                                <Textarea
                                  placeholder="Enter the front side content"
                                  className="resize-none bg-white dark:bg-white/5 dark:text-white dark:border-white/10"
                                  {...field}
                                />
                              </FormControl>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                        <FormField
                          control={form.control}
                          name="back"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel className="dark:text-neutral-200">Back</FormLabel>
                              <FormControl>
                                <Textarea
                                  placeholder="Enter the back side content"
                                  className="resize-none bg-white dark:bg-white/5 dark:text-white dark:border-white/10"
                                  {...field}
                                />
                              </FormControl>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                        <Button
                          type="submit"
                          className="w-full dark:bg-white dark:text-black dark:hover:bg-neutral-200"
                        >
                          {editingCard ? "Save Changes" : "Add Card"}
                        </Button>
                      </form>
                    </Form>
                  </DialogContent>
                </Dialog>

                <Button
                  variant="outline"
                  onClick={() => setIsTranslationDialogOpen(true)}
                  className="border-neutral-300 hover:border-neutral-400 dark:border-white/10 dark:hover:border-white/20 dark:text-white"
                >
                  <Globe className="mr-2 h-4 w-4" />
                  Add Translation Card
                </Button>
                {!deck.originalSharedDeckId && (
                  <Button
                    variant="outline"
                    onClick={handleShareDeck}
                    disabled={isShared}
                    className="border-neutral-300 hover:border-neutral-400 dark:border-white/10 dark:hover:border-white/20 dark:text-white"
                  >
                    <Globe className="mr-2 h-4 w-4" />
                    {isShared ? 'Shared on Marketplace' : 'Share to Marketplace'}
                  </Button>
                )}
              </div>
            </CardFooter>
          </Card>
        </motion.div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <AnimatePresence mode="popLayout">
            {flashcards.map((card, index) => (
              <motion.div
                key={card.id}
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -20 }}
                transition={{ duration: 0.3, delay: index * 0.05 }}
              >
                <Card className={cn(
                  "dark:glass-card dark:border-white/5 bg-white border-neutral-200",
                  "group hover:shadow-lg hover:-translate-y-1 transition-all duration-200"
                )}>
                  <CardHeader className="pb-3">
                    <div className="flex justify-between items-start">
                      <CardTitle className="text-lg font-normal text-neutral-600 dark:text-neutral-300">
                        Card {index + 1}
                      </CardTitle>
                      <div className="opacity-0 group-hover:opacity-100 transition-opacity">
                        <ChevronRight className="h-5 w-5 text-neutral-400 dark:text-neutral-500" />
                      </div>
                    </div>
                  </CardHeader>
                  <CardContent className="space-y-3">
                    <div>
                      <p className="text-xs font-medium text-neutral-500 dark:text-neutral-400 mb-1">Front</p>
                      <p className="text-sm text-neutral-800 dark:text-white">{card.front}</p>
                    </div>
                    <div>
                      <p className="text-xs font-medium text-neutral-500 dark:text-neutral-400 mb-1">Back</p>
                      <p className="text-sm text-neutral-800 dark:text-white">{card.back}</p>
                    </div>
                  </CardContent>
                  <CardFooter className="border-t border-neutral-100 dark:border-white/5 pt-4">
                    <div className="flex justify-between items-center w-full">
                      <div className="text-xs text-neutral-500 dark:text-neutral-400">
                        {formatTimestamp(card.lastReviewed)}
                      </div>
                      <div className="flex space-x-2">
                        <Button
                          variant="ghost"
                          size="sm"
                          className="hover:bg-neutral-100 dark:hover:bg-white/5 dark:text-neutral-200"
                          onClick={() => {
                            setEditingCard(card);
                            form.reset({
                              front: card.front,
                              back: card.back
                            });
                            setIsCreating(true);
                          }}
                        >
                          <Edit2 className="h-4 w-4" />
                        </Button>
                        <Button
                          variant="ghost"
                          size="sm"
                          className="hover:bg-red-50 hover:text-red-600 dark:hover:bg-red-500/10 dark:hover:text-red-400"
                          onClick={() => handleDelete(card.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>
                  </CardFooter>
                </Card>
              </motion.div>
            ))}
          </AnimatePresence>
        </div>

        {flashcards.length === 0 && (
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            className="text-center py-12"
          >
            <div className="w-16 h-16 bg-neutral-100 dark:bg-white/5 rounded-full mx-auto flex items-center justify-center mb-6">
              <Book className="w-8 h-8 text-neutral-500 dark:text-neutral-400" />
            </div>
            <h3 className="text-xl font-light text-neutral-800 dark:text-white mb-2">
              No flashcards yet
            </h3>
            <p className="text-neutral-600 dark:text-neutral-400 mb-6">
              Create your first flashcard to get started
            </p>
            <Button
              onClick={() => setIsCreating(true)}
              className="dark:bg-white dark:text-black dark:hover:bg-neutral-200"
            >
              <Plus className="mr-2 h-4 w-4" />
              Create Flashcard
            </Button>
          </motion.div>
        )}
      </div>

      <TranslationFlashcardDialog
        open={isTranslationDialogOpen}
        onOpenChange={setIsTranslationDialogOpen}
        deckId={deck.id}
        onFlashcardCreated={() => {
          fetchFlashcards();
        }}
      />
    </div>
  );
}

================
File: app/decks/[id]/page.tsx
================
// app/decks/[id]/page.tsx
import { getDeck, getFlashcards } from '@/lib/db';
import { notFound, redirect } from 'next/navigation';
import DeckPageClient from './DeckPageClient';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { Button } from '@/components/ui/button';
import Link from 'next/link';
import { Deck, Flashcard } from '@/lib/types';

export default async function DeckPage({ params }: { params: { id: string } }) {
  const session = await getServerSession(authOptions);
  
  if (!session?.user) {
    redirect('/auth/signin');
  }

  const deckData = await getDeck(params.id);

  if (!deckData) {
    notFound();
  }

  if (deckData.userId !== session.user.id) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <h1 className="text-2xl font-semibold mb-4">Access Denied</h1>
          <p className="text-gray-600 mb-4">You don't have permission to view this deck.</p>
          <Link href="/decks">
            <Button>
              Return to My Decks
            </Button>
          </Link>
        </div>
      </div>
    );
  }

  // Convert timestamps to numbers for the deck
  const deck: Deck = {
    ...deckData,
    createdAt: new Date(Number(deckData.createdAt)),
    updatedAt: new Date(Number(deckData.updatedAt))
  };

  // Get flashcards and ensure all BigInt values are converted to numbers
  const rawFlashcards = await getFlashcards(params.id);
  const flashcards: Flashcard[] = rawFlashcards.map(card => ({
    ...card,
    createdAt: Number(card.createdAt),
    updatedAt: Number(card.updatedAt),
    lastReviewed: card.lastReviewed ? Number(card.lastReviewed) : null,
    nextReview: card.nextReview ? Number(card.nextReview) : null,
    stability: Number(card.stability),
    difficulty: Number(card.difficulty),
    elapsedDays: Number(card.elapsedDays),
    scheduledDays: Number(card.scheduledDays),
    reps: Number(card.reps),
    lapses: Number(card.lapses),
    interval: Number(card.interval),
    easeFactor: Number(card.easeFactor)
  }));

  return <DeckPageClient initialDeck={deck} initialFlashcards={flashcards} />;
}

================
File: app/decks/DecksClient.tsx
================
'use client';

import React, { useState } from 'react';
import Link from 'next/link';
import { useSession } from "next-auth/react";
import { Search } from "lucide-react";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Loader2, Pencil, Trash2 } from "lucide-react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle, CardFooter } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Form, FormField, FormItem, FormLabel, FormControl, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { PlusCircle, Sparkles, ArrowRight } from "lucide-react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { Deck, ExtendedSession } from '@/lib/types';
import { motion, AnimatePresence } from 'framer-motion';
import { useRouter } from 'next/navigation';
import { useToast } from '@/hooks/use-toast';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from '@/components/ui/alert-dialog';
import { DeckLabelInput } from '@/components/DeckLabelInput';
import { Badge } from '@/components/ui/badge';

const formSchema = z.object({
  title: z.string().min(1, "Title is required"),
  description: z.string().optional(),
  labels: z.array(z.string()).default([])
});

type FormData = z.infer<typeof formSchema>;

interface DeckLabelsProps {
  labels?: string[] | null;
}

export function SearchBar({
  value,
  onChange,
  placeholder = "Search collections...",
  className = ""
}: {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  className?: string;
}) {
  return (
    <div className={`relative ${className}`}>
      <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-neutral-500 dark:text-neutral-400" />
      <Input
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder}
        className="pl-9 dark:bg-white/5 dark:border-white/10"
      />
    </div>
  );
}

const formatDate = (date: Date) => {
  return new Intl.DateTimeFormat('en-US', {
    year: 'numeric',
    month: 'numeric',
    day: 'numeric',
    timeZone: 'UTC'
  }).format(new Date(date));
};


export default function DecksClient({ initialDecks }: { initialDecks: Deck[] }) {
  const { data: session } = useSession();
  const [decks, setDecks] = useState<Deck[]>(
    initialDecks.map(deck => ({
      ...deck,
      labels: deck.labels || []
    }))
  );
  const [isCreating, setIsCreating] = useState(false);
  const [editingDeck, setEditingDeck] = useState<Deck | null>(null);
  const router = useRouter();
  const { toast } = useToast();
  const [searchQuery, setSearchQuery] = useState('');
  initialDecks.map(deck => ({
    ...deck,
    labels: deck.labels || [] // Ensure labels is always an array
  }))

  const form = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      title: "",
      description: ""
    }
  });

  const onSubmit = async (data: FormData) => {
    if (!session?.user?.id) {
      toast({
        title: "Error",
        description: "You must be logged in to create a deck",
        variant: "destructive"
      });
      return;
    }

    try {
      const response = await fetch(editingDeck ? `/api/decks/${editingDeck.id}` : '/api/decks', {
        method: editingDeck ? 'PUT' : 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId: session.user.id,
          title: data.title,
          description: data.description || '',
          labels: data.labels || []
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to save deck');
      }

      const savedDeck = await response.json();

      if (editingDeck) {
        setDecks(prevDecks => prevDecks.map(deck =>
          deck.id === editingDeck.id ? savedDeck : deck
        ));
      } else {
        setDecks(prevDecks => [...prevDecks, savedDeck]);
      }

      form.reset();
      setIsCreating(false);
      setEditingDeck(null);

      toast({
        title: "Success",
        description: `Deck ${editingDeck ? 'updated' : 'created'} successfully`,
      });
    } catch (error) {
      console.error("Failed to save deck:", error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "An unexpected error occurred",
        variant: "destructive"
      });
    }
  };

  const filteredDecks = React.useMemo(() => {
    const searchLower = searchQuery.toLowerCase();
    return decks.filter(deck => {
      // Search in title and description
      const titleMatch = deck.title?.toLowerCase().includes(searchLower) ?? false;
      const descriptionMatch = deck.description?.toLowerCase().includes(searchLower) ?? false;

      // Safely handle labels search with proper null checking
      const labelMatch = Array.isArray(deck.labels) && deck.labels.length > 0
        ? deck.labels.some(label =>
          label && typeof label === 'string' && label.toLowerCase().includes(searchLower)
        )
        : false;

      return titleMatch || descriptionMatch || labelMatch;
    });
  }, [decks, searchQuery]);

  const DeckLabels: React.FC<DeckLabelsProps> = ({ labels }) => {
    if (!labels?.length) return null;

    return (
      <div className="flex flex-wrap gap-2 mt-2">
        {labels.map(label => (
          label ?
            (<Badge
              key={label}
              variant="secondary"
              className="px-2 py-1 bg-neutral-100 dark:bg-white/10 text-neutral-700 dark:text-neutral-300"
            >
              {label}
            </Badge>)
            : ""
        ))}
      </div>
    );
  };

  const handleDelete = async (deck: Deck) => {
    try {
      const response = await fetch(`/api/decks/${deck.id}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        throw new Error('Failed to delete deck');
      }

      setDecks(prevDecks => prevDecks.filter(d => d.id !== deck.id));

      toast({
        title: "Success",
        description: "Collection deleted successfully",
      });
    } catch (error) {
      console.error("Failed to delete deck:", error);
      toast({
        title: "Error",
        description: "Failed to delete deck. Please try again.",
        variant: "destructive",
      });
    }
  };



  return (
    <div className="container mx-auto px-4 py-8">
      <div className="max-w-6xl mx-auto">
        <div className="flex justify-between items-center mb-8">
          <div>
            <h1 className="text-3xl font-light text-neutral-800 dark:text-white">Collections</h1>
            <p className="text-neutral-600 dark:text-neutral-400 mt-2">Create and manage your flashcard collections</p>
          </div>
          <div className="flex gap-5">
            <SearchBar
              value={searchQuery}
              onChange={setSearchQuery}
              placeholder="Search collections..."
            />
            <Button
              onClick={() => setIsCreating(true)}
              className="dark:bg-white dark:text-black dark:hover:bg-neutral-200"
            >
              <PlusCircle className="mr-2 h-4 w-4" />
              New Collection
            </Button>
          </div>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          <AnimatePresence mode="popLayout">
            {filteredDecks.length === 0 ? (
              <motion.div
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                className="col-span-full flex flex-col items-center justify-center p-12 text-center"
              >
                {searchQuery ? (
                  <>
                    <div className="w-16 h-16 bg-neutral-100 dark:bg-white/5 rounded-full flex items-center justify-center mb-6">
                      <Search className="w-8 h-8 text-neutral-500 dark:text-neutral-400" />
                    </div>
                    <h3 className="text-xl font-light text-neutral-800 dark:text-white mb-2">
                      No matching collections found
                    </h3>
                    <p className="text-neutral-600 dark:text-neutral-400">
                      Try adjusting your search terms
                    </p>
                  </>
                ) : (
                  // Your existing empty state
                  <>
                    <div className="w-16 h-16 bg-neutral-100 dark:bg-white/5 rounded-full flex items-center justify-center mb-6">
                      <Sparkles className="w-8 h-8 text-neutral-500 dark:text-neutral-400" />
                    </div>
                    <h3 className="text-xl font-light text-neutral-800 dark:text-white mb-2">
                      No collections yet
                    </h3>
                    <p className="text-neutral-600 dark:text-neutral-400 mb-6">
                      Create your first collection to get started
                    </p>
                    <Button
                      onClick={() => setIsCreating(true)}
                      className="dark:bg-white dark:text-black dark:hover:bg-neutral-200"
                    >
                      <PlusCircle className="mr-2 h-4 w-4" />
                      Create Collection
                    </Button>
                  </>
                )}
              </motion.div>
            ) : (
              filteredDecks.map((deck, index) => (
                <motion.div
                  key={deck.id}
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, scale: 0.95 }}
                  transition={{ duration: 0.2, delay: index * 0.05 }}
                  className="h-full"
                >
                  <Card className="dark:glass-card dark:border-white/5 group hover:shadow-lg transition-all duration-200 h-full flex flex-col">
                    <CardHeader>
                      <CardTitle className="text-xl font-light dark:text-white">
                        {deck.title}
                      </CardTitle>
                      <CardDescription className="dark:text-neutral-400">
                        {deck.description || 'No description'}
                      </CardDescription>
                    </CardHeader>
                    <CardContent className="flex-grow">
                      <div className="space-y-4">
                        <DeckLabels labels={deck.labels} />
                      </div>
                    </CardContent>
                    <CardFooter className="flex justify-end space-x-2 mt-auto pt-4">
                      <AlertDialog>
                        <AlertDialogTrigger asChild>
                          <Button
                            variant="outline"
                            onClick={(e) => e.stopPropagation()}
                            className="dark:border-white/10 dark:hover:border-white/20 dark:text-white"
                          >
                            <Trash2 className="h-4 w-4 mr-2" />
                            Delete
                          </Button>
                        </AlertDialogTrigger>
                        <AlertDialogContent>
                          <AlertDialogHeader>
                            <AlertDialogTitle>Delete Collection</AlertDialogTitle>
                            <AlertDialogDescription>
                              Are you sure you want to delete &quot;{deck.title}&quot;? This action cannot be undone
                              and all flashcards in this collection will be permanently deleted.
                            </AlertDialogDescription>
                          </AlertDialogHeader>
                          <AlertDialogFooter>
                            <AlertDialogCancel>Cancel</AlertDialogCancel>
                            <AlertDialogAction
                              onClick={() => handleDelete(deck)}
                              className="bg-red-600 hover:bg-red-700"
                            >
                              Delete
                            </AlertDialogAction>
                          </AlertDialogFooter>
                        </AlertDialogContent>
                      </AlertDialog>
                      <Button
                        variant="outline"
                        onClick={() => {
                          setEditingDeck(deck);
                          form.reset({
                            title: deck.title,
                            description: deck.description || undefined
                          });
                          setIsCreating(true);
                        }}
                        className="dark:border-white/10 dark:hover:border-white/20 dark:text-white"
                      >
                        <Pencil className="h-4 w-4 mr-2" />
                        Edit
                      </Button>
                      <Button
                        onClick={() => router.push(`/decks/${deck.id}`)}
                        className="dark:bg-white dark:text-black dark:hover:bg-neutral-200"
                      >
                        View Cards
                        <ArrowRight className="ml-2 h-4 w-4" />
                      </Button>
                    </CardFooter>
                  </Card>
                </motion.div>
              ))
            )}
          </AnimatePresence>
        </div>
      </div>

      <Dialog open={isCreating} onOpenChange={setIsCreating}>
        <DialogContent className="dark:glass-card sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle className="text-xl font-light dark:text-white">
              {editingDeck ? 'Edit Collection' : 'Create New Collection'}
            </DialogTitle>
            <DialogDescription className="dark:text-neutral-400">
              {editingDeck
                ? 'Update your collection details.'
                : 'Add a new collection to organize your flashcards.'}
            </DialogDescription>
          </DialogHeader>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="dark:text-neutral-300">Title</FormLabel>
                    <FormControl>
                      <Input
                        placeholder="Collection title"
                        className="dark:bg-white/5 dark:border-white/10 dark:text-white dark:placeholder-neutral-500"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="description"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="dark:text-neutral-300">Description</FormLabel>
                    <FormControl>
                      <Textarea
                        placeholder="Describe your collection"
                        className="dark:bg-white/5 dark:border-white/10 dark:text-white dark:placeholder-neutral-500 resize-none"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="labels"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="dark:text-neutral-300">Labels</FormLabel>
                    <FormControl>
                      <DeckLabelInput
                        labels={field.value || []}
                        onLabelsChange={(newLabels) => field.onChange(newLabels)}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button
                type="submit"
                className="w-full dark:bg-white dark:text-black dark:hover:bg-neutral-200"
              >
                {editingDeck ? 'Save Changes' : 'Create Collection'}
              </Button>
            </form>
          </Form>
        </DialogContent>
      </Dialog>
    </div>
  );
}

================
File: app/decks/page.tsx
================
import { getServerSession } from "next-auth/next"
import { authOptions } from "@/lib/auth"
import { getDecks } from '@/lib/db'
import { ExtendedSession, Deck } from '@/lib/types'
import { SignInButton } from '@/components/SignInButton'
import DecksClient from './DecksClient'

export default async function DecksPage() {
  const session = await getServerSession(authOptions) as ExtendedSession | null;

  if (!session || !session.user) {
    return (
      <div className="flex flex-col items-center justify-center min-h-screen">
        <h1 className="text-2xl mb-4">Please sign in to view your decks</h1>
        <SignInButton />
      </div>
    );
  }

  const rawDecks = await getDecks(session.user.id) || [];

  const decks: Deck[] = rawDecks.map(deck => ({
    ...deck,
    createdAt: new Date(deck.createdAt),
    updatedAt: new Date(deck.updatedAt),
    labels: Array.isArray(deck.labels) 
      ? deck.labels.filter((label): label is string => 
          typeof label === 'string' && label.length > 0
        )
      : []
  }));

  return <DecksClient initialDecks={decks} />;
}

================
File: app/marketplace/DeckCommentsDialog.tsx
================
// components/DeckCommentsDialog.tsx
'use client';

import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { ScrollArea } from "@/components/ui/scroll-area";
import { useToast } from "@/hooks/use-toast";
import { useState, useEffect } from "react";
import { useSession } from "next-auth/react";
import { format } from 'date-fns';
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Loader2 } from "lucide-react";

interface Comment {
  id: string;
  content: string;
  createdAt: number;
  user: {
    id: string;
    name: string | null;
    image: string | null;
  };
}

interface DeckCommentsDialogProps {
  deck: {
    id: string;
    deckOwnerName: string;
  };
  open: boolean;
  onOpenChange: (open: boolean) => void;
  currentUserId?: string | null;
}

export function DeckCommentsDialog({
  deck,
  open,
  onOpenChange,
  currentUserId
}: DeckCommentsDialogProps) {
  const [comments, setComments] = useState<Comment[]>([]);
  const [newComment, setNewComment] = useState('');
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const { data: session } = useSession();
  const { toast } = useToast();

  useEffect(() => {
    if (open && deck) {
      fetchComments();
    }
  }, [open, deck]);

  const fetchComments = async () => {
    setIsLoading(true);
    try {
      const response = await fetch(`/api/marketplace/${deck.id}/comments`);
      if (!response.ok) throw new Error('Failed to fetch comments');
      const data = await response.json();
      setComments(data);
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to load comments",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleSubmitComment = async () => {
    if (!session?.user?.id || !newComment.trim()) return;

    setIsSubmitting(true);
    try {
      const response = await fetch(`/api/marketplace/${deck.id}/comments`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          userId: session.user.id,
          content: newComment.trim()
        }),
      });

      if (!response.ok) throw new Error('Failed to submit comment');

      const newCommentData = await response.json();
      setComments(prev => [...prev, newCommentData]);
      setNewComment('');
      
      toast({
        title: "Success",
        description: "Comment added successfully",
      });
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to submit comment",
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="dark:glass-card sm:max-w-[525px]">
        <DialogHeader>
          <DialogTitle className="text-xl font-light">Comments</DialogTitle>
        </DialogHeader>
        <div className="py-4">
          <ScrollArea className="h-[400px] pr-4">
            {isLoading ? (
              <div className="flex justify-center items-center h-[200px]">
                <Loader2 className="h-6 w-6 animate-spin text-neutral-500" />
              </div>
            ) : comments.length === 0 ? (
              <div className="text-center text-neutral-500 dark:text-neutral-400 py-8">
                No comments yet. Be the first to comment!
              </div>
            ) : (
              comments.map((comment) => (
                <div key={comment.id} className="mb-4 last:mb-0">
                  <div className="flex items-start space-x-3">
                    <Avatar className="h-8 w-8">
                      <AvatarImage src={comment.user.image || undefined} />
                      <AvatarFallback>
                        {comment.user.name?.[0] || 'A'}
                      </AvatarFallback>
                    </Avatar>
                    <div className="flex-1">
                      <div className="flex items-center justify-between">
                        <span className="text-sm font-medium dark:text-white flex items-center gap-2">
                          {comment.user.name || 'Anonymous'}
                          {comment.user.id === currentUserId && (
                            <span className="text-xs text-neutral-500">(You)</span>
                          )}
                          {comment.user.id === deck.id && (
                            <span className="text-xs text-neutral-500">(Owner)</span>
                          )}
                        </span>
                        <span className="text-xs text-neutral-500">
                          {format(comment.createdAt, 'MMM d, yyyy')}
                        </span>
                      </div>
                      <p className="text-sm text-neutral-600 dark:text-neutral-300 mt-1">
                        {comment.content}
                      </p>
                    </div>
                  </div>
                </div>
              ))
            )}
          </ScrollArea>
          
          {session?.user && (
            <div className="mt-4 space-y-4">
              <Textarea
                placeholder="Add a comment..."
                value={newComment}
                onChange={(e) => setNewComment(e.target.value)}
                className="dark:bg-white/5 dark:border-white/10 min-h-[100px]"
                disabled={isSubmitting}
              />
              <Button
                onClick={handleSubmitComment}
                disabled={isSubmitting || !newComment.trim()}
                className="w-full dark:bg-white dark:text-black dark:hover:bg-neutral-200"
              >
                {isSubmitting ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Posting...
                  </>
                ) : (
                  'Post Comment'
                )}
              </Button>
            </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
}

================
File: app/marketplace/DeckRatingDialog.tsx
================
// app/marketplace/DeckRatingDialog.tsx
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { useToast } from "@/hooks/use-toast";
import { useState, useEffect } from "react";
import { Star } from "lucide-react";
import { useSession } from "next-auth/react";

interface DeckRatingDialogProps {
  deck: {
    id: string;
    userId: string;
    averageRating: number;
    ratingCount: number;
  };
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onRatingSubmit: (rating: number, newAverage: number, newCount: number) => void;
}

export function DeckRatingDialog({
  deck,
  open,
  onOpenChange,
  onRatingSubmit
}: DeckRatingDialogProps) {
  const [hoveredRating, setHoveredRating] = useState(0);
  const [selectedRating, setSelectedRating] = useState(0);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const { data: session } = useSession();
  const { toast } = useToast();

  useEffect(() => {
    if (open && session?.user?.id) {
      const fetchExistingRating = async () => {
        try {
          const response = await fetch(`/api/marketplace/${deck.id}/ratings?userId=${session.user.id}`);
          if (response.ok) {
            const data = await response.json();
            if (data.rating) {
              setSelectedRating(data.rating);
            }
          }
        } catch (error) {
          console.error('Error fetching existing rating:', error);
        }
      };
      fetchExistingRating();
    }
  }, [open, deck.id, session?.user?.id]);

  const handleRatingSubmit = async () => {
    if (!session?.user?.id || selectedRating === 0) return;

    setIsSubmitting(true);
    try {
      const response = await fetch(`/api/marketplace/${deck.id}/ratings`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId: session.user.id,
          rating: selectedRating
        }),
      });

      if (!response.ok) throw new Error('Failed to submit rating');
      
      const result = await response.json();
      onRatingSubmit(selectedRating, result.averageRating, result.ratingCount);
      onOpenChange(false);

      toast({
        title: "Success",
        description: "Rating submitted successfully",
      });
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to submit rating",
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="dark:glass-card sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle className="text-xl font-light">Rate Collection</DialogTitle>
        </DialogHeader>
        <div className="py-4">
          <div className="flex justify-center space-x-2 mb-6">
            {[1, 2, 3, 4, 5].map((rating) => (
              <button
                key={rating}
                className="relative p-1"
                onMouseEnter={() => setHoveredRating(rating)}
                onMouseLeave={() => setHoveredRating(0)}
                onClick={() => setSelectedRating(rating)}
                disabled={isSubmitting}
              >
                <Star
                  className={`w-8 h-8 transition-colors ${
                    (hoveredRating || selectedRating) >= rating
                      ? 'fill-yellow-400 text-yellow-400'
                      : 'text-gray-300'
                  }`}
                />
              </button>
            ))}
          </div>
          <div className="text-center text-sm text-neutral-600 dark:text-neutral-400 mb-6">
            {selectedRating > 0 && (
              <span>You selected {selectedRating} stars</span>
            )}
          </div>
          <Button
            className="w-full dark:bg-white dark:text-black dark:hover:bg-neutral-200"
            onClick={handleRatingSubmit}
            disabled={isSubmitting || selectedRating === 0}
          >
            {isSubmitting ? 'Submitting...' : 'Submit Rating'}
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}

================
File: app/marketplace/MarketplaceClient.tsx
================
// app/marketplace/MarketplaceClient.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { useSession } from "next-auth/react";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { useToast } from "@/hooks/use-toast";
import { motion, AnimatePresence } from 'framer-motion';
import { Star, StarHalf, MessageCircle, Download, Trash2, Loader2, User, Search, Book } from 'lucide-react';
import { DeckRatingDialog } from './DeckRatingDialog';
import { DeckCommentsDialog } from './DeckCommentsDialog';
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { formatDistanceToNow } from 'date-fns';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';

interface MarketplaceDeck {
  id: string;
  userId: string;
  title: string;
  description: string | null;
  createdAt: number;
  downloads: number;
  averageRating: number;
  ratingCount: number;
  user?: {
    name: string | null;
    image: string | null;
  };
  labels?: string[] | null;
}

interface SharedDeck {
  id: string;
  title: string;
  description: string | null;
  downloads: number;
  createdAt: number;
  userId: string;
  averageRating: number;
  ratingCount: number;
  user?: {
    name: string | null;
    image: string | null;
  };
}

interface DeckCardProps {
  deck: MarketplaceDeck;
  onRate: () => void;
  onComment: () => void;
  onRemove?: () => void;
  isOwner?: boolean;
  currentUserId?: string | null;
}

export function SearchBar({
  value,
  onChange,
  placeholder = "Search...",
  className = ""
}: {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  className?: string;
}) {
  return (
    <div className={`relative ${className}`}>
      <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-neutral-500 dark:text-neutral-400" />
      <Input
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder}
        className="pl-9 w-auto dark:bg-white/5 dark:border-white/10"
      />
    </div>
  );
}

export default function MarketplaceClient() {
  const [allDecks, setAllDecks] = useState<MarketplaceDeck[]>([]);
  const [mySharedDecks, setMySharedDecks] = useState<MarketplaceDeck[]>([]);
  const [selectedDeck, setSelectedDeck] = useState<MarketplaceDeck | null>(null);
  const [isRatingOpen, setIsRatingOpen] = useState(false);
  const [isCommentsOpen, setIsCommentsOpen] = useState(false);
  const [removingDeckId, setRemovingDeckId] = useState<string | null>(null);
  const [downloadingDeckId, setDownloadingDeckId] = useState<string | null>(null);
  const { data: session } = useSession();
  const { toast } = useToast();
  const [searchQuery, setSearchQuery] = useState('');

  useEffect(() => {
    fetchDecks();
    if (session?.user?.id) {
      fetchMySharedDecks();
    }
  }, [session?.user?.id]);

  const fetchDecks = async () => {
    try {
      const response = await fetch('/api/marketplace');
      if (!response.ok) throw new Error('Failed to fetch decks');
      const data = await response.json();
      setAllDecks(data);
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to load marketplace decks",
        variant: "destructive",
      });
    }
  };

  const fetchMySharedDecks = async () => {
    if (!session?.user?.id) return;
    try {
      const response = await fetch(`/api/marketplace/user/${session.user.id}`);
      if (!response.ok) throw new Error('Failed to fetch shared decks');
      const data = await response.json();
      setMySharedDecks(data);
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to load your shared decks",
        variant: "destructive",
      });
    }
  };

  const handleRemoveFromMarketplace = async (deckId: string) => {
    setRemovingDeckId(deckId);
    try {
      const response = await fetch(`/api/marketplace/${deckId}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to remove deck');
      }

      setAllDecks(prev => prev.filter(deck => deck.id !== deckId));
      setMySharedDecks(prev => prev.filter(deck => deck.id !== deckId));

      toast({
        title: "Success",
        description: "Deck removed from marketplace successfully",
      });
    } catch (error) {
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Failed to remove deck",
        variant: "destructive",
      });
    } finally {
      setRemovingDeckId(null);
    }
  };

  const handleRatingSubmit = async (rating: number, newAverage: number, newCount: number) => {
    if (!selectedDeck || selectedDeck.userId === session?.user?.id) {
      toast({
        title: "Error",
        description: "You cannot rate your own deck",
        variant: "destructive",
      });
      return;
    }

    const updateDeckList = (decks: MarketplaceDeck[]) =>
      decks.map(deck =>
        deck.id === selectedDeck.id
          ? {
            ...deck,
            averageRating: newAverage,
            ratingCount: newCount,
          }
          : deck
      );

    setAllDecks(updateDeckList);
    setMySharedDecks(updateDeckList);
    setIsRatingOpen(false);
  };

  const DeckCard = ({
    deck,
    onRate,
    onComment,
    onRemove,
    isOwner = false,
    currentUserId
  }: DeckCardProps) => {
    const [isDownloading, setIsDownloading] = useState(false);
    const { toast } = useToast();
    const isOwnDeck = deck.userId === currentUserId;
    const { data: session } = useSession();


    const handleAddToCollection = async () => {
      if (!currentUserId) {
        toast({
          title: "Error",
          description: "Please sign in to add this collection",
          variant: "destructive",
        });
        return;
      }

      setIsDownloading(true);
      try {
        const response = await fetch(`/api/marketplace/${deck.id}/clone`, {
          method: 'POST',
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to add collection');
        }

        toast({
          title: "Success",
          description: "Collection added to your library",
        });
      } catch (error) {
        toast({
          title: "Error",
          description: error instanceof Error ? error.message : "Failed to add collection",
          variant: "destructive",
        });
      } finally {
        setIsDownloading(false);
      }
    };

    const getUserDisplayName = () => {
      if (isOwner || deck.userId === currentUserId) {
        return `${deck.user?.name || 'You'} (You)`;
      }
      return deck.user?.name || 'Anonymous';
    };

    const renderStars = (rating: number) => {
      const ratingValue = rating || 0;
      const fullStars = Math.floor(ratingValue);
      const hasHalfStar = (ratingValue % 1) >= 0.5;

      return (
        <div className="flex items-center space-x-1">
          {[...Array(5)].map((_, index) => {
            if (index < fullStars) {
              return <Star key={index} className="w-4 h-4 fill-yellow-400 text-yellow-400" />;
            } else if (index === fullStars && hasHalfStar) {
              return <StarHalf key={index} className="w-4 h-4 fill-yellow-400 text-yellow-400" />;
            } else {
              return <Star key={index} className="w-4 h-4 text-gray-300" />;
            }
          })}
          <span className="text-sm text-neutral-500 ml-2">
            ({(rating / 1) ? rating : '0'})
          </span>
        </div>
      );
    };


    return (
      <Card className="dark:glass-card h-full flex flex-col">
        <CardHeader>
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-2">
              <Avatar className="h-8 w-8">
                <AvatarImage src={deck.user?.image || undefined} />
                <AvatarFallback>
                  {deck.user?.name?.[0] || 'A'}
                </AvatarFallback>
              </Avatar>
              <div>
                <div className="text-sm font-medium dark:text-white">
                  {getUserDisplayName()}
                </div>
                <div className="text-sm text-neutral-500">
                  {formatDistanceToNow(deck.createdAt, { addSuffix: true })}
                </div>
              </div>
            </div>
          </div>
          <CardTitle className="text-xl font-light mt-4">{deck.title}</CardTitle>
        </CardHeader>

        <CardContent className="flex-grow">
          <div className="space-y-4">
            {deck.labels && deck.labels.length > 0 && (
              <div className="flex flex-wrap gap-2 mb-3">
                <DeckLabels labels={deck.labels} />
              </div>
            )}
            <div className="flex items-center space-x-1">
              {renderStars(deck.averageRating)}
            </div>
            <div className="flex items-center space-x-2 text-sm text-neutral-600 dark:text-neutral-400">
              <Download className="h-4 w-4" />
              <span>{deck.downloads} downloads</span>
            </div>
          </div>
        </CardContent>

        <CardFooter className="flex justify-between gap-2">
          {isOwner ? (
            <AlertDialog>
              <AlertDialogTrigger asChild>
                <Button
                  variant="destructive"
                  size="sm"
                  className="w-full"
                >
                  <Trash2 className="w-4 h-4 mr-2" />
                  Remove from Marketplace
                </Button>
              </AlertDialogTrigger>
              <AlertDialogContent>
                <AlertDialogHeader>
                  <AlertDialogTitle>Remove from Marketplace?</AlertDialogTitle>
                  <AlertDialogDescription>
                    This will remove the deck from the marketplace. All ratings and comments will be deleted.
                    This action cannot be undone.
                  </AlertDialogDescription>
                </AlertDialogHeader>
                <AlertDialogFooter>
                  <AlertDialogCancel>Cancel</AlertDialogCancel>
                  <AlertDialogAction
                    onClick={onRemove}
                    className="bg-red-600 hover:bg-red-700"
                  >
                    Remove
                  </AlertDialogAction>
                </AlertDialogFooter>
              </AlertDialogContent>
            </AlertDialog>
          ) : (
            <>
              <div className="flex space-x-2">
                {!isOwnDeck && (
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={onRate}
                    className="dark:border-white/10 dark:hover:border-white/20 dark:text-white"
                  >
                    <Star className="w-4 h-4 mr-1" />
                    Rate
                  </Button>
                )}
                <Button
                  variant="outline"
                  size="sm"
                  onClick={onComment}
                  className="dark:border-white/10 dark:hover:border-white/20 dark:text-white"
                >
                  <MessageCircle className="w-4 h-4 mr-1" />
                  Comments
                </Button>
              </div>
              {!isOwnDeck && (
                <Button
                  variant="default"
                  size="sm"
                  onClick={handleAddToCollection}
                  disabled={isDownloading}
                  className="dark:bg-white dark:text-black dark:hover:bg-neutral-200"
                >
                  {isDownloading ? (
                    <>
                      <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      Adding...
                    </>
                  ) : (
                    <>
                      <Download className="w-4 h-4 mr-1" />
                      Add
                    </>
                  )}
                </Button>
              )}
            </>
          )}
        </CardFooter>
      </Card>
    );
  };

  const renderStars = (rating: number) => {
    const starArray = [];
    const fullStars = Math.floor(rating);
    const hasHalfStar = rating % 1 >= 0.5;

    for (let i = 0; i < 5; i++) {
      if (i < fullStars) {
        starArray.push(<Star key={i} className="w-4 h-4 fill-yellow-400 text-yellow-400" />);
      } else if (i === fullStars && hasHalfStar) {
        starArray.push(<StarHalf key={i} className="w-4 h-4 fill-yellow-400 text-yellow-400" />);
      } else {
        starArray.push(<Star key={i} className="w-4 h-4 text-gray-300" />);
      }
    }

    return (
      <div className="flex items-center space-x-1">
        {starArray}
        <span className="text-sm text-neutral-500 ml-2">
          ({rating ? rating.toFixed(1) : '0.0'})
        </span>
      </div>
    );
  };

  const filteredDecks = React.useMemo(() => {
    const searchLower = searchQuery.toLowerCase();
    return allDecks.filter(deck => {
      const titleMatch = deck.title?.toLowerCase().includes(searchLower) ?? false;

      const descriptionMatch = deck.description?.toLowerCase().includes(searchLower) ?? false;

      const labelMatch = Array.isArray(deck.labels) && deck.labels.length > 0
        ? deck.labels.some(label =>
          label && typeof label === 'string' && label.toLowerCase().includes(searchLower)
        )
        : false;

      return titleMatch || descriptionMatch || labelMatch;
    });
  }, [allDecks, searchQuery]);

  const filteredMySharedDecks = React.useMemo(() => {
    const searchLower = searchQuery.toLowerCase();
    return mySharedDecks.filter(deck => {
      const titleMatch = deck.title?.toLowerCase().includes(searchLower) ?? false;
      const descriptionMatch = deck.description?.toLowerCase().includes(searchLower) ?? false;
      const labelMatch = Array.isArray(deck.labels) && deck.labels.length > 0
        ? deck.labels.some(label =>
          label && typeof label === 'string' && label.toLowerCase().includes(searchLower)
        )
        : false;

      return titleMatch || descriptionMatch || labelMatch;
    });
  }, [mySharedDecks, searchQuery]);
  const handleAddToCollection = async (deck: MarketplaceDeck) => {
    if (!session?.user?.id) {
      toast({
        title: "Error",
        description: "Please sign in to add this collection",
        variant: "destructive",
      });
      return;
    }

    setDownloadingDeckId(deck.id);
    try {
      const response = await fetch(`/api/marketplace/${deck.id}/clone`, {
        method: 'POST',
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to add collection');
      }

      toast({
        title: "Success",
        description: "Collection added to your library",
      });
    } catch (error) {
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Failed to add collection",
        variant: "destructive",
      });
    } finally {
      setDownloadingDeckId(null);
    }
  };
  const DeckLabels: React.FC<{ labels?: string[] | null }> = ({ labels }) => {
    if (!Array.isArray(labels) || labels.length === 0) return null;

    return (
      <div className="flex flex-wrap gap-2 mb-3">
        {labels.map(label => (
          label && (
            <Badge
              key={label}
              variant="secondary"
              className="px-2 py-1 bg-neutral-100 dark:bg-white/10 text-neutral-700 dark:text-neutral-300"
            >
              {label}
            </Badge>
          )
        ))}
      </div>
    );
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="max-w-6xl mx-auto">
        <div className="flex justify-between items-center mb-8">
          <div>
            <h1 className="text-3xl font-light text-neutral-800 dark:text-white">
              Collection Marketplace
            </h1>
            <p className="text-neutral-600 dark:text-neutral-400 mt-2">
              Discover and add shared collections from the community
            </p>
          </div>
        </div>
        <div className="flex flex-col gap-5">
          <SearchBar
            value={searchQuery}
            onChange={setSearchQuery}
            placeholder="Search collections..."
          />
          <Tabs defaultValue="browse" className="space-y-6">

            <TabsList className="grid w-full grid-cols-2 lg:w-[400px]">
              <TabsTrigger value="browse">Browse Collections</TabsTrigger>
              <TabsTrigger value="my-shared">My Shared Collections</TabsTrigger>
            </TabsList>

            <TabsContent value="browse">
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <AnimatePresence mode="popLayout">
                  {filteredDecks.length === 0 ? (
                    <motion.div
                      initial={{ opacity: 0, y: 20 }}
                      animate={{ opacity: 1, y: 0 }}
                      className="col-span-full flex flex-col items-center justify-center p-12 text-center"
                    >
                      {searchQuery ? (
                        <>
                          <div className="w-16 h-16 bg-neutral-100 dark:bg-white/5 rounded-full flex items-center justify-center mb-6">
                            <Search className="w-8 h-8 text-neutral-500 dark:text-neutral-400" />
                          </div>
                          <h3 className="text-xl font-light text-neutral-800 dark:text-white mb-2">
                            No matching collections found
                          </h3>
                          <p className="text-neutral-600 dark:text-neutral-400">
                            Try adjusting your search terms
                          </p>
                        </>
                      ) : (
                        <>
                          <div className="w-16 h-16 bg-neutral-100 dark:bg-white/5 rounded-full flex items-center justify-center mb-6">
                            <Book className="w-8 h-8 text-neutral-500 dark:text-neutral-400" />
                          </div>
                          <h3 className="text-xl font-light text-neutral-800 dark:text-white mb-2">
                            No collections available
                          </h3>
                          <p className="text-neutral-600 dark:text-neutral-400">
                            Be the first to share a collection!
                          </p>
                        </>
                      )}
                    </motion.div>
                  ) : (
                    filteredDecks.map((deck) => (
                      <motion.div
                        key={deck.id}
                        layout
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, scale: 0.95 }}
                      >
                        <Card className="dark:glass-card h-full flex flex-col">
                          <CardHeader>
                            <div className="flex items-center justify-between">
                              <div className="flex items-center space-x-2">
                                <Avatar className="h-8 w-8">
                                  <AvatarImage src={deck.user?.image || undefined} />
                                  <AvatarFallback>
                                    {deck.user?.name?.[0] || 'A'}
                                  </AvatarFallback>
                                </Avatar>
                                <div>
                                  <div className="text-sm font-medium dark:text-white">
                                    {deck.userId === session?.user?.id ? `${deck.user?.name || 'You'} (You)` : deck.user?.name || 'Anonymous'}
                                  </div>
                                  <div className="text-sm text-neutral-500">
                                    {formatDistanceToNow(deck.createdAt, { addSuffix: true })}
                                  </div>
                                </div>
                              </div>
                            </div>
                            <CardTitle className="text-xl font-light mt-4">{deck.title}</CardTitle>
                          </CardHeader>

                          <CardContent className="flex-grow">
                            <div className="flex-col space-y-4">
                              {deck.labels && deck.labels.length > 0 && (
                                <div className="flex flex-wrap gap-2 mb-3">
                                  <DeckLabels labels={deck.labels} />
                                </div>
                              )}
                              <div className="flex-col items-baseline space-y-2">
                                <div className="flex items-center space-x-1">
                                  {renderStars(deck.averageRating)}
                                </div>
                                <div className="flex items-center space-x-2 text-sm text-neutral-600 dark:text-neutral-400">
                                  <Download className="h-4 w-4" />
                                  <span>{deck.downloads} downloads</span>
                                </div>
                              </div>
                            </div>
                          </CardContent>

                          <CardFooter className="flex justify-between gap-2">
                            <div className="flex space-x-2">
                              {deck.userId !== session?.user?.id && (
                                <Button
                                  variant="outline"
                                  size="sm"
                                  onClick={() => {
                                    if (deck.userId === session?.user?.id) {
                                      toast({
                                        title: "Error",
                                        description: "You cannot rate your own deck",
                                        variant: "destructive",
                                      });
                                      return;
                                    }
                                    setSelectedDeck(deck);
                                    setIsRatingOpen(true);
                                  }}
                                  className="dark:border-white/10 dark:hover:border-white/20 dark:text-white"
                                >
                                  <Star className="w-4 h-4 mr-1" />
                                  Rate
                                </Button>
                              )}
                              <Button
                                variant="outline"
                                size="sm"
                                onClick={() => {
                                  setSelectedDeck(deck);
                                  setIsCommentsOpen(true);
                                }}
                                className="dark:border-white/10 dark:hover:border-white/20 dark:text-white"
                              >
                                <MessageCircle className="w-4 h-4 mr-1" />
                                Comments
                              </Button>
                            </div>
                            {deck.userId !== session?.user?.id && (
                              <Button
                                variant="default"
                                size="sm"
                                onClick={() => handleAddToCollection(deck)}
                                disabled={downloadingDeckId === deck.id}
                                className="dark:bg-white dark:text-black dark:hover:bg-neutral-200"
                              >
                                {downloadingDeckId === deck.id ? (
                                  <>
                                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                                    Adding...
                                  </>
                                ) : (
                                  <>
                                    <Download className="w-4 h-4 mr-1" />
                                    Add
                                  </>
                                )}
                              </Button>
                            )}
                          </CardFooter>
                        </Card>
                      </motion.div>
                    ))
                  )}
                </AnimatePresence>
              </div>
            </TabsContent>

            <TabsContent value="my-shared">
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <AnimatePresence mode="popLayout">
                  {filteredMySharedDecks.map((deck) => (
                    <motion.div
                      key={deck.id}
                      layout
                      initial={{ opacity: 0, y: 20 }}
                      animate={{ opacity: 1, y: 0 }}
                      exit={{ opacity: 0, scale: 0.95 }}
                    >
                      <Card className="dark:glass-card h-full flex flex-col">
                        <CardHeader>
                          <div className="flex items-center justify-between">
                            <div className="flex items-center space-x-2">
                              <Avatar className="h-8 w-8">
                                {session?.user?.image ? (
                                  <AvatarImage src={session.user.image} />
                                ) : (
                                  <AvatarFallback>
                                    {session?.user?.name?.[0] || 'A'}
                                  </AvatarFallback>
                                )}
                              </Avatar>
                              <div>
                                <div className="text-sm font-medium dark:text-white">
                                  {session?.user?.name}
                                </div>
                                <div className="text-sm text-neutral-500">
                                  {formatDistanceToNow(deck.createdAt, { addSuffix: true })}
                                </div>
                              </div>
                            </div>
                          </div>
                          <CardTitle className="text-xl font-light mt-4">{deck.title}</CardTitle>
                        </CardHeader>
                        <CardContent className="flex-grow">
                          <div className="space-y-4">
                            <DeckLabels labels={deck.labels} />
                            {renderStars(deck.averageRating)}
                            <div className="flex items-center space-x-2 text-sm text-neutral-600 dark:text-neutral-400">
                              <Download className="h-4 w-4" />
                              <span>{deck.downloads} downloads</span>
                            </div>
                          </div>
                        </CardContent>
                        <CardFooter className="flex justify-start gap-2">
                          <AlertDialog>
                            <AlertDialogTrigger asChild>
                              <Button
                                variant="destructive"
                                size="sm"
                                className="w-auto"
                              >
                                <Trash2 className="w-4 h-4 mr-2" />
                                Remove
                              </Button>
                            </AlertDialogTrigger>
                            <AlertDialogContent>
                              <AlertDialogHeader>
                                <AlertDialogTitle>Remove from Marketplace?</AlertDialogTitle>
                                <AlertDialogDescription>
                                  This will remove the deck from the marketplace. All ratings and comments will be deleted.
                                  This action cannot be undone.
                                </AlertDialogDescription>
                              </AlertDialogHeader>
                              <AlertDialogFooter>
                                <AlertDialogCancel>Cancel</AlertDialogCancel>
                                <AlertDialogAction
                                  onClick={() => handleRemoveFromMarketplace(deck.id)}
                                  className="bg-red-600 hover:bg-red-700"
                                >
                                  Remove
                                </AlertDialogAction>
                              </AlertDialogFooter>
                            </AlertDialogContent>
                          </AlertDialog>

                        </CardFooter>
                      </Card>
                    </motion.div>
                  ))}
                </AnimatePresence>
              </div>
            </TabsContent>
          </Tabs>
        </div>
      </div>

      {selectedDeck && (
        <>
          <DeckRatingDialog
            deck={selectedDeck}
            open={isRatingOpen}
            onOpenChange={setIsRatingOpen}
            onRatingSubmit={(rating: number, newAverage: number, newCount: number) => {
              if (selectedDeck.userId === session?.user?.id) {
                toast({
                  title: "Error",
                  description: "You cannot rate your own deck",
                  variant: "destructive",
                });
                return;
              }
              handleRatingSubmit(rating, newAverage, newCount);
            }}
          />
          <DeckCommentsDialog
            deck={{
              ...selectedDeck,
              deckOwnerName: selectedDeck.user?.name || 'Anonymous'
            }}
            open={isCommentsOpen}
            onOpenChange={setIsCommentsOpen}
            currentUserId={session?.user?.id}
          />
        </>
      )}
    </div>
  );
}

================
File: app/marketplace/page.tsx
================
import MarketplaceClient from './MarketplaceClient';

export default function MarketplacePage() {
  return <MarketplaceClient />;
}

================
File: app/review/page.tsx
================
import ReviewPageClient from "./ReviewPageClient";

export const revalidate = 0;

export default function ReviewPage() {
  return <ReviewPageClient />;
}

================
File: app/review/ReviewCompletion.tsx
================
import { Button } from "@/components/ui/button";
import { motion } from "framer-motion";
import { CheckCircle, ChevronLeft } from "lucide-react";

export default function ReviewCompletion({ 
    cardsReviewed, 
    studyTime,
    onStartNewSession,
    onBackToDecks 
  }: { 
    cardsReviewed: number;
    studyTime: { hours: number; minutes: number };
    onStartNewSession: () => void;
    onBackToDecks: () => void;
  }) {
    return (
      <div className="flex flex-col items-center justify-center min-h-[60vh] p-6">
        <motion.div
          initial={{ scale: 0 }}
          animate={{ scale: 1 }}
          transition={{ type: "spring", stiffness: 260, damping: 20 }}
          className="w-16 h-16 bg-green-100 dark:bg-green-900/20 rounded-full flex items-center justify-center mb-6"
        >
          <CheckCircle className="w-8 h-8 text-green-600 dark:text-green-400" />
        </motion.div>
        
        <h2 className="text-3xl font-light text-neutral-800 dark:text-white mb-3">
          Review Complete!
        </h2>
        
        <div className="text-center space-y-2 mb-8">
          <p className="text-neutral-600 dark:text-neutral-400">
            You've reviewed {cardsReviewed} cards
          </p>
          <p className="text-neutral-600 dark:text-neutral-400">
            Study time: {studyTime.hours}h {studyTime.minutes}m
          </p>
        </div>
  
        <div className="flex space-x-4">
          <Button
            variant="outline"
            onClick={onBackToDecks}
            className="dark:border-white/10 dark:hover:border-white/20 dark:text-white"
          >
            <ChevronLeft className="mr-2 h-4 w-4" />
            Back to Decks
          </Button>
          <Button
            onClick={onStartNewSession}
            className="dark:bg-white dark:text-black dark:hover:bg-neutral-200"
          >
            Start New Session
          </Button>
        </div>
      </div>
    );
  }

================
File: app/review/ReviewDeckSelector.tsx
================
import React from 'react';
import { Check, ChevronDown } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
} from "@/components/ui/command";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Deck } from "@/lib/types";
import { cn } from "@/lib/utils";
import { motion } from 'framer-motion';

interface ReviewDeckSelectorProps {
  decks: Deck[];
  selectedDecks: Deck[];
  onSelectDecks: (decks: Deck[]) => void;
  onStartReview: () => void;
}

export default function ReviewDeckSelector({ 
  decks, 
  selectedDecks, 
  onSelectDecks,
  onStartReview 
}: ReviewDeckSelectorProps) {
  const [open, setOpen] = React.useState(false);

  const toggleDeck = (deck: Deck) => {
    const isSelected = selectedDecks.some(d => d.id === deck.id);
    if (isSelected) {
      onSelectDecks(selectedDecks.filter(d => d.id !== deck.id));
    } else {
      onSelectDecks([...selectedDecks, deck]);
    }
  };

  return (
    <div className="flex flex-col items-center gap-6 p-8 max-w-xl mx-auto">
      <motion.div 
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        className="w-full space-y-4 text-center"
      >
        <h2 className="text-3xl font-light text-neutral-800 dark:text-white">
          Start Review Session
        </h2>
        <p className="text-lg text-neutral-600 dark:text-neutral-400">
          Select the decks you want to review
        </p>
      </motion.div>

      <motion.div 
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ delay: 0.1 }}
        className="w-full space-y-4"
      >
        <Popover open={open} onOpenChange={setOpen}>
          <PopoverTrigger asChild>
            <Button
              variant="outline"
              role="combobox"
              aria-expanded={open}
              className="w-full h-auto py-4 justify-between dark:border-white/10 dark:bg-white/5 text-left"
            >
              <div className="flex flex-col items-start gap-1">
                <span className="text-sm text-neutral-500 dark:text-neutral-400">
                  {selectedDecks.length === 0 ? "Select decks to review" : "Selected decks"}
                </span>
                <span className="font-medium">
                  {selectedDecks.length === 0
                    ? "No decks selected"
                    : `${selectedDecks.length} deck${selectedDecks.length === 1 ? '' : 's'} selected`}
                </span>
              </div>
              <ChevronDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
            </Button>
          </PopoverTrigger>
          <PopoverContent className="w-full p-0" align="start">
            <Command className="border dark:border-white/10">
              <CommandInput placeholder="Search decks..." className="h-12" />
              <CommandEmpty>No decks found.</CommandEmpty>
              <CommandGroup className="max-h-[300px] overflow-auto p-2">
                {decks.map((deck) => (
                  <CommandItem
                    key={deck.id}
                    onSelect={() => toggleDeck(deck)}
                    className="flex items-center gap-2 p-2 cursor-pointer"
                  >
                    <div
                      className={cn(
                        "flex h-4 w-4 items-center justify-center rounded border transition-colors",
                        selectedDecks.some(d => d.id === deck.id)
                          ? "border-primary bg-primary text-primary-foreground"
                          : "border-neutral-300 dark:border-neutral-700"
                      )}
                    >
                      {selectedDecks.some(d => d.id === deck.id) && (
                        <Check className="h-3 w-3" />
                      )}
                    </div>
                    <span>{deck.title}</span>
                  </CommandItem>
                ))}
              </CommandGroup>
            </Command>
          </PopoverContent>
        </Popover>

        <Button
          onClick={onStartReview}
          disabled={selectedDecks.length === 0}
          className="w-full h-12 dark:bg-white dark:text-black dark:hover:bg-neutral-200 text-lg font-medium"
        >
          Start Review
        </Button>
      </motion.div>
    </div>
  );
}

================
File: app/review/ReviewPageClient.tsx
================
// app/review/ReviewPageClient.tsx
'use client'

import React, { useState, useEffect } from 'react';
import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { Deck, Flashcard } from '@/lib/types';
import { useToast } from "@/hooks/use-toast";
import ReviewDeckSelector from './ReviewDeckSelector';
import ReviewSession from './ReviewSession';
import { Button } from '@/components/ui/button';

export default function ReviewPageClient() {
  const { data: session } = useSession();
  const [decks, setDecks] = useState<Deck[]>([]);
  const [selectedDecks, setSelectedDecks] = useState<Deck[]>([]);
  const [flashcards, setFlashcards] = useState<Flashcard[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isReviewStarted, setIsReviewStarted] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { toast } = useToast();
  const router = useRouter();

  useEffect(() => {
    if (!session?.user?.id) {
      router.push('/auth/signin');
      return;
    }
    fetchDecks();
  }, [session?.user?.id]);

  const fetchDecks = async () => {
    try {
      const response = await fetch(`/api/decks?userId=${session?.user?.id}`);
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to fetch decks');
      }
      const data = await response.json();
      setDecks(data);
    } catch (error) {
      console.error('Error fetching decks:', error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Failed to load decks",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };

  const startReview = async () => {
    if (selectedDecks.length === 0) {
      toast({
        title: "Error",
        description: "Please select at least one deck to review",
        variant: "destructive",
      });
      return;
    }

    setIsLoading(true);
    setError(null);
    const allFlashcards: Flashcard[] = [];

    try {
      for (const deck of selectedDecks) {
        const response = await fetch(`/api/flashcards?deckId=${deck.id}`);
        
        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || `Failed to fetch flashcards for deck ${deck.id}`);
        }
        
        const deckFlashcards = await response.json();
        
        if (!Array.isArray(deckFlashcards)) {
          throw new Error(`Invalid response format for deck ${deck.id}`);
        }
        
        allFlashcards.push(...deckFlashcards);
      }

      if (allFlashcards.length === 0) {
        toast({
          title: "No Cards",
          description: "Selected decks contain no flashcards",
          variant: "default",
        });
        return;
      }

      const shuffled = [...allFlashcards].sort(() => Math.random() - 0.5);
      setFlashcards(shuffled);
      setIsReviewStarted(true);
    } catch (error) {
      console.error('Error starting review:', error);
      setError(error instanceof Error ? error.message : 'Failed to start review');
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Failed to start review",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };

  if (!session?.user?.id) {
    return null;
  }

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[60vh]">
        <div className="text-lg text-neutral-600 dark:text-neutral-400">
          Loading...
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex flex-col items-center justify-center min-h-[60vh] gap-4">
        <div className="text-red-500 dark:text-red-400">{error}</div>
        <Button onClick={() => setError(null)}>Try Again</Button>
      </div>
    );
  }

  if (!isReviewStarted) {
    return (
      <ReviewDeckSelector
        decks={decks}
        selectedDecks={selectedDecks}
        onSelectDecks={setSelectedDecks}
        onStartReview={startReview}
      />
    );
  }

  return (
    <ReviewSession 
      flashcards={flashcards}
      onComplete={() => {
        setIsReviewStarted(false);
        setSelectedDecks([]);
      }}
      userId={session.user.id}
    />
  );
}

================
File: app/review/ReviewSession.tsx
================
// app/review/ReviewSession.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import { Flashcard as FlashcardType } from '@/lib/types';
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { motion } from 'framer-motion';
import { useToast } from "@/hooks/use-toast";
import { ChevronLeft, ThumbsUp, ThumbsDown, AlertCircle, Trophy } from 'lucide-react';
import ReviewCompletion from './ReviewCompletion';
import Flashcard from '@/components/Flashcard';
import { fsrs, type Rating, type CardState } from '@/lib/fsrs';

interface ReviewSessionProps {
  flashcards: FlashcardType[];
  onComplete: () => void;
  userId: string;
}

export default function ReviewSession({
  flashcards: initialFlashcards,
  onComplete,
  userId
}: ReviewSessionProps) {
  const [originalCards] = useState(initialFlashcards);
  const [reviewQueue, setReviewQueue] = useState<FlashcardType[]>([...initialFlashcards]);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [isCompleted, setIsCompleted] = useState(false);
  const [sessionStartTime] = useState(() => Date.now());
  const [responseStartTime, setResponseStartTime] = useState<number>(Date.now());
  const [totalResponseTime, setTotalResponseTime] = useState(0);
  const [reviewedCount, setReviewedCount] = useState(0);
  const [correctCount, setCorrectCount] = useState(0);
  const [incorrectCount, setIncorrectCount] = useState(0);
  const { toast } = useToast();
  const router = useRouter();

  // Check if we've run out of cards
  useEffect(() => {
    if (reviewQueue.length === 0) {
      handleSessionComplete();
    }
  }, [reviewQueue]);

  // Get current card safely
  const currentCard = reviewQueue[currentIndex];
  const progress = originalCards.length > 0 ? (reviewedCount / originalCards.length) * 100 : 0;

  const createStudySession = async () => {
    try {
      const sessionData = {
        userId,
        cardsStudied: reviewedCount,
        startTime: sessionStartTime,
        endTime: Date.now(),
        correctCount,
        incorrectCount,
        averageTime: reviewedCount > 0 ? Math.round(totalResponseTime / reviewedCount) : 0
      };

      const response = await fetch('/api/study-sessions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(sessionData),
      });

      if (!response.ok) {
        throw new Error('Failed to save study session');
      }

      // Don't show success toast to avoid UI clutter
      console.log('Study session saved successfully');
    } catch (error) {
      console.error('Error saving study session:', error);
      toast({
        title: "Error",
        description: "Failed to save study progress",
        variant: "destructive",
      });
    }
  };

  const handleSessionComplete = async () => {
    setIsCompleted(true);
    if (reviewedCount > 0) {
      await createStudySession();
    }
  };

  const handleCardUpdate = async (rating: Rating) => {
    if (!currentCard) return;
  
    const responseTime = Date.now() - responseStartTime;
    setTotalResponseTime(prev => prev + responseTime);
  
    try {
      // Calculate new state using FSRS
      const currentState: CardState = {
        state: currentCard.state || 'new',
        stability: Number(currentCard.stability || 1),
        difficulty: Number(currentCard.difficulty || 5),
        elapsedDays: Number(currentCard.elapsedDays || 0),
        scheduledDays: Number(currentCard.scheduledDays || 0),
        reps: Number(currentCard.reps || 0),
        lapses: Number(currentCard.lapses || 0),
      };
  
      const newState = fsrs.updateState(currentState, rating);
      const nextReviewDate = fsrs.getNextReviewDate(newState);
  
      // Prepare update data
      const updateData = {
        front: currentCard.front,
        back: currentCard.back,
        reviewData: {
          lastReviewed: Date.now(),
          nextReview: nextReviewDate.getTime(),
          state: newState.state,
          stability: Number(newState.stability),
          difficulty: Number(newState.difficulty),
          elapsedDays: Number(newState.elapsedDays),
          scheduledDays: Number(newState.scheduledDays),
          reps: Number(currentCard.reps || 0) + 1,
          lapses: Number(newState.lapses)
        }
      };
  
      console.log('Sending update data:', updateData);
  
      // Update the flashcard
      const response = await fetch(`/api/flashcards/${currentCard.id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(updateData)
      });
  
      if (!response.ok) {
        const errorData = await response.json();
        console.error('Update error response:', errorData);
        throw new Error(errorData.error || 'Failed to update flashcard');
      }
  
      const result = await response.json();
      console.log('Update success:', result);
  
      // Handle successful update
      if (rating.rating === 'again') {
        setIncorrectCount(prev => prev + 1);
        
        // Remove current card and add it back later in the queue
        const newQueue = [...reviewQueue];
        newQueue.splice(currentIndex, 1);
        
        const reinsertPosition = Math.min(
          currentIndex + 3 + Math.floor(Math.random() * 5),
          newQueue.length
        );
        newQueue.splice(reinsertPosition, 0, currentCard);
        
        setReviewQueue(newQueue);
      } else {
        setCorrectCount(prev => prev + 1);
        setReviewedCount(prev => prev + 1);
        
        // Remove the current card from the queue
        const newQueue = [...reviewQueue];
        newQueue.splice(currentIndex, 1);
        setReviewQueue(newQueue);
        
        if (currentIndex >= newQueue.length) {
          setCurrentIndex(Math.max(0, newQueue.length - 1));
        }
      }
  
      setResponseStartTime(Date.now());
  
    } catch (error) {
      console.error('Error updating flashcard:', error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Failed to update flashcard",
        variant: "destructive",
      });
    }
  };

  const updateFlashcardInDb = async (
    id: string,
    newState: CardState,
    nextReviewDate: Date | null,
    ratingValue: number,
    responseTimeMs: number
  ) => {
    try {
      // Clamp extremely large numbers to safe values
      const stability = Math.min(Number(newState.stability), Number.MAX_SAFE_INTEGER);
      const scheduledDays = Math.min(Number(newState.scheduledDays), Number.MAX_SAFE_INTEGER);
  
      const updateData = {
        front: currentCard.front,
        back: currentCard.back,
        reviewData: {
          lastReviewed: Date.now(),
          nextReview: nextReviewDate ? nextReviewDate.getTime() : null,
          state: newState.state,
          stability,
          difficulty: Number(newState.difficulty),
          elapsedDays: Number(newState.elapsedDays),
          scheduledDays,
          reps: Number(currentCard.reps || 0) + 1,
          lapses: Number(newState.lapses)
        }
      };
  
      console.log('Sending update data:', JSON.stringify(updateData, null, 2));
  
      const response = await fetch(`/api/flashcards/${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(updateData)
      });
  
      const responseData = await response.json();
  
      if (!response.ok) {
        console.error('Update error response:', responseData);
        throw new Error(responseData.error || 'Failed to update flashcard');
      }
  
      return responseData;
      
    } catch (error) {
      console.error('Error updating flashcard:', error);
      throw error;
    }
  };
  

  // Show empty state if there were no cards to begin with
  if (originalCards.length === 0) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <h2 className="text-2xl font-light mb-4">No cards available for review</h2>
          <Button onClick={onComplete}>Return to Collections</Button>
        </div>
      </div>
    );
  }

  const studyTime = {
    hours: Math.floor((Date.now() - sessionStartTime) / (1000 * 60 * 60)),
    minutes: Math.floor(((Date.now() - sessionStartTime) / (1000 * 60)) % 60)
  };

  if (isCompleted || reviewQueue.length === 0) {
    return (
      <ReviewCompletion
        cardsReviewed={reviewedCount}
        studyTime={studyTime}
        onStartNewSession={onComplete}
        onBackToDecks={() => router.push('/decks')}
      />
    );
  }

  // Safely render the review interface only if we have a current card
  if (!currentCard) {
    return null;
  }

  return (
    <div className="max-w-4xl mx-auto p-4">
      <div className="mb-8">
        <div className="flex items-center justify-between mb-4">
          <Button
            variant="ghost"
            onClick={onComplete}
            className="text-neutral-600 dark:text-neutral-400 hover:bg-neutral-100 dark:hover:bg-white/5"
          >
            <ChevronLeft className="mr-2 h-4 w-4" />
            End Session
          </Button>
          <div className="text-sm text-neutral-600 dark:text-neutral-400">
            {reviewedCount} of {originalCards.length} cards
          </div>
        </div>
        <Progress value={progress} className="h-2 dark:bg-white/5" />
      </div>

      <motion.div
        key={currentCard.id}
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        exit={{ opacity: 0, y: -20 }}
        transition={{ duration: 0.3 }}
      >
        <div className="mb-6">
          <Flashcard
            front={currentCard.front}
            back={currentCard.back}
          />
        </div>

        <div className="grid grid-cols-4 gap-4">
          <Button
            onClick={() => handleCardUpdate({ rating: 'again', value: 1 })}
            className="bg-red-600 hover:bg-red-700 dark:bg-red-500/20 dark:hover:bg-red-500/30 text-white dark:text-red-400"
          >
            <AlertCircle className="mr-2 h-4 w-4" />
            Again
          </Button>
          <Button
            onClick={() => handleCardUpdate({ rating: 'hard', value: 2 })}
            className="bg-yellow-600 hover:bg-yellow-700 dark:bg-yellow-500/20 dark:hover:bg-yellow-500/30 text-white dark:text-yellow-400"
          >
            <ThumbsDown className="mr-2 h-4 w-4" />
            Hard
          </Button>
          <Button
            onClick={() => handleCardUpdate({ rating: 'good', value: 3 })}
            className="bg-green-600 hover:bg-green-700 dark:bg-green-500/20 dark:hover:bg-green-500/30 text-white dark:text-green-400"
          >
            <ThumbsUp className="mr-2 h-4 w-4" />
            Good
          </Button>
          <Button
            onClick={() => handleCardUpdate({ rating: 'easy', value: 4 })}
            className="bg-blue-600 hover:bg-blue-700 dark:bg-blue-500/20 dark:hover:bg-blue-500/30 text-white dark:text-blue-400"
          >
            <Trophy className="mr-2 h-4 w-4" />
            Easy
          </Button>
        </div>
      </motion.div>
    </div>
  );
}

================
File: app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 44 47% 95%;
    --foreground: 20 14.3% 4.1%;
    --card: 0 0% 100%;
    --card-foreground: 20 14.3% 4.1%;
    --popover: 0 0% 100%;
    --popover-foreground: 20 14.3% 4.1%;
    --primary: 24 9.8% 10%;
    --primary-foreground: 60 9.1% 97.8%;
    --secondary: 60 4.8% 95.9%;
    --secondary-foreground: 24 9.8% 10%;
    --muted: 60 4.8% 95.9%;
    --muted-foreground: 25 5.3% 44.7%;
    --accent: 60 4.8% 95.9%;
    --accent-foreground: 24 9.8% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 60 9.1% 97.8%;
    --border: 20 5.9% 90%;
    --input: 20 5.9% 90%;
    --ring: 24 9.8% 10%;
    --radius: 0.75rem;
  }
 
  .dark {
    --background: 20 14% 8%;
    --foreground: 60 9.1% 97.8%;
    --card: 20 14% 12%;
    --card-foreground: 60 9.1% 97.8%;
    --popover: 20 14% 12%;
    --popover-foreground: 60 9.1% 97.8%;
    --primary: 60 9.1% 97.8%;
    --primary-foreground: 24 9.8% 10%;
    --secondary: 12 6.5% 15.1%;
    --secondary-foreground: 60 9.1% 97.8%;
    --muted: 12 6.5% 15.1%;
    --muted-foreground: 24 5.4% 63.9%;
    --accent: 12 6.5% 15.1%;
    --accent-foreground: 60 9.1% 97.8%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 60 9.1% 97.8%;
    --border: 12 6.5% 15.1%;
    --input: 12 6.5% 15.1%;
    --ring: 24 5.7% 82.9%;
  }

  * {
    @apply border-border;
  }

  body {
    @apply bg-background text-foreground;
    font-feature-settings: "rlig" 1, "calt" 1;
  }

  .dark body {
    background: radial-gradient(
      circle at center,
      hsl(20 14% 12%) 0%,
      hsl(20 14% 8%) 100%
    );
  }

  .dark .glass-card {
    background: rgba(255, 255, 255, 0.03);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.05);
  }

  .dark .glass-effect {
    background: linear-gradient(
      135deg,
      rgba(255, 255, 255, 0.05) 0%,
      rgba(255, 255, 255, 0.01) 100%
    );
  }

  .dark .nav-blur {
    background: rgba(24, 24, 27, 0.7);
    backdrop-filter: blur(10px);
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  }

  .dark ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }

  .dark ::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
  }

  .dark ::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
  }

  .dark ::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.15);
  }
}

@keyframes float {
  0% { transform: translateY(0px); }
  50% { transform: translateY(-10px); }
  100% { transform: translateY(0px); }
}

.animate-float {
  animation: float 3s ease-in-out infinite;
}

.grid-cols-52 {
  grid-template-columns: repeat(52, minmax(0, 1fr));
}

================
File: app/HomeClient.tsx
================
'use client'

import { SignInButton } from '@/components/SignInButton'
import { motion } from 'framer-motion'
import { Brain, Sparkles, RefreshCw, ChevronRight } from 'lucide-react'
import { Button } from '@/components/ui/button'

export default function HomeClient() {
  return (
    <div className="min-h-[calc(100vh-4rem)] flex flex-col">
      <div className="flex-1 flex flex-col">
        <div className="flex-1 px-4 pb-20">
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5 }}
            className="container max-w-6xl mx-auto pt-20 md:pt-32"
          >
            <div className="text-center mb-16">
              <h1 className="text-4xl md:text-6xl lg:text-7xl font-light tracking-tight text-neutral-900 dark:text-white mb-6">
                Simple,
                <span className="text-neutral-500 dark:text-neutral-400"> But Efficient</span>
              </h1>
              <p className="text-lg md:text-xl text-neutral-600 dark:text-neutral-400 mb-8 max-w-3xl mx-auto">
                Master any subject with our intelligent flashcard system. Built for students, professionals, and lifelong learners.
              </p>
              <div className="flex justify-center gap-4">
                <SignInButton className="bg-neutral-900 text-white hover:bg-neutral-800 dark:bg-white dark:text-black dark:hover:bg-neutral-200" />

              </div>
            </div>

            <motion.div
              initial={{ opacity: 0, y: 40 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.5, delay: 0.2 }}
              className="grid grid-cols-1 md:grid-cols-3 gap-8 md:gap-12"
            >
              <div className="relative group">
                <div className="absolute inset-0 bg-gradient-to-r from-blue-500/10 to-purple-500/10 dark:from-blue-500/5 dark:to-purple-500/5 rounded-2xl blur-xl transition-all duration-500 group-hover:scale-110" />
                <div className="relative p-8 dark:glass-card rounded-2xl border border-neutral-200/50 dark:border-white/5">
                  <div className="w-12 h-12 bg-neutral-900 dark:bg-white rounded-xl flex items-center justify-center mb-6 group-hover:scale-110 transition-transform">
                    <Brain className="w-6 h-6 text-white dark:text-black" />
                  </div>
                  <h3 className="text-xl font-medium mb-3 text-neutral-900 dark:text-white">Smart Learning</h3>
                  <p className="text-neutral-600 dark:text-neutral-400">
                    Our spaced repetition system adapts to your learning pace, ensuring optimal retention.
                  </p>
                </div>
              </div>

              <div className="relative group">
                <div className="absolute inset-0 bg-gradient-to-r from-green-500/10 to-emerald-500/10 dark:from-green-500/5 dark:to-emerald-500/5 rounded-2xl blur-xl transition-all duration-500 group-hover:scale-110" />
                <div className="relative p-8 dark:glass-card rounded-2xl border border-neutral-200/50 dark:border-white/5">
                  <div className="w-12 h-12 bg-neutral-900 dark:bg-white rounded-xl flex items-center justify-center mb-6 group-hover:scale-110 transition-transform">
                    <Sparkles className="w-6 h-6 text-white dark:text-black" />
                  </div>
                  <h3 className="text-xl font-medium mb-3 text-neutral-900 dark:text-white">Beautiful Interface</h3>
                  <p className="text-neutral-600 dark:text-neutral-400">
                    A clean, minimalist design that helps you focus on what matters most: learning.
                  </p>
                </div>
              </div>

              <div className="relative group">
                <div className="absolute inset-0 bg-gradient-to-r from-orange-500/10 to-red-500/10 dark:from-orange-500/5 dark:to-red-500/5 rounded-2xl blur-xl transition-all duration-500 group-hover:scale-110" />
                <div className="relative p-8 dark:glass-card rounded-2xl border border-neutral-200/50 dark:border-white/5">
                  <div className="w-12 h-12 bg-neutral-900 dark:bg-white rounded-xl flex items-center justify-center mb-6 group-hover:scale-110 transition-transform">
                    <RefreshCw className="w-6 h-6 text-white dark:text-black" />
                  </div>
                  <h3 className="text-xl font-medium mb-3 text-neutral-900 dark:text-white">Active Recall</h3>
                  <p className="text-neutral-600 dark:text-neutral-400">
                    Strengthen your memory through proven active recall techniques and spaced repetition.
                  </p>
                </div>
              </div>
            </motion.div>
          </motion.div>
        </div>

        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5, delay: 0.4 }}
          className="bg-white dark:bg-white/[0.02] border-t border-neutral-200 dark:border-white/5 py-16 md:py-24"
        >
          
        </motion.div>
      </div>
    </div>
  )
}

================
File: app/layout.tsx
================
import './globals.css'
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import { SessionProvider } from "@/components/SessionProvider"
import { ThemeProvider } from "@/components/theme-provider"
import Navbar from '@/components/Navbar'
import { Toaster } from "@/components/ui/toaster"

const inter = Inter({ 
  subsets: ['latin'],
  variable: '--font-inter',
})

export const metadata: Metadata = {
  title: 'Flashcards',
  description: 'Modern spaced repetition learning',
}

function NavbarWrapper() {
  return (
    <SessionProvider>
      <Navbar />
    </SessionProvider>
  )
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={`${inter.className} bg-[#F5F2EA] min-h-screen`}>
        <ThemeProvider
          attribute="class"
          defaultTheme="light"
          enableSystem
          disableTransitionOnChange
        >
          <NavbarWrapper />
          <SessionProvider>
            <main className="pt-20 min-h-[calc(100vh-4rem)]">
              {children}
            </main>
          </SessionProvider>
          <Toaster />
        </ThemeProvider>
      </body>
    </html>
  )
}

================
File: app/page.tsx
================
import { redirect } from 'next/navigation'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import HomeClient from './HomeClient'

export default async function Home() {
  const session = await getServerSession(authOptions)
  
  if (session) {
    redirect('/decks')
  }

  return <HomeClient />
}

================
File: components/ui/accordion.tsx
================
'use client';

import * as React from 'react';
import * as AccordionPrimitive from '@radix-ui/react-accordion';
import { ChevronDown } from 'lucide-react';

import { cn } from '@/lib/utils';

const Accordion = AccordionPrimitive.Root;

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn('border-b', className)}
    {...props}
  />
));
AccordionItem.displayName = 'AccordionItem';

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        'flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180',
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
));
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName;

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn('pb-4 pt-0', className)}>{children}</div>
  </AccordionPrimitive.Content>
));

AccordionContent.displayName = AccordionPrimitive.Content.displayName;

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent };

================
File: components/ui/alert-dialog.tsx
================
'use client';

import * as React from 'react';
import * as AlertDialogPrimitive from '@radix-ui/react-alert-dialog';

import { cn } from '@/lib/utils';
import { buttonVariants } from '@/components/ui/button';

const AlertDialog = AlertDialogPrimitive.Root;

const AlertDialogTrigger = AlertDialogPrimitive.Trigger;

const AlertDialogPortal = AlertDialogPrimitive.Portal;

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      'fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className
    )}
    {...props}
    ref={ref}
  />
));
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName;

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        'fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg',
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
));
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName;

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col space-y-2 text-center sm:text-left',
      className
    )}
    {...props}
  />
);
AlertDialogHeader.displayName = 'AlertDialogHeader';

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className
    )}
    {...props}
  />
);
AlertDialogFooter.displayName = 'AlertDialogFooter';

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn('text-lg font-semibold', className)}
    {...props}
  />
));
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName;

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName;

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
));
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName;

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: 'outline' }),
      'mt-2 sm:mt-0',
      className
    )}
    {...props}
  />
));
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName;

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
};

================
File: components/ui/alert.tsx
================
import * as React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const alertVariants = cva(
  'relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground',
  {
    variants: {
      variant: {
        default: 'bg-background text-foreground',
        destructive:
          'border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
));
Alert.displayName = 'Alert';

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn('mb-1 font-medium leading-none tracking-tight', className)}
    {...props}
  />
));
AlertTitle.displayName = 'AlertTitle';

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('text-sm [&_p]:leading-relaxed', className)}
    {...props}
  />
));
AlertDescription.displayName = 'AlertDescription';

export { Alert, AlertTitle, AlertDescription };

================
File: components/ui/aspect-ratio.tsx
================
'use client';

import * as AspectRatioPrimitive from '@radix-ui/react-aspect-ratio';

const AspectRatio = AspectRatioPrimitive.Root;

export { AspectRatio };

================
File: components/ui/avatar.tsx
================
'use client';

import * as React from 'react';
import * as AvatarPrimitive from '@radix-ui/react-avatar';

import { cn } from '@/lib/utils';

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      'relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full',
      className
    )}
    {...props}
  />
));
Avatar.displayName = AvatarPrimitive.Root.displayName;

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn('aspect-square h-full w-full', className)}
    {...props}
  />
));
AvatarImage.displayName = AvatarPrimitive.Image.displayName;

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      'flex h-full w-full items-center justify-center rounded-full bg-muted',
      className
    )}
    {...props}
  />
));
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName;

export { Avatar, AvatarImage, AvatarFallback };

================
File: components/ui/badge.tsx
================
import * as React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const badgeVariants = cva(
  'inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2',
  {
    variants: {
      variant: {
        default:
          'border-transparent bg-primary text-primary-foreground hover:bg-primary/80',
        secondary:
          'border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80',
        destructive:
          'border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80',
        outline: 'text-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };

================
File: components/ui/breadcrumb.tsx
================
import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { ChevronRight, MoreHorizontal } from 'lucide-react';

import { cn } from '@/lib/utils';

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<'nav'> & {
    separator?: React.ReactNode;
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />);
Breadcrumb.displayName = 'Breadcrumb';

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<'ol'>
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      'flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5',
      className
    )}
    {...props}
  />
));
BreadcrumbList.displayName = 'BreadcrumbList';

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<'li'>
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn('inline-flex items-center gap-1.5', className)}
    {...props}
  />
));
BreadcrumbItem.displayName = 'BreadcrumbItem';

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<'a'> & {
    asChild?: boolean;
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : 'a';

  return (
    <Comp
      ref={ref}
      className={cn('transition-colors hover:text-foreground', className)}
      {...props}
    />
  );
});
BreadcrumbLink.displayName = 'BreadcrumbLink';

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<'span'>
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn('font-normal text-foreground', className)}
    {...props}
  />
));
BreadcrumbPage.displayName = 'BreadcrumbPage';

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<'li'>) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn('[&>svg]:size-3.5', className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
);
BreadcrumbSeparator.displayName = 'BreadcrumbSeparator';

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<'span'>) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn('flex h-9 w-9 items-center justify-center', className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
);
BreadcrumbEllipsis.displayName = 'BreadcrumbElipssis';

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
};

================
File: components/ui/button.tsx
================
// components/ui/button.tsx
import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/utils';

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-lg text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-neutral-900 text-neutral-50 hover:bg-neutral-800 dark:bg-white dark:text-black dark:hover:bg-neutral-200",
        destructive: "bg-red-500/90 text-neutral-50 hover:bg-red-500 dark:bg-red-900/90 dark:hover:bg-red-900",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground dark:border-white/10 dark:hover:border-white/20 dark:text-white",
        secondary: "bg-neutral-100 text-neutral-900 hover:bg-neutral-200 dark:bg-white/10 dark:text-neutral-100 dark:hover:bg-white/20",
        ghost: "hover:bg-neutral-100 hover:text-neutral-900 dark:hover:bg-white/5 dark:hover:text-neutral-100",
        link: "text-neutral-900 underline-offset-4 hover:underline dark:text-neutral-100",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : 'button';
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);
Button.displayName = 'Button';

export { Button, buttonVariants };

================
File: components/ui/calendar.tsx
================
'use client';

import * as React from 'react';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { DayPicker } from 'react-day-picker';

import { cn } from '@/lib/utils';
import { buttonVariants } from '@/components/ui/button';

export type CalendarProps = React.ComponentProps<typeof DayPicker>;

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn('p-3', className)}
      classNames={{
        months: 'flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0',
        month: 'space-y-4',
        caption: 'flex justify-center pt-1 relative items-center',
        caption_label: 'text-sm font-medium',
        nav: 'space-x-1 flex items-center',
        nav_button: cn(
          buttonVariants({ variant: 'outline' }),
          'h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100'
        ),
        nav_button_previous: 'absolute left-1',
        nav_button_next: 'absolute right-1',
        table: 'w-full border-collapse space-y-1',
        head_row: 'flex',
        head_cell:
          'text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]',
        row: 'flex w-full mt-2',
        cell: 'h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20',
        day: cn(
          buttonVariants({ variant: 'ghost' }),
          'h-9 w-9 p-0 font-normal aria-selected:opacity-100'
        ),
        day_range_end: 'day-range-end',
        day_selected:
          'bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground',
        day_today: 'bg-accent text-accent-foreground',
        day_outside:
          'day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30',
        day_disabled: 'text-muted-foreground opacity-50',
        day_range_middle:
          'aria-selected:bg-accent aria-selected:text-accent-foreground',
        day_hidden: 'invisible',
        ...classNames,
      }}
      components={{
        IconLeft: ({ ...props }) => <ChevronLeft className="h-4 w-4" />,
        IconRight: ({ ...props }) => <ChevronRight className="h-4 w-4" />,
      }}
      {...props}
    />
  );
}
Calendar.displayName = 'Calendar';

export { Calendar };

================
File: components/ui/card.tsx
================
import * as React from "react"
import { cn } from "@/lib/utils"

interface CardProps extends React.HTMLAttributes<HTMLDivElement> {}
interface CardHeaderProps extends React.HTMLAttributes<HTMLDivElement> {}
interface CardFooterProps extends React.HTMLAttributes<HTMLDivElement> {}
interface CardTitleProps extends React.HTMLAttributes<HTMLHeadingElement> {}
interface CardDescriptionProps extends React.HTMLAttributes<HTMLParagraphElement> {}
interface CardContentProps extends React.HTMLAttributes<HTMLDivElement> {}

const Card = React.forwardRef<HTMLDivElement, CardProps>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn(
        "rounded-lg border border-neutral-200 bg-white text-neutral-950 shadow-sm transition-all dark:glass-card dark:border-white/5 dark:text-neutral-50",
        className
      )}
      {...props}
    />
  )
)
Card.displayName = "Card"

const CardHeader = React.forwardRef<HTMLDivElement, CardHeaderProps>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn("flex flex-col space-y-1.5 p-6", className)}
      {...props}
    />
  )
)
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<HTMLHeadingElement, CardTitleProps>(
  ({ className, ...props }, ref) => (
    <h3
      ref={ref}
      className={cn("text-2xl font-light tracking-tight", className)}
      {...props}
    />
  )
)
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<HTMLParagraphElement, CardDescriptionProps>(
  ({ className, ...props }, ref) => (
    <p
      ref={ref}
      className={cn("text-sm text-neutral-600 dark:text-neutral-400", className)}
      {...props}
    />
  )
)
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<HTMLDivElement, CardContentProps>(
  ({ className, ...props }, ref) => (
    <div 
      ref={ref} 
      className={cn("p-6 pt-0", className)} 
      {...props} 
    />
  )
)
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<HTMLDivElement, CardFooterProps>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn("flex items-center p-6 pt-0", className)}
      {...props}
    />
  )
)
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

================
File: components/ui/carousel.tsx
================
'use client';

import * as React from 'react';
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from 'embla-carousel-react';
import { ArrowLeft, ArrowRight } from 'lucide-react';

import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';

type CarouselApi = UseEmblaCarouselType[1];
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>;
type CarouselOptions = UseCarouselParameters[0];
type CarouselPlugin = UseCarouselParameters[1];

type CarouselProps = {
  opts?: CarouselOptions;
  plugins?: CarouselPlugin;
  orientation?: 'horizontal' | 'vertical';
  setApi?: (api: CarouselApi) => void;
};

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0];
  api: ReturnType<typeof useEmblaCarousel>[1];
  scrollPrev: () => void;
  scrollNext: () => void;
  canScrollPrev: boolean;
  canScrollNext: boolean;
} & CarouselProps;

const CarouselContext = React.createContext<CarouselContextProps | null>(null);

function useCarousel() {
  const context = React.useContext(CarouselContext);

  if (!context) {
    throw new Error('useCarousel must be used within a <Carousel />');
  }

  return context;
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = 'horizontal',
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === 'horizontal' ? 'x' : 'y',
      },
      plugins
    );
    const [canScrollPrev, setCanScrollPrev] = React.useState(false);
    const [canScrollNext, setCanScrollNext] = React.useState(false);

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return;
      }

      setCanScrollPrev(api.canScrollPrev());
      setCanScrollNext(api.canScrollNext());
    }, []);

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev();
    }, [api]);

    const scrollNext = React.useCallback(() => {
      api?.scrollNext();
    }, [api]);

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === 'ArrowLeft') {
          event.preventDefault();
          scrollPrev();
        } else if (event.key === 'ArrowRight') {
          event.preventDefault();
          scrollNext();
        }
      },
      [scrollPrev, scrollNext]
    );

    React.useEffect(() => {
      if (!api || !setApi) {
        return;
      }

      setApi(api);
    }, [api, setApi]);

    React.useEffect(() => {
      if (!api) {
        return;
      }

      onSelect(api);
      api.on('reInit', onSelect);
      api.on('select', onSelect);

      return () => {
        api?.off('select', onSelect);
      };
    }, [api, onSelect]);

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === 'y' ? 'vertical' : 'horizontal'),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn('relative', className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    );
  }
);
Carousel.displayName = 'Carousel';

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel();

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          'flex',
          orientation === 'horizontal' ? '-ml-4' : '-mt-4 flex-col',
          className
        )}
        {...props}
      />
    </div>
  );
});
CarouselContent.displayName = 'CarouselContent';

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel();

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        'min-w-0 shrink-0 grow-0 basis-full',
        orientation === 'horizontal' ? 'pl-4' : 'pt-4',
        className
      )}
      {...props}
    />
  );
});
CarouselItem.displayName = 'CarouselItem';

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = 'outline', size = 'icon', ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel();

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        'absolute  h-8 w-8 rounded-full',
        orientation === 'horizontal'
          ? '-left-12 top-1/2 -translate-y-1/2'
          : '-top-12 left-1/2 -translate-x-1/2 rotate-90',
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  );
});
CarouselPrevious.displayName = 'CarouselPrevious';

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = 'outline', size = 'icon', ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel();

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        'absolute h-8 w-8 rounded-full',
        orientation === 'horizontal'
          ? '-right-12 top-1/2 -translate-y-1/2'
          : '-bottom-12 left-1/2 -translate-x-1/2 rotate-90',
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  );
});
CarouselNext.displayName = 'CarouselNext';

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
};

================
File: components/ui/chart.tsx
================
'use client';

import * as React from 'react';
import * as RechartsPrimitive from 'recharts';

import { cn } from '@/lib/utils';

// Add proper payload type
interface ChartPayload {
  value: number;
  payload: any;
  dataKey?: string;
  name?: string;
  color?: string;
  fill?: string;
}

const THEMES = { light: '', dark: '.dark' } as const;

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode;
    icon?: React.ComponentType;
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  );
};

type ChartContextProps = {
  config: ChartConfig;
};

const ChartContext = React.createContext<ChartContextProps | null>(null);

function useChart() {
  const context = React.useContext(ChartContext);

  if (!context) {
    throw new Error('useChart must be used within a <ChartContainer />');
  }

  return context;
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<'div'> & {
    config: ChartConfig;
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >['children'];
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId();
  const chartId = `chart-${id || uniqueId.replace(/:/g, '')}`;

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  );
});
ChartContainer.displayName = 'Chart';

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([_, config]) => config.theme || config.color
  );

  if (!colorConfig.length) {
    return null;
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color;
    return color ? `  --color-${key}: ${color};` : null;
  })
  .join('\n')}
}
`
          )
          .join('\n'),
      }}
    />
  );
};

const ChartTooltip = RechartsPrimitive.Tooltip;

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  Omit<React.ComponentProps<typeof RechartsPrimitive.Tooltip>, 'payload'> &
    React.ComponentProps<'div'> & {
      hideLabel?: boolean;
      hideIndicator?: boolean;
      indicator?: 'line' | 'dot' | 'dashed';
      nameKey?: string;
      labelKey?: string;
      payload?: ChartPayload[];
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = 'dot',
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart();

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null;
      }

      const [item] = payload;
      const key = `${labelKey || item.dataKey || item.name || 'value'}`;
      const itemConfig = getPayloadConfigFromPayload(config, item, key);
      const value =
        !labelKey && typeof label === 'string'
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label;

      if (labelFormatter) {
        return (
          <div className={cn('font-medium', labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        );
      }

      if (!value) {
        return null;
      }

      return <div className={cn('font-medium', labelClassName)}>{value}</div>;
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ]);

    if (!active || !payload?.length) {
      return null;
    }

    const nestLabel = payload.length === 1 && indicator !== 'dot';

    return (
      <div
        ref={ref}
        className={cn(
          'grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl',
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || 'value'}`;
            const itemConfig = getPayloadConfigFromPayload(config, item, key);
            const indicatorColor = color || item.payload?.fill || item.color;

            return (
              <div
                key={item.dataKey ?? index}
                className={cn(
                  'flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground',
                  indicator === 'dot' && 'items-center'
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            'shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]',
                            {
                              'h-2.5 w-2.5': indicator === 'dot',
                              'w-1': indicator === 'line',
                              'w-0 border-[1.5px] border-dashed bg-transparent':
                                indicator === 'dashed',
                              'my-0.5': nestLabel && indicator === 'dashed',
                            }
                          )}
                          style={
                            {
                              '--color-bg': indicatorColor,
                              '--color-border': indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        'flex flex-1 justify-between leading-none',
                        nestLabel ? 'items-end' : 'items-center'
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value !== undefined && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            );
          })}
        </div>
      </div>
    );
  }
);
ChartTooltipContent.displayName = 'ChartTooltip';

const ChartLegend = RechartsPrimitive.Legend;

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<'div'> &
    Pick<RechartsPrimitive.LegendProps, 'payload' | 'verticalAlign'> & {
      hideIcon?: boolean;
      nameKey?: string;
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = 'bottom', nameKey },
    ref
  ) => {
    const { config } = useChart();

    if (!payload?.length) {
      return null;
    }

    return (
      <div
        ref={ref}
        className={cn(
          'flex items-center justify-center gap-4',
          verticalAlign === 'top' ? 'pb-3' : 'pt-3',
          className
        )}
      >
        {payload.map((entry: any) => {
          const key = `${nameKey || entry.dataKey || 'value'}`;
          const itemConfig = getPayloadConfigFromPayload(config, entry, key);

          return (
            <div
              key={entry.value}
              className={cn(
                'flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground'
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: entry.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          );
        })}
      </div>
    );
  }
);
ChartLegendContent.displayName = 'ChartLegend';

function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: any,
  key: string
) {
  if (typeof payload !== 'object' || payload === null) {
    return undefined;
  }

  const payloadPayload =
    'payload' in payload &&
    typeof payload.payload === 'object' &&
    payload.payload !== null
      ? payload.payload
      : undefined;

  let configLabelKey: string = key;

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === 'string'
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string;
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === 'string'
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string;
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config];
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
};

================
File: components/ui/checkbox.tsx
================
'use client';

import * as React from 'react';
import * as CheckboxPrimitive from '@radix-ui/react-checkbox';
import { Check } from 'lucide-react';

import { cn } from '@/lib/utils';

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      'peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground',
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn('flex items-center justify-center text-current')}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };

================
File: components/ui/collapsible.tsx
================
'use client';

import * as CollapsiblePrimitive from '@radix-ui/react-collapsible';

const Collapsible = CollapsiblePrimitive.Root;

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger;

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent;

export { Collapsible, CollapsibleTrigger, CollapsibleContent };

================
File: components/ui/command.tsx
================
'use client';

import * as React from 'react';
import { type DialogProps } from '@radix-ui/react-dialog';
import { Command as CommandPrimitive } from 'cmdk';
import { Search } from 'lucide-react';

import { cn } from '@/lib/utils';
import { Dialog, DialogContent } from '@/components/ui/dialog';

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      'flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground',
      className
    )}
    {...props}
  />
));
Command.displayName = CommandPrimitive.displayName;

interface CommandDialogProps extends DialogProps {}

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
};

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        'flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50',
        className
      )}
      {...props}
    />
  </div>
));

CommandInput.displayName = CommandPrimitive.Input.displayName;

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn('max-h-[300px] overflow-y-auto overflow-x-hidden', className)}
    {...props}
  />
));

CommandList.displayName = CommandPrimitive.List.displayName;

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
));

CommandEmpty.displayName = CommandPrimitive.Empty.displayName;

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      'overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground',
      className
    )}
    {...props}
  />
));

CommandGroup.displayName = CommandPrimitive.Group.displayName;

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 h-px bg-border', className)}
    {...props}
  />
));
CommandSeparator.displayName = CommandPrimitive.Separator.displayName;

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50",
      className
    )}
    {...props}
  />
));

CommandItem.displayName = CommandPrimitive.Item.displayName;

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        'ml-auto text-xs tracking-widest text-muted-foreground',
        className
      )}
      {...props}
    />
  );
};
CommandShortcut.displayName = 'CommandShortcut';

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
};

================
File: components/ui/context-menu.tsx
================
'use client';

import * as React from 'react';
import * as ContextMenuPrimitive from '@radix-ui/react-context-menu';
import { Check, ChevronRight, Circle } from 'lucide-react';

import { cn } from '@/lib/utils';

const ContextMenu = ContextMenuPrimitive.Root;

const ContextMenuTrigger = ContextMenuPrimitive.Trigger;

const ContextMenuGroup = ContextMenuPrimitive.Group;

const ContextMenuPortal = ContextMenuPrimitive.Portal;

const ContextMenuSub = ContextMenuPrimitive.Sub;

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup;

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      'flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground',
      inset && 'pl-8',
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
));
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName;

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className
    )}
    {...props}
  />
));
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName;

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
));
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName;

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
));
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName;

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
));
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName;

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
));
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName;

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      'px-2 py-1.5 text-sm font-semibold text-foreground',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
));
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName;

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-border', className)}
    {...props}
  />
));
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName;

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        'ml-auto text-xs tracking-widest text-muted-foreground',
        className
      )}
      {...props}
    />
  );
};
ContextMenuShortcut.displayName = 'ContextMenuShortcut';

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
};

================
File: components/ui/dialog.tsx
================
'use client';

import * as React from 'react';
import * as DialogPrimitive from '@radix-ui/react-dialog';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      'fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        'fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg',
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col space-y-1.5 text-center sm:text-left',
      className
    )}
    {...props}
  />
);
DialogHeader.displayName = 'DialogHeader';

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className
    )}
    {...props}
  />
);
DialogFooter.displayName = 'DialogFooter';

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      'text-lg font-semibold leading-none tracking-tight',
      className
    )}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};

================
File: components/ui/drawer.tsx
================
'use client';

import * as React from 'react';
import { Drawer as DrawerPrimitive } from 'vaul';

import { cn } from '@/lib/utils';

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
);
Drawer.displayName = 'Drawer';

const DrawerTrigger = DrawerPrimitive.Trigger;

const DrawerPortal = DrawerPrimitive.Portal;

const DrawerClose = DrawerPrimitive.Close;

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn('fixed inset-0 z-50 bg-black/80', className)}
    {...props}
  />
));
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName;

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        'fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background',
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
));
DrawerContent.displayName = 'DrawerContent';

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn('grid gap-1.5 p-4 text-center sm:text-left', className)}
    {...props}
  />
);
DrawerHeader.displayName = 'DrawerHeader';

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn('mt-auto flex flex-col gap-2 p-4', className)}
    {...props}
  />
);
DrawerFooter.displayName = 'DrawerFooter';

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      'text-lg font-semibold leading-none tracking-tight',
      className
    )}
    {...props}
  />
));
DrawerTitle.displayName = DrawerPrimitive.Title.displayName;

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
DrawerDescription.displayName = DrawerPrimitive.Description.displayName;

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
};

================
File: components/ui/dropdown-menu.tsx
================
'use client';

import * as React from 'react';
import * as DropdownMenuPrimitive from '@radix-ui/react-dropdown-menu';
import { Check, ChevronRight, Circle } from 'lucide-react';

import { cn } from '@/lib/utils';

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      'flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent',
      inset && 'pl-8',
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      'px-2 py-1.5 text-sm font-semibold',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn('ml-auto text-xs tracking-widest opacity-60', className)}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = 'DropdownMenuShortcut';

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};

================
File: components/ui/form.tsx
================
'use client';

import * as React from 'react';
import * as LabelPrimitive from '@radix-ui/react-label';
import { Slot } from '@radix-ui/react-slot';
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from 'react-hook-form';

import { cn } from '@/lib/utils';
import { Label } from '@/components/ui/label';

const Form = FormProvider;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();

  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error('useFormField should be used within <FormField>');
  }

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
);

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId();

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn('space-y-2', className)} {...props} />
    </FormItemContext.Provider>
  );
});
FormItem.displayName = 'FormItem';

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();

  return (
    <Label
      ref={ref}
      className={cn(error && 'text-destructive', className)}
      htmlFor={formItemId}
      {...props}
    />
  );
});
FormLabel.displayName = 'FormLabel';

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } =
    useFormField();

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  );
});
FormControl.displayName = 'FormControl';

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn('text-sm text-muted-foreground', className)}
      {...props}
    />
  );
});
FormDescription.displayName = 'FormDescription';

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message) : children;

  if (!body) {
    return null;
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn('text-sm font-medium text-destructive', className)}
      {...props}
    >
      {body}
    </p>
  );
});
FormMessage.displayName = 'FormMessage';

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
};

================
File: components/ui/hover-card.tsx
================
'use client';

import * as React from 'react';
import * as HoverCardPrimitive from '@radix-ui/react-hover-card';

import { cn } from '@/lib/utils';

const HoverCard = HoverCardPrimitive.Root;

const HoverCardTrigger = HoverCardPrimitive.Trigger;

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = 'center', sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      'z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className
    )}
    {...props}
  />
));
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName;

export { HoverCard, HoverCardTrigger, HoverCardContent };

================
File: components/ui/input-otp.tsx
================
'use client';

import * as React from 'react';
import { OTPInput, OTPInputContext } from 'input-otp';
import { Dot } from 'lucide-react';

import { cn } from '@/lib/utils';

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      'flex items-center gap-2 has-[:disabled]:opacity-50',
      containerClassName
    )}
    className={cn('disabled:cursor-not-allowed', className)}
    {...props}
  />
));
InputOTP.displayName = 'InputOTP';

const InputOTPGroup = React.forwardRef<
  React.ElementRef<'div'>,
  React.ComponentPropsWithoutRef<'div'>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn('flex items-center', className)} {...props} />
));
InputOTPGroup.displayName = 'InputOTPGroup';

const InputOTPSlot = React.forwardRef<
  React.ElementRef<'div'>,
  React.ComponentPropsWithoutRef<'div'> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext);
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index];

  return (
    <div
      ref={ref}
      className={cn(
        'relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md',
        isActive && 'z-10 ring-2 ring-ring ring-offset-background',
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="h-4 w-px animate-caret-blink bg-foreground duration-1000" />
        </div>
      )}
    </div>
  );
});
InputOTPSlot.displayName = 'InputOTPSlot';

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<'div'>,
  React.ComponentPropsWithoutRef<'div'>
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
));
InputOTPSeparator.displayName = 'InputOTPSeparator';

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator };

================
File: components/ui/input.tsx
================
import * as React from 'react';

import { cn } from '@/lib/utils';

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          'flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);
Input.displayName = 'Input';

export { Input };

================
File: components/ui/label.tsx
================
'use client';

import * as React from 'react';
import * as LabelPrimitive from '@radix-ui/react-label';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const labelVariants = cva(
  'text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70'
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

================
File: components/ui/menubar.tsx
================
'use client';

import * as React from 'react';
import * as MenubarPrimitive from '@radix-ui/react-menubar';
import { Check, ChevronRight, Circle } from 'lucide-react';

import { cn } from '@/lib/utils';

const MenubarMenu = MenubarPrimitive.Menu;

const MenubarGroup = MenubarPrimitive.Group;

const MenubarPortal = MenubarPrimitive.Portal;

const MenubarSub = MenubarPrimitive.Sub;

const MenubarRadioGroup = MenubarPrimitive.RadioGroup;

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      'flex h-10 items-center space-x-1 rounded-md border bg-background p-1',
      className
    )}
    {...props}
  />
));
Menubar.displayName = MenubarPrimitive.Root.displayName;

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      'flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground',
      className
    )}
    {...props}
  />
));
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName;

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      'flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground',
      inset && 'pl-8',
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
));
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName;

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className
    )}
    {...props}
  />
));
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName;

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = 'start', alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          'z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
);
MenubarContent.displayName = MenubarPrimitive.Content.displayName;

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
));
MenubarItem.displayName = MenubarPrimitive.Item.displayName;

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
));
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName;

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
));
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName;

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      'px-2 py-1.5 text-sm font-semibold',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
));
MenubarLabel.displayName = MenubarPrimitive.Label.displayName;

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
));
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName;

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        'ml-auto text-xs tracking-widest text-muted-foreground',
        className
      )}
      {...props}
    />
  );
};
MenubarShortcut.displayname = 'MenubarShortcut';

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
};

================
File: components/ui/navigation-menu.tsx
================
import * as React from 'react';
import * as NavigationMenuPrimitive from '@radix-ui/react-navigation-menu';
import { cva } from 'class-variance-authority';
import { ChevronDown } from 'lucide-react';

import { cn } from '@/lib/utils';

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      'relative z-10 flex max-w-max flex-1 items-center justify-center',
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
));
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName;

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      'group flex flex-1 list-none items-center justify-center space-x-1',
      className
    )}
    {...props}
  />
));
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName;

const NavigationMenuItem = NavigationMenuPrimitive.Item;

const navigationMenuTriggerStyle = cva(
  'group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50'
);

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), 'group', className)}
    {...props}
  >
    {children}{' '}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
));
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName;

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      'left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ',
      className
    )}
    {...props}
  />
));
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName;

const NavigationMenuLink = NavigationMenuPrimitive.Link;

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn('absolute left-0 top-full flex justify-center')}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        'origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]',
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
));
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName;

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      'top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in',
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
));
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName;

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
};

================
File: components/ui/pagination.tsx
================
import * as React from 'react';
import { ChevronLeft, ChevronRight, MoreHorizontal } from 'lucide-react';

import { cn } from '@/lib/utils';
import { ButtonProps, buttonVariants } from '@/components/ui/button';

const Pagination = ({ className, ...props }: React.ComponentProps<'nav'>) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn('mx-auto flex w-full justify-center', className)}
    {...props}
  />
);
Pagination.displayName = 'Pagination';

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<'ul'>
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn('flex flex-row items-center gap-1', className)}
    {...props}
  />
));
PaginationContent.displayName = 'PaginationContent';

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<'li'>
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn('', className)} {...props} />
));
PaginationItem.displayName = 'PaginationItem';

type PaginationLinkProps = {
  isActive?: boolean;
} & Pick<ButtonProps, 'size'> &
  React.ComponentProps<'a'>;

const PaginationLink = ({
  className,
  isActive,
  size = 'icon',
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? 'page' : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? 'outline' : 'ghost',
        size,
      }),
      className
    )}
    {...props}
  />
);
PaginationLink.displayName = 'PaginationLink';

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn('gap-1 pl-2.5', className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
);
PaginationPrevious.displayName = 'PaginationPrevious';

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn('gap-1 pr-2.5', className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
);
PaginationNext.displayName = 'PaginationNext';

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<'span'>) => (
  <span
    aria-hidden
    className={cn('flex h-9 w-9 items-center justify-center', className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
);
PaginationEllipsis.displayName = 'PaginationEllipsis';

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
};

================
File: components/ui/popover.tsx
================
'use client';

import * as React from 'react';
import * as PopoverPrimitive from '@radix-ui/react-popover';

import { cn } from '@/lib/utils';

const Popover = PopoverPrimitive.Root;

const PopoverTrigger = PopoverPrimitive.Trigger;

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = 'center', sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        'z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
));
PopoverContent.displayName = PopoverPrimitive.Content.displayName;

export { Popover, PopoverTrigger, PopoverContent };

================
File: components/ui/progress.tsx
================
'use client';

import * as React from 'react';
import * as ProgressPrimitive from '@radix-ui/react-progress';

import { cn } from '@/lib/utils';

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      'relative h-4 w-full overflow-hidden rounded-full bg-secondary',
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
));
Progress.displayName = ProgressPrimitive.Root.displayName;

export { Progress };

================
File: components/ui/radio-group.tsx
================
'use client';

import * as React from 'react';
import * as RadioGroupPrimitive from '@radix-ui/react-radio-group';
import { Circle } from 'lucide-react';

import { cn } from '@/lib/utils';

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn('grid gap-2', className)}
      {...props}
      ref={ref}
    />
  );
});
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName;

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        'aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  );
});
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName;

export { RadioGroup, RadioGroupItem };

================
File: components/ui/resizable.tsx
================
'use client';

import { GripVertical } from 'lucide-react';
import * as ResizablePrimitive from 'react-resizable-panels';

import { cn } from '@/lib/utils';

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      'flex h-full w-full data-[panel-group-direction=vertical]:flex-col',
      className
    )}
    {...props}
  />
);

const ResizablePanel = ResizablePrimitive.Panel;

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean;
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      'relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90',
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
);

export { ResizablePanelGroup, ResizablePanel, ResizableHandle };

================
File: components/ui/scroll-area.tsx
================
'use client';

import * as React from 'react';
import * as ScrollAreaPrimitive from '@radix-ui/react-scroll-area';

import { cn } from '@/lib/utils';

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn('relative overflow-hidden', className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
));
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName;

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = 'vertical', ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      'flex touch-none select-none transition-colors',
      orientation === 'vertical' &&
        'h-full w-2.5 border-l border-l-transparent p-[1px]',
      orientation === 'horizontal' &&
        'h-2.5 flex-col border-t border-t-transparent p-[1px]',
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
));
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName;

export { ScrollArea, ScrollBar };

================
File: components/ui/select.tsx
================
'use client';

import * as React from 'react';
import * as SelectPrimitive from '@radix-ui/react-select';
import { Check, ChevronDown, ChevronUp } from 'lucide-react';

import { cn } from '@/lib/utils';

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      'flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1',
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      'flex cursor-default items-center justify-center py-1',
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      'flex cursor-default items-center justify-center py-1',
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = 'popper', ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        'relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        position === 'popper' &&
          'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          'p-1',
          position === 'popper' &&
            'h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]'
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn('py-1.5 pl-8 pr-2 text-sm font-semibold', className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
};

================
File: components/ui/separator.tsx
================
'use client';

import * as React from 'react';
import * as SeparatorPrimitive from '@radix-ui/react-separator';

import { cn } from '@/lib/utils';

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = 'horizontal', decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        'shrink-0 bg-border',
        orientation === 'horizontal' ? 'h-[1px] w-full' : 'h-full w-[1px]',
        className
      )}
      {...props}
    />
  )
);
Separator.displayName = SeparatorPrimitive.Root.displayName;

export { Separator };

================
File: components/ui/sheet.tsx
================
'use client';

import * as React from 'react';
import * as SheetPrimitive from '@radix-ui/react-dialog';
import { cva, type VariantProps } from 'class-variance-authority';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const Sheet = SheetPrimitive.Root;

const SheetTrigger = SheetPrimitive.Trigger;

const SheetClose = SheetPrimitive.Close;

const SheetPortal = SheetPrimitive.Portal;

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      'fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className
    )}
    {...props}
    ref={ref}
  />
));
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName;

const sheetVariants = cva(
  'fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500',
  {
    variants: {
      side: {
        top: 'inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top',
        bottom:
          'inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom',
        left: 'inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm',
        right:
          'inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm',
      },
    },
    defaultVariants: {
      side: 'right',
    },
  }
);

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = 'right', className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
));
SheetContent.displayName = SheetPrimitive.Content.displayName;

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col space-y-2 text-center sm:text-left',
      className
    )}
    {...props}
  />
);
SheetHeader.displayName = 'SheetHeader';

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className
    )}
    {...props}
  />
);
SheetFooter.displayName = 'SheetFooter';

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn('text-lg font-semibold text-foreground', className)}
    {...props}
  />
));
SheetTitle.displayName = SheetPrimitive.Title.displayName;

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
SheetDescription.displayName = SheetPrimitive.Description.displayName;

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
};

================
File: components/ui/skeleton.tsx
================
import { cn } from '@/lib/utils';

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn('animate-pulse rounded-md bg-muted', className)}
      {...props}
    />
  );
}

export { Skeleton };

================
File: components/ui/slider.tsx
================
'use client';

import * as React from 'react';
import * as SliderPrimitive from '@radix-ui/react-slider';

import { cn } from '@/lib/utils';

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      'relative flex w-full touch-none select-none items-center',
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
));
Slider.displayName = SliderPrimitive.Root.displayName;

export { Slider };

================
File: components/ui/sonner.tsx
================
'use client';

import { useTheme } from 'next-themes';
import { Toaster as Sonner } from 'sonner';

type ToasterProps = React.ComponentProps<typeof Sonner>;

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = 'system' } = useTheme();

  return (
    <Sonner
      theme={theme as ToasterProps['theme']}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            'group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg',
          description: 'group-[.toast]:text-muted-foreground',
          actionButton:
            'group-[.toast]:bg-primary group-[.toast]:text-primary-foreground',
          cancelButton:
            'group-[.toast]:bg-muted group-[.toast]:text-muted-foreground',
        },
      }}
      {...props}
    />
  );
};

export { Toaster };

================
File: components/ui/switch.tsx
================
'use client';

import * as React from 'react';
import * as SwitchPrimitives from '@radix-ui/react-switch';

import { cn } from '@/lib/utils';

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      'peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input',
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        'pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0'
      )}
    />
  </SwitchPrimitives.Root>
));
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };

================
File: components/ui/table.tsx
================
import * as React from 'react';

import { cn } from '@/lib/utils';

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn('w-full caption-bottom text-sm', className)}
      {...props}
    />
  </div>
));
Table.displayName = 'Table';

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn('[&_tr]:border-b', className)} {...props} />
));
TableHeader.displayName = 'TableHeader';

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn('[&_tr:last-child]:border-0', className)}
    {...props}
  />
));
TableBody.displayName = 'TableBody';

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      'border-t bg-muted/50 font-medium [&>tr]:last:border-b-0',
      className
    )}
    {...props}
  />
));
TableFooter.displayName = 'TableFooter';

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      'border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted',
      className
    )}
    {...props}
  />
));
TableRow.displayName = 'TableRow';

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      'h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0',
      className
    )}
    {...props}
  />
));
TableHead.displayName = 'TableHead';

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn('p-4 align-middle [&:has([role=checkbox])]:pr-0', className)}
    {...props}
  />
));
TableCell.displayName = 'TableCell';

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn('mt-4 text-sm text-muted-foreground', className)}
    {...props}
  />
));
TableCaption.displayName = 'TableCaption';

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
};

================
File: components/ui/tabs.tsx
================
'use client';

import * as React from 'react';
import * as TabsPrimitive from '@radix-ui/react-tabs';

import { cn } from '@/lib/utils';

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      'inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground',
      className
    )}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      'inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm',
      className
    )}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      'mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2',
      className
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };

================
File: components/ui/textarea.tsx
================
import * as React from 'react';

import { cn } from '@/lib/utils';

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          'flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);
Textarea.displayName = 'Textarea';

export { Textarea };

================
File: components/ui/toast.tsx
================
'use client';

import * as React from 'react';
import * as ToastPrimitives from '@radix-ui/react-toast';
import { cva, type VariantProps } from 'class-variance-authority';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      'fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]',
      className
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  'group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full',
  {
    variants: {
      variant: {
        default: 'border bg-background text-foreground',
        destructive:
          'destructive group border-destructive bg-destructive text-destructive-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      'inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive',
      className
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      'absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600',
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn('text-sm font-semibold', className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn('text-sm opacity-90', className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};

================
File: components/ui/toaster.tsx
================
'use client';

import { useToast } from '@/hooks/use-toast';
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from '@/components/ui/toast';

export function Toaster() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}

================
File: components/ui/toggle-group.tsx
================
'use client';

import * as React from 'react';
import * as ToggleGroupPrimitive from '@radix-ui/react-toggle-group';
import { type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';
import { toggleVariants } from '@/components/ui/toggle';

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: 'default',
  variant: 'default',
});

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn('flex items-center justify-center gap-1', className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
));

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName;

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext);

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  );
});

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName;

export { ToggleGroup, ToggleGroupItem };

================
File: components/ui/toggle.tsx
================
'use client';

import * as React from 'react';
import * as TogglePrimitive from '@radix-ui/react-toggle';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const toggleVariants = cva(
  'inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground',
  {
    variants: {
      variant: {
        default: 'bg-transparent',
        outline:
          'border border-input bg-transparent hover:bg-accent hover:text-accent-foreground',
      },
      size: {
        default: 'h-10 px-3',
        sm: 'h-9 px-2.5',
        lg: 'h-11 px-5',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
));

Toggle.displayName = TogglePrimitive.Root.displayName;

export { Toggle, toggleVariants };

================
File: components/ui/tooltip.tsx
================
'use client';

import * as React from 'react';
import * as TooltipPrimitive from '@radix-ui/react-tooltip';

import { cn } from '@/lib/utils';

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      'z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };

================
File: components/DeckLabelInput.tsx
================
import { useState } from 'react';
import { Badge } from './ui/badge';
import { Input } from './ui/input';
import { X } from 'lucide-react';

interface DeckLabelInputProps {
  labels: string[];
  onLabelsChange: (labels: string[]) => void;
}

export function DeckLabelInput({ labels, onLabelsChange }: DeckLabelInputProps) {
  const [input, setInput] = useState('');

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && input.trim()) {
      e.preventDefault();
      const newLabel = input.trim();
      if (!labels.includes(newLabel)) {
        onLabelsChange([...labels, newLabel]);
        setInput('');
      }
    }
  };

  const removeLabel = (labelToRemove: string) => {
    onLabelsChange(labels.filter(label => label !== labelToRemove));
  };

  return (
    <div className="space-y-2">
      <div className="flex flex-wrap gap-2">
        {labels.map(label => (
          <Badge
            key={label}
            variant="secondary"
            className="px-2 py-1 flex items-center gap-1"
          >
            {label}
            <X
              className="h-3 w-3 cursor-pointer"
              onClick={() => removeLabel(label)}
              data-testid={`remove-label-${label}`}
            />
          </Badge>
        ))}
      </div>
      <div className="flex gap-2">
        <Input
          placeholder="Add label (press Enter)"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={handleKeyDown}
          className="dark:bg-white/5 dark:border-white/10"
        />
      </div>
    </div>
  );
}

================
File: components/Flashcard.tsx
================
// components/Flashcard.tsx
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { Card } from "@/components/ui/card";
import { cn } from '@/lib/utils';

interface FlashcardProps {
  front: string;
  back: string;
  className?: string;
}

const Flashcard: React.FC<FlashcardProps> = ({
  front,
  back,
  className
}) => {
  const [isFlipped, setIsFlipped] = useState(false);

  const handleFlip = () => setIsFlipped(!isFlipped);

  return (
    <Card 
      className={cn(
        "relative dark:glass-card bg-white dark:border-white/5 overflow-hidden cursor-pointer min-h-[400px]",
        className
      )}
      onClick={handleFlip}
    >
      <div className="absolute inset-0 p-8 flex items-center justify-center">
        <motion.div
          className="w-full text-center"
          initial={false}
          animate={{ rotateX: isFlipped ? 180 : 0 }}
          transition={{ duration: 0.6, type: "spring" }}
          style={{ transformStyle: "preserve-3d" }}
        >
          <div className={`${isFlipped ? 'opacity-0' : 'opacity-100'} transition-opacity duration-300`}>
            <h3 className="text-xl text-neutral-600 dark:text-neutral-400 mb-4">Front</h3>
            <p className="text-2xl font-light dark:text-white">{front}</p>
          </div>
          <div 
            className={`${isFlipped ? 'opacity-100' : 'opacity-0'} absolute inset-0 flex items-center justify-center transition-opacity duration-300`}
            style={{ transform: "rotateX(180deg)" }}
          >
            <div>
              <h3 className="text-xl text-neutral-600 dark:text-neutral-400 mb-4">Back</h3>
              <p className="text-2xl font-light dark:text-white">{back}</p>
            </div>
          </div>
        </motion.div>
      </div>
    </Card>
  );
};

export default Flashcard;

================
File: components/FlipCard.tsx
================
import React, { useState } from 'react';
import { motion } from 'framer-motion';

interface FlipCardProps {
  front: string;
  back: string;
}

const FlipCard: React.FC<FlipCardProps> = ({ front, back }) => {
  const [isFlipped, setIsFlipped] = useState(false);

  return (
    <div 
      className="w-full h-64 cursor-pointer"
      onClick={() => setIsFlipped(!isFlipped)}
      style={{ perspective: '1000px' }}
    >
      <motion.div
        animate={{ rotateY: isFlipped ? 180 : 0 }}
        transition={{ duration: 0.5 }}
        style={{ width: '100%', height: '100%', transformStyle: 'preserve-3d' }}
      >
        <motion.div
          className="absolute w-full h-full bg-white rounded-lg shadow-lg flex items-center justify-center p-6"
          style={{ backfaceVisibility: 'hidden' }}
        >
          <p className="text-xl font-semibold text-center">{front}</p>
        </motion.div>
        <motion.div
          className="absolute w-full h-full bg-blue-100 rounded-lg shadow-lg flex items-center justify-center p-6"
          style={{ backfaceVisibility: 'hidden', rotateY: 180 }}
        >
          <p className="text-xl font-semibold text-center">{back}</p>
        </motion.div>
      </motion.div>
    </div>
  );
};

export default FlipCard;

================
File: components/mode-toggle.tsx
================
"use client"

import * as React from "react"
import { Moon, Sun } from "lucide-react"
import { useTheme } from "next-themes"

import { Button } from "@/components/ui/button"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"

export function ModeToggle() {
  const { setTheme } = useTheme()

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon">
          <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>
          Light
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>
          Dark
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>
          System
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}

================
File: components/Navbar.tsx
================
'use client'

import Link from 'next/link'
import { usePathname, useRouter } from 'next/navigation'
import { signIn, signOut, useSession } from 'next-auth/react'
import { Button } from '@/components/ui/button'
import { ModeToggle } from '@/components/mode-toggle'
import { Menu, X, BookOpen, LayoutDashboard, RefreshCw, ShoppingBag } from 'lucide-react'
import { useState } from 'react'
import { motion, AnimatePresence } from 'framer-motion'

const Navbar = () => {
  const pathname = usePathname()
  const { data: session, status } = useSession()
  const [isMenuOpen, setIsMenuOpen] = useState(false)
  const router = useRouter()

  const handleSignOut = async () => {
    await signOut({ 
      callbackUrl: "/",
      redirect: true
    })
  }

  const NavLink = ({ 
    href, 
    children, 
    icon: Icon 
  }: { 
    href: string; 
    children: React.ReactNode;
    icon: React.ElementType;
  }) => {
    const isActive = pathname === href
    
    return (
      <button
        onClick={() => router.push(href)}
        className={`flex items-center space-x-2 px-4 py-2 rounded-lg transition-all duration-200 ${
          isActive 
            ? 'dark:bg-white/10 dark:text-white bg-neutral-100 text-neutral-900' 
            : 'text-neutral-600 dark:text-neutral-300 hover:bg-neutral-50 dark:hover:bg-white/5'
        }`}
      >
        <Icon size={18} />
        <span className="font-light">{children}</span>
      </button>
    )
  }

  return (
    <nav className="fixed top-0 w-full dark:nav-blur bg-[#F5F2EA]/90 backdrop-blur-sm border-b border-neutral-200 dark:border-white/5 z-50">
      <div className="container mx-auto px-4 py-4">
        <div className="flex items-center justify-between">
          <Link href="/" className="flex items-center space-x-2">
            <span className="text-2xl font-light tracking-wider text-neutral-800 dark:text-white">
              cervello<span className="text-neutral-400 dark:text-neutral-500">flashcards</span>
            </span>
          </Link>

          <div className="hidden md:flex items-center space-x-2">
            {status === 'authenticated' && (
              <div className="flex items-center mr-4 bg-white dark:glass-card rounded-lg shadow-sm">
                <NavLink href="/dashboard" icon={LayoutDashboard}>Dashboard</NavLink>
                <NavLink href="/decks" icon={BookOpen}>Collections</NavLink>
                <NavLink href="/marketplace" icon={ShoppingBag}>Marketplace</NavLink>
                <NavLink href="/review" icon={RefreshCw}>Review</NavLink>
              </div>
            )}
            <div className="flex items-center space-x-3">
              <ModeToggle />
              {status === 'authenticated' ? (
                <Button 
                  onClick={handleSignOut}
                  variant="outline"
                  className="border-neutral-300 hover:border-neutral-400 dark:border-neutral-700 dark:hover:border-neutral-600 dark:text-white"
                >
                  Sign Out
                </Button>
              ) : (
                <Button
                  onClick={() => signIn('google')}
                  className="dark:bg-white dark:text-black dark:hover:bg-neutral-200 bg-neutral-900 text-white hover:bg-neutral-800"
                >
                  Sign In
                </Button>
              )}
            </div>
          </div>

          <button 
            onClick={() => setIsMenuOpen(!isMenuOpen)}
            className="md:hidden p-2 rounded-lg text-neutral-600 dark:text-neutral-300 hover:bg-neutral-100 dark:hover:bg-white/5"
          >
            {isMenuOpen ? <X size={24} /> : <Menu size={24} />}
          </button>
        </div>

        <AnimatePresence>
          {isMenuOpen && (
            <motion.div
              initial={{ opacity: 0, height: 0 }}
              animate={{ opacity: 1, height: 'auto' }}
              exit={{ opacity: 0, height: 0 }}
              className="md:hidden border-t border-neutral-200 dark:border-white/5 mt-4"
            >
              <div className="py-4 flex flex-col space-y-2">
                {status === 'authenticated' && (
                  <>
                    <NavLink href="/dashboard" icon={LayoutDashboard}>Dashboard</NavLink>
                    <NavLink href="/decks" icon={BookOpen}>Collections</NavLink>
                    <NavLink href="/review" icon={RefreshCw}>Review</NavLink>
                  </>
                )}
                <div className="flex items-center space-x-3 px-4 pt-4">
                  <ModeToggle />
                  {status === 'authenticated' ? (
                    <Button 
                      onClick={handleSignOut}
                      variant="outline"
                      className="border-neutral-300 hover:border-neutral-400 dark:border-neutral-700 dark:hover:border-neutral-600 dark:text-white"
                    >
                      Sign Out
                    </Button>
                  ) : (
                    <Button
                      onClick={() => signIn('google')}
                      className="dark:bg-white dark:text-black dark:hover:bg-neutral-200 bg-neutral-900 text-white hover:bg-neutral-800"
                    >
                      Sign In
                    </Button>
                  )}
                </div>
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    </nav>
  )
}

export default Navbar

================
File: components/SessionProvider.tsx
================
'use client'

import { SessionProvider as NextAuthSessionProvider } from "next-auth/react"

type Props = {
  children: React.ReactNode
}

export function SessionProvider({ children }: Props) {
  return <NextAuthSessionProvider>{children}</NextAuthSessionProvider>
}

================
File: components/SignInButton.tsx
================
'use client'

import { signIn } from 'next-auth/react'
import { Button } from '@/components/ui/button'

interface SignInButtonProps {
  className?: string;
}

export function SignInButton({ className }: SignInButtonProps) {
  return (
    <Button 
      onClick={() => signIn('google', { callbackUrl: '/decks' })}
      className={className}
    >
      Sign in with Google
    </Button>
  )
}

================
File: components/theme-provider.tsx
================
"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
import { type ThemeProviderProps } from "next-themes/dist/types"

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}

================
File: components/TranslationFlashcardDialog.tsx
================
'use client';

import { useState, useEffect, useCallback } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from './ui/dialog';
import { Button } from './ui/button';
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from '@/components/ui/form';
import { Input } from './ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from './ui/select';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { useToast } from "@/hooks/use-toast";
import { Loader2, AlertCircle } from 'lucide-react';
import { languageMapping } from '@/lib/huggingface';
import {
  Alert,
  AlertDescription,
  AlertTitle,
} from "@/components/ui/alert";
import { cn } from '@/lib/utils';
import { useForm } from 'react-hook-form';

const formSchema = z.object({
  text: z.string().min(1, "Text is required").max(500, "Text too long"),
  sourceLang: z.string().min(1, "Source language is required"),
  targetLang: z.string().min(1, "Target language is required")
});

type FormData = z.infer<typeof formSchema>;

interface TranslationFlashcardDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  deckId: string;
  onFlashcardCreated: () => void;
}

const formatResetTime = (resetIn: number): string => {
  const minutes = Math.ceil(resetIn / 60000);
  if (minutes < 60) return `${minutes} minute${minutes === 1 ? '' : 's'}`;
  const hours = Math.ceil(minutes / 60);
  return `${hours} hour${hours === 1 ? '' : 's'}`;
};

const RemainingTranslations = ({ count }: { count: number | null }) => {
  // Changed to return a loading indicator when null
  if (count === null) {
    return (
      <div className="flex items-center gap-2 text-sm text-muted-foreground">
        <Loader2 className="h-4 w-4 animate-spin" />
        <span>Loading translation quota...</span>
      </div>
    );
  }

  return (
    <div className="inline-flex items-center text-sm text-muted-foreground">
      <div className="flex items-center gap-1.5">
        {count > 0 ? (
          <span className="text-xs font-medium bg-blue-500/10 dark:bg-blue-500/20 text-blue-600 dark:text-blue-400 px-2 py-0.5 rounded-full">
            {count} translation{count === 1 ? '' : 's'} remaining
          </span>
        ) : (
          <span className="text-xs font-medium bg-red-500/10 dark:bg-red-500/20 text-red-600 dark:text-red-400 px-2 py-0.5 rounded-full">
            No translations remaining
          </span>
        )}
      </div>
    </div>
  );
};

export default function TranslationFlashcardDialog({
  open,
  onOpenChange,
  deckId,
  onFlashcardCreated
}: TranslationFlashcardDialogProps) {
  const [isLoading, setIsLoading] = useState(false);
  const [remainingTranslations, setRemainingTranslations] = useState<number | null>(null);
  const [rateLimitError, setRateLimitError] = useState<string | null>(null);
  const [resetTime, setResetTime] = useState<number | null>(null);
  const { toast } = useToast();

  const form = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      text: '',
      sourceLang: 'en',
      targetLang: 'de'
    }
  });

  const fetchRemainingTranslations = useCallback(async () => {
    if (!open) return; // Only fetch if dialog is open

    try {
      const response = await fetch('/api/translate');
      if (!response.ok) throw new Error('Failed to fetch translation limit');
      
      const data = await response.json();
      setRemainingTranslations(data.remaining);

      if (data.isLimited) {
        setRateLimitError(data.message);
        setResetTime(data.resetIn);
      } else {
        setRateLimitError(null);
        setResetTime(null);
      }
    } catch (error) {
      console.error('Error fetching translation quota:', error);
      toast({
        title: "Error",
        description: "Failed to check translation quota",
        variant: "destructive",
      });
      setRemainingTranslations(0); // Set to 0 on error to prevent perpetual loading
    }
  }, [open, toast]);

  useEffect(() => {
    if (open) {
      fetchRemainingTranslations();
      const intervalId = setInterval(fetchRemainingTranslations, 30000);
      return () => clearInterval(intervalId);
    }
  }, [open, fetchRemainingTranslations]);

  useEffect(() => {
    if (!open) {
      form.reset();
      setRateLimitError(null);
      setResetTime(null);
    }
  }, [open, form]);

  const onSubmit = async (values: FormData) => {
    setIsLoading(true);
    setRateLimitError(null);

    try {
      const translationResponse = await fetch('/api/translate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(values),
      });

      if (!translationResponse.ok) {
        const error = await translationResponse.json();
        if (translationResponse.status === 429) {
          setRateLimitError(error.message);
          setResetTime(error.resetIn);
          setRemainingTranslations(0);
          throw new Error(error.message);
        }
        throw new Error(error.error || 'Translation failed');
      }

      const { source, target, remaining } = await translationResponse.json();
      setRemainingTranslations(remaining);

      await createFlashcard(source, target);
      
      toast({
        title: "Success",
        description: "Translation flashcard created successfully",
      });

      form.reset();
      onFlashcardCreated();
      onOpenChange(false); // Close dialog on success
    } catch (error) {
      console.error('Error:', error);
      if (!rateLimitError) {
        toast({
          title: "Error",
          description: error instanceof Error ? error.message : 'Failed to create flashcard',
          variant: 'destructive',
        });
      }
    } finally {
      setIsLoading(false);
    }
  };

  const createFlashcard = async (source: string, target: string) => {
    const response = await fetch('/api/flashcards', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        deckId,
        front: source,
        back: target
      }),
    });

    if (!response.ok) {
      throw new Error('Failed to create flashcard');
    }

    return response.json();
  };

  const isDisabled = isLoading || remainingTranslations === 0;

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="dark:glass-card sm:max-w-[425px]">
        <DialogHeader>
          <div className="space-y-2">
            <DialogTitle className="text-xl font-light dark:text-white">
              Create Translation Flashcard
            </DialogTitle>
            <RemainingTranslations count={remainingTranslations} />
          </div>
        </DialogHeader>

        {rateLimitError && (
          <Alert variant="destructive" className="mb-4">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>Rate Limit Exceeded</AlertTitle>
            <AlertDescription className="mt-1">
              <p>{rateLimitError}</p>
              {resetTime && (
                <p className="mt-2 text-sm opacity-90">
                  Resets in: {formatResetTime(resetTime)}
                </p>
              )}
            </AlertDescription>
          </Alert>
        )}

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
            <FormField
              control={form.control}
              name="text"
              render={({ field }) => (
                <FormItem>
                  <FormLabel className="dark:text-neutral-200">Word or Phrase</FormLabel>
                  <FormControl>
                    <Input
                      placeholder="Enter word or phrase to translate"
                      className="dark:bg-white/5 dark:border-white/10 dark:text-white"
                      {...field}
                      disabled={isDisabled}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="sourceLang"
              render={({ field }) => (
                <FormItem>
                  <FormLabel className="dark:text-neutral-200">Source Language</FormLabel>
                  <Select
                    disabled={isDisabled}
                    onValueChange={field.onChange}
                    defaultValue={field.value}
                  >
                    <FormControl>
                      <SelectTrigger className="dark:bg-white/5 dark:border-white/10 dark:text-white">
                        <SelectValue placeholder="Select source language" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      {Object.entries(languageMapping).map(([code, name]) => (
                        <SelectItem key={code} value={code}>
                          {name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="targetLang"
              render={({ field }) => (
                <FormItem>
                  <FormLabel className="dark:text-neutral-200">Target Language</FormLabel>
                  <Select
                    disabled={isDisabled}
                    onValueChange={field.onChange}
                    defaultValue={field.value}
                  >
                    <FormControl>
                      <SelectTrigger className="dark:bg-white/5 dark:border-white/10 dark:text-white">
                        <SelectValue placeholder="Select target language" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      {Object.entries(languageMapping).map(([code, name]) => (
                        <SelectItem key={code} value={code}>
                          {name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />

            <Button
              type="submit"
              className={cn(
                "w-full transition-all",
                isDisabled
                  ? "dark:bg-neutral-800 dark:text-neutral-400"
                  : "dark:bg-white dark:text-black dark:hover:bg-neutral-200"
              )}
              disabled={isDisabled}
            >
              {isLoading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Creating Translation...
                </>
              ) : remainingTranslations === 0 ? (
                'No Translations Available'
              ) : (
                'Create Flashcard'
              )}
            </Button>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}

================
File: hooks/use-toast.ts
================
'use client';

import * as React from 'react';

import type { ToastActionElement, ToastProps } from '@/components/ui/toast';

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

const actionTypes = {
  ADD_TOAST: 'ADD_TOAST',
  UPDATE_TOAST: 'UPDATE_TOAST',
  DISMISS_TOAST: 'DISMISS_TOAST',
  REMOVE_TOAST: 'REMOVE_TOAST',
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType['ADD_TOAST'];
      toast: ToasterToast;
    }
  | {
      type: ActionType['UPDATE_TOAST'];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType['DISMISS_TOAST'];
      toastId?: ToasterToast['id'];
    }
  | {
      type: ActionType['REMOVE_TOAST'];
      toastId?: ToasterToast['id'];
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: 'REMOVE_TOAST',
      toastId: toastId,
    });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'ADD_TOAST':
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case 'UPDATE_TOAST':
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      };

    case 'DISMISS_TOAST': {
      const { toastId } = action;

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      };
    }
    case 'REMOVE_TOAST':
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      };
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}

type Toast = Omit<ToasterToast, 'id'>;

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: ToasterToast) =>
    dispatch({
      type: 'UPDATE_TOAST',
      toast: { ...props, id },
    });
  const dismiss = () => dispatch({ type: 'DISMISS_TOAST', toastId: id });

  dispatch({
    type: 'ADD_TOAST',
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      },
    },
  });

  return {
    id: id,
    dismiss,
    update,
  };
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: 'DISMISS_TOAST', toastId }),
  };
}

export { useToast, toast };

================
File: lib/auth.ts
================
import { NextAuthOptions } from "next-auth";
import GoogleProvider from "next-auth/providers/google";
import { DrizzleAdapter } from "@auth/drizzle-adapter";
import { getDb } from "./db";
import { user, account } from "./schema";
import { AdapterUser } from "next-auth/adapters";
import { eq } from "drizzle-orm";

interface UserData {
  name?: string | null;
  email?: string | null;
  emailVerified?: Date | null;
  image?: string | null;
}

interface AccountData {
  userId: string;
  type: string;
  provider: string;
  providerAccountId: string;
  refresh_token?: string | null;
  access_token?: string | null;
  expires_at?: number | null;
  token_type?: string | null;
  scope?: string | null;
  id_token?: string | null;
  session_state?: string | null;
}

declare module "next-auth" {
  interface Session {
    user: {
      id: string;
      email?: string | null;
      name?: string | null;
      image?: string | null;
    }
  }
}

export const authOptions: NextAuthOptions = {
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
      authorization: {
        params: {
          prompt: "select_account",
          access_type: "offline",
          response_type: "code"
        }
      },
    }),
  ],
  adapter: {
    ...DrizzleAdapter(await getDb()),
    async createUser(data: UserData) {
      const db = await getDb();
      try {
        if (data.email) {
          const existingUser = await db.select().from(user).where(eq(user.email, data.email)).get();
          if (existingUser) {
            return {
              id: existingUser.id,
              name: existingUser.name,
              email: existingUser.email,
              emailVerified: existingUser.emailVerified,
              image: existingUser.image
            } as AdapterUser;
          }
        }

        const newUser = {
          id: crypto.randomUUID(),
          name: data.name,
          email: data.email,
          emailVerified: data.emailVerified,
          image: data.image
        };

        await db.insert(user).values(newUser);
        return newUser as AdapterUser;
      } catch (error) {
        console.error("Error in createUser:", error);
        throw error;
      }
    },

    async linkAccount(data: AccountData) {
      const db = await getDb();
      try {
        const existingAccount = await db.select()
          .from(account)
          .where(eq(account.providerAccountId, data.providerAccountId))
          .get();

        if (existingAccount) {
          return;
        }

        const accountData = {
          id: crypto.randomUUID(),
          userId: data.userId,
          type: data.type,
          provider: data.provider,
          providerAccountId: data.providerAccountId,
          refresh_token: data.refresh_token,
          access_token: data.access_token,
          expires_at: data.expires_at,
          token_type: data.token_type,
          scope: data.scope,
          id_token: data.id_token,
          session_state: data.session_state
        };

        await db.insert(account).values(accountData);
      } catch (error) {
        console.error("Error in linkAccount:", error);
        throw error;
      }
    },

    async getUser(id: string) {
      const db = await getDb();
      try {
        const result = await db.select().from(user).where(eq(user.id, id)).get();
        return result as AdapterUser | null;
      } catch (error) {
        console.error("Error in getUser:", error);
        return null;
      }
    },

    async getUserByEmail(email: string) {
      const db = await getDb();
      try {
        const result = await db.select().from(user).where(eq(user.email, email)).get();
        return result as AdapterUser | null;
      } catch (error) {
        console.error("Error in getUserByEmail:", error);
        return null;
      }
    },

    async updateUser(data: Partial<AdapterUser> & { id: string }) {
      const db = await getDb();
      try {
        if (!data.id) throw new Error("User ID is required");
        await db.update(user)
          .set({
            name: data.name,
            email: data.email,
            image: data.image,
            emailVerified: data.emailVerified
          })
          .where(eq(user.id, data.id));
        
        const updatedUser = await db.select().from(user).where(eq(user.id, data.id)).get();
        if (!updatedUser) throw new Error("Failed to update user");
        return updatedUser as AdapterUser;
      } catch (error) {
        console.error("Error in updateUser:", error);
        throw error;
      }
    }
  },
  session: {
    strategy: "jwt",
    maxAge: 30 * 24 * 60 * 60,
  },
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id;
      }
      return token;
    },
    async session({ session, token }) {
      if (session?.user && token.sub) {
        session.user.id = token.sub;
      }
      return session;
    },
  },
  pages: {
    signIn: '/auth/signin',
    error: '/auth/error',
  },
  secret: process.env.NEXTAUTH_SECRET,
};

================
File: lib/db.ts
================
import { drizzle } from 'drizzle-orm/libsql';
import { and, eq, gte, lt, sql } from 'drizzle-orm';
import { createClient } from '@libsql/client';
import * as schema from './schema';
import { 
  user, deck, flashcard, studySession, reviewLog,
  type User, type Deck, type Flashcard, 
  type StudySession, type ReviewLog,
  type CardState,
  deckLabel,
  label,
  sharedDeck,
  deckRating
} from './schema';

const RETRY_ATTEMPTS = 3;
const RETRY_DELAY = 1000;

async function createDbClientWithRetry(attempt = 1) {
  try {
    const client = createClient({
      url: process.env.NEXT_PUBLIC_TURSO_DATABASE_URL!,
      authToken: process.env.NEXT_PUBLIC_TURSO_AUTH_TOKEN,
    });
    await client.execute('SELECT 1');
    return drizzle(client, { schema, logger: false });
  } catch (error) {
    if (attempt < RETRY_ATTEMPTS) {
      await new Promise(resolve => setTimeout(resolve, RETRY_DELAY * attempt));
      return createDbClientWithRetry(attempt + 1);
    }
    throw error;
  }
}

let dbInstance: ReturnType<typeof drizzle> | null = null;

export async function getDb() {
  if (typeof window !== 'undefined') {
    throw new Error('Cannot use database client in browser environment');
  }
  if (!dbInstance) {
    dbInstance = await createDbClientWithRetry();
  }
  return dbInstance;
}

export async function createDbClient() {
  return await createDbClientWithRetry();
}

export async function getDecks(userId: string) {
  try {
    const db = await getDb();
    
    // Join with deck_label and label tables to get labels
    const decksWithLabels = await db
      .select({
        id: deck.id,
        userId: deck.userId,
        title: deck.title,
        description: deck.description,
        createdAt: deck.createdAt,
        updatedAt: deck.updatedAt,
        originalSharedDeckId: deck.originalSharedDeckId,
        labels: sql<string[]>`JSON_GROUP_ARRAY(DISTINCT CASE WHEN ${label.name} IS NULL THEN NULL ELSE ${label.name} END)`
      })
      .from(deck)
      .leftJoin(deckLabel, eq(deck.id, deckLabel.deckId))
      .leftJoin(label, eq(deckLabel.labelId, label.id))
      .where(eq(deck.userId, userId))
      .groupBy(deck.id);

    return decksWithLabels.map(deck => ({
      ...deck,
      labels: deck.labels[0] === null ? [] 
        : Array.from(new Set(JSON.parse(deck.labels.toString())))
    }));
  } catch (error) {
    console.error('Error fetching decks:', error);
    throw error;
  }
}

export async function getDeck(id: string) {
  try {
    const db = await createDbClient();
    return await db.select().from(deck).where(eq(deck.id, id)).get();
  } catch (error) {
    console.error('Error fetching deck:', error);
    throw error;
  }
}

export async function createDeck(
  userId: string, 
  title: string, 
  description: string,
  labels: string[] = []
) {
  const db = await getDb();
  const now = Date.now();
  
  try {
    const deckId = crypto.randomUUID();
    
    await db.transaction(async (tx) => {
      // Create the deck
      await tx.insert(deck).values({
        id: deckId,
        userId,
        title,
        description,
        createdAt: now,
        updatedAt: now,
      });

      // Handle labels
      for (const labelName of labels) {
        // Create or get existing label
        let labelId = crypto.randomUUID();
        const existingLabel = await tx
          .select()
          .from(label)
          .where(eq(label.name, labelName))
          .get();

        if (existingLabel) {
          labelId = existingLabel.id;
        } else {
          await tx.insert(label).values({
            id: labelId,
            name: labelName,
            createdAt: now,
          });
        }

        // Create deck-label association
        await tx.insert(deckLabel).values({
          id: crypto.randomUUID(),
          deckId: deckId,
          labelId: labelId,
        });
      }
    });

    return await getDeck(deckId);
  } catch (error) {
    console.error('Error creating deck:', error);
    throw error;
  }
}

export async function updateDeck(
  id: string, 
  title: string, 
  description: string,
  labels: string[] = []
) {
  const db = await getDb();
  
  try {
    await db.transaction(async (tx) => {
      // Update deck details
      await tx.update(deck)
        .set({
          title,
          description,
          updatedAt: Date.now()
        })
        .where(eq(deck.id, id));

      // Remove existing labels
      await tx.delete(deckLabel)
        .where(eq(deckLabel.deckId, id));

      // Add new labels
      for (const labelName of labels) {
        // Create or get existing label
        let labelId = crypto.randomUUID();
        const existingLabel = await tx
          .select()
          .from(label)
          .where(eq(label.name, labelName))
          .get();

        if (existingLabel) {
          labelId = existingLabel.id;
        } else {
          await tx.insert(label).values({
            id: labelId,
            name: labelName,
            createdAt: Date.now(),
          });
        }

        // Create deck-label association
        await tx.insert(deckLabel).values({
          id: crypto.randomUUID(),
          deckId: id,
          labelId: labelId,
        });
      }
    });

    return getDeck(id);
  } catch (error) {
    console.error('Error updating deck:', error);
    throw error;
  }
}

export async function deleteDeck(id: string) {
  try {
    const db = await createDbClient();
    await db.delete(deck).where(eq(deck.id, id));
  } catch (error) {
    console.error('Error deleting deck:', error);
    throw error;
  }
}

export async function createFlashcard(
  deckId: string,
  front: string,
  back: string,
  audio?: string
) {
  const db = await createDbClient();
  const now = Date.now();

  try {
    const newFlashcard = {
      id: crypto.randomUUID(),
      deckId,
      front,
      back,
      audio,
      createdAt: now,
      updatedAt: now,
      lastReviewed: null,
      nextReview: null,
      state: 'new' as const,
      stability: 1,
      difficulty: 5,
      elapsedDays: 0,
      scheduledDays: 0,
      reps: 0,
      lapses: 0,
      interval: 0,
      easeFactor: 250,
    };

    await db.insert(flashcard).values(newFlashcard);
    return newFlashcard;
  } catch (error) {
    console.error('Error creating flashcard:', error);
    throw error;
  }
}

export async function updateFlashcard(
  id: string,
  front: string,
  back: string,
  reviewData?: {
    lastReviewed: number;
    nextReview: number | null;  // Allow null here
    state?: 'new' | 'learning' | 'review' | 'relearning';
    stability?: number;
    difficulty?: number;
    elapsedDays?: number;
    scheduledDays?: number;
    reps?: number;
    lapses?: number;
  }
) {
  const db = await getDb();

  try {
    const updateData: Record<string, any> = {
      front,
      back,
      updatedAt: Date.now()
    };

    if (reviewData) {
      updateData.lastReviewed = reviewData.lastReviewed;
      updateData.nextReview = reviewData.nextReview;
      
      if (reviewData.state) updateData.state = reviewData.state;
      if (typeof reviewData.stability === 'number') updateData.stability = reviewData.stability;
      if (typeof reviewData.difficulty === 'number') updateData.difficulty = reviewData.difficulty;
      if (typeof reviewData.elapsedDays === 'number') updateData.elapsedDays = reviewData.elapsedDays;
      if (typeof reviewData.scheduledDays === 'number') updateData.scheduledDays = reviewData.scheduledDays;
      if (typeof reviewData.reps === 'number') updateData.reps = reviewData.reps;
      if (typeof reviewData.lapses === 'number') updateData.lapses = reviewData.lapses;
    }

    await db
      .update(flashcard)
      .set(updateData)
      .where(eq(flashcard.id, id));

    const updatedCard = await db
      .select()
      .from(flashcard)
      .where(eq(flashcard.id, id))
      .get();

    if (!updatedCard) {
      throw new Error('Failed to fetch updated flashcard');
    }

    // Convert the values to appropriate types
    return {
      ...updatedCard,
      createdAt: Number(updatedCard.createdAt),
      updatedAt: Number(updatedCard.updatedAt),
      lastReviewed: updatedCard.lastReviewed ? Number(updatedCard.lastReviewed) : null,
      nextReview: updatedCard.nextReview ? Number(updatedCard.nextReview) : null,
      stability: Number(updatedCard.stability),
      difficulty: Number(updatedCard.difficulty),
      elapsedDays: Number(updatedCard.elapsedDays),
      scheduledDays: Number(updatedCard.scheduledDays),
      reps: Number(updatedCard.reps),
      lapses: Number(updatedCard.lapses),
      interval: Number(updatedCard.interval),
      easeFactor: Number(updatedCard.easeFactor)
    };

  } catch (error) {
    console.error('Error in updateFlashcard:', error);
    throw new Error(`Failed to update flashcard: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export async function deleteFlashcard(id: string) {
  try {
    const db = await createDbClient();
    await db.delete(flashcard).where(eq(flashcard.id, id));
  } catch (error) {
    console.error('Error deleting flashcard:', error);
    throw error;
  }
}

export async function getFlashcards(deckId: string) {
  const db = await createDbClient();

  try {
    // First verify the deck exists
    const deckExists = await db
      .select()
      .from(deck)
      .where(eq(deck.id, deckId))
      .get();

    if (!deckExists) {
      throw new Error('Deck not found');
    }

    // Use explicit casting in the SQL query to handle BigInt values
    const cards = await db
      .select({
        id: flashcard.id,
        deckId: flashcard.deckId,
        front: flashcard.front,
        back: flashcard.back,
        audio: flashcard.audio,
        createdAt: sql<string>`CAST(${flashcard.createdAt} AS TEXT)`,
        updatedAt: sql<string>`CAST(${flashcard.updatedAt} AS TEXT)`,
        lastReviewed: sql<string>`CAST(${flashcard.lastReviewed} AS TEXT)`,
        nextReview: sql<string>`CAST(${flashcard.nextReview} AS TEXT)`,
        state: flashcard.state,
        stability: sql<string>`CAST(${flashcard.stability} AS TEXT)`,
        difficulty: sql<string>`CAST(${flashcard.difficulty} AS TEXT)`,
        elapsedDays: sql<string>`CAST(${flashcard.elapsedDays} AS TEXT)`,
        scheduledDays: sql<string>`CAST(${flashcard.scheduledDays} AS TEXT)`,
        reps: sql<string>`CAST(${flashcard.reps} AS TEXT)`,
        lapses: sql<string>`CAST(${flashcard.lapses} AS TEXT)`,
        interval: sql<string>`CAST(${flashcard.interval} AS TEXT)`,
        easeFactor: sql<string>`CAST(${flashcard.easeFactor} AS TEXT)`
      })
      .from(flashcard)
      .where(eq(flashcard.deckId, deckId));

    // Convert the string values to appropriate JavaScript types
    return cards.map(card => ({
      ...card,
      createdAt: parseInt(card.createdAt, 10),
      updatedAt: parseInt(card.updatedAt, 10),
      lastReviewed: card.lastReviewed ? parseInt(card.lastReviewed, 10) : null,
      nextReview: card.nextReview ? parseInt(card.nextReview, 10) : null,
      stability: parseFloat(card.stability),
      difficulty: parseFloat(card.difficulty),
      elapsedDays: parseInt(card.elapsedDays, 10),
      scheduledDays: parseInt(card.scheduledDays, 10),
      reps: parseInt(card.reps, 10),
      lapses: parseInt(card.lapses, 10),
      interval: parseInt(card.interval, 10),
      easeFactor: parseInt(card.easeFactor, 10)
    }));

  } catch (error) {
    console.error('Database error in getFlashcards:', error);
    
    if (error instanceof Error) {
      throw new Error(`Failed to fetch flashcards: ${error.message}`);
    }
    
    throw new Error('Failed to fetch flashcards: Unknown error');
  }
}

export async function createStudySession(
  userId: string,
  cardsStudied: number,
  startTime: Date,
  endTime: Date,
  correctCount: number = 0,
  incorrectCount: number = 0,
  averageTime: number = 0
) {
  const db = await createDbClient();

  try {
    // Ensure times are stored as milliseconds timestamps
    const sessionData = {
      id: crypto.randomUUID(),
      userId,
      cardsStudied,
      startTime: startTime.getTime(),
      endTime: endTime.getTime(),
      createdAt: Date.now(),
      correctCount,
      incorrectCount,
      averageTime
    };

    await db.insert(studySession).values(sessionData);
    return sessionData;
  } catch (error) {
    console.error('Error creating study session:', error);
    throw error;
  }
}

export async function createReviewLog(
  userId: string,
  flashcardId: string,
  rating: number,
  reviewData: {
    stability: number;
    difficulty: number;
    elapsedDays: number;
    scheduledDays: number;
    responseTime: number;
  }
) {
  const db = await createDbClient();

  try {
    const logEntry = {
      id: crypto.randomUUID(),
      userId,
      flashcardId,
      rating,
      reviewedAt: Date.now(),
      ...reviewData
    };

    await db.insert(reviewLog).values(logEntry);
    return logEntry;
  } catch (error) {
    console.error('Error creating review log:', error);
    throw error;
  }
}

export async function getStudyStats(userId: string) {
  const db = await createDbClient();
  const now = new Date();
  const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
  const todayEnd = todayStart + (24 * 60 * 60 * 1000);

  try {
    // Get today's study sessions with detailed time tracking
    const todaysSessions = await db
      .select({
        cardsStudied: studySession.cardsStudied,
        startTime: studySession.startTime,
        endTime: studySession.endTime,
        correctCount: studySession.correctCount,
        incorrectCount: studySession.incorrectCount
      })
      .from(studySession)
      .where(
        and(
          eq(studySession.userId, userId),
          gte(studySession.startTime, todayStart),
          lt(studySession.endTime, todayEnd)
        )
      );

    // Calculate total study time in minutes
    const todayStats = todaysSessions.reduce(
      (acc, session) => ({
        cardsStudied: acc.cardsStudied + session.cardsStudied,
        studyTime: acc.studyTime + (session.endTime - session.startTime),
        correctCount: acc.correctCount + session.correctCount,
        incorrectCount: acc.incorrectCount + session.incorrectCount,
      }),
      {
        cardsStudied: 0,
        studyTime: 0,
        correctCount: 0,
        incorrectCount: 0,
      }
    );

    const studyTimeMinutes = Math.round(todayStats.studyTime / (1000 * 60));

    // Get last 30 days of data
    const thirtyDaysAgo = new Date(now.getTime() - (30 * 24 * 60 * 60 * 1000));
    
    const lastThirtyDaysSessions = await db
      .select()
      .from(studySession)
      .where(
        and(
          eq(studySession.userId, userId),
          gte(studySession.startTime, thirtyDaysAgo.getTime())
        )
      );

    // Process sessions into daily data
    const dailyData = new Map();
    
    // Initialize all dates in the last 30 days
    for (let i = 0; i < 30; i++) {
      const date = new Date(now);
      date.setDate(date.getDate() - i);
      const dateStr = date.toISOString().split('T')[0];
      dailyData.set(dateStr, { count: 0, studyTime: 0 });
    }

    // Fill in actual study data
    lastThirtyDaysSessions.forEach(session => {
      const date = new Date(session.startTime).toISOString().split('T')[0];
      const existing = dailyData.get(date) || { count: 0, studyTime: 0 };
      dailyData.set(date, {
        count: existing.count + session.cardsStudied,
        studyTime: existing.studyTime + (session.endTime - session.startTime)
      });
    });

    // Calculate streak
    let streak = 0;
    let currentDate = new Date(now);
    
    while (streak < 30) {
      const dateStr = currentDate.toISOString().split('T')[0];
      const dayData = dailyData.get(dateStr);
      
      if (!dayData || (dayData.count === 0 && dateStr !== now.toISOString().split('T')[0])) {
        break;
      }
      
      if (dayData.count > 0) {
        streak++;
      }
      
      currentDate.setDate(currentDate.getDate() - 1);
    }

    return {
      totalCardsToday: todayStats.cardsStudied,
      studyTimeToday: studyTimeMinutes,
      correctCount: todayStats.correctCount,
      incorrectCount: todayStats.incorrectCount,
      accuracy: todayStats.cardsStudied > 0 
        ? Math.round((todayStats.correctCount / todayStats.cardsStudied) * 100)
        : 0,
      streak,
      lastThirtyDays: Array.from(dailyData, ([date, data]) => ({
        date,
        count: data.count,
        studyTime: Math.round(data.studyTime / (1000 * 60)) // Convert to minutes
      })).sort((a, b) => a.date.localeCompare(b.date))
    };
  } catch (error) {
    console.error('Error fetching study stats:', error);
    throw error;
  }
}

export async function getMarketplaceDecks() {
  const db = await getDb();
  
  const decks = await db
    .select({
      id: sharedDeck.id,
      title: sharedDeck.title,
      description: sharedDeck.description,
      downloads: sharedDeck.downloads,
      createdAt: sharedDeck.createdAt,
      userId: sharedDeck.userId,
      user: {
        name: user.name,
        image: user.image,
      },
      averageRating: sql<number>`COALESCE(AVG(${deckRating.rating}), 0)`.as('averageRating'),
      ratingCount: sql<number>`COUNT(${deckRating.id})`.as('ratingCount'),
      labels: sql<string[]>`JSON_GROUP_ARRAY(DISTINCT CASE WHEN ${label.name} IS NULL THEN NULL ELSE ${label.name} END)`
    })
    .from(sharedDeck)
    .leftJoin(user, eq(sharedDeck.userId, user.id))
    .leftJoin(deckRating, eq(sharedDeck.id, deckRating.sharedDeckId))
    .leftJoin(deckLabel, eq(sharedDeck.id, deckLabel.deckId))
    .leftJoin(label, eq(deckLabel.labelId, label.id))
    .groupBy(sharedDeck.id, user.name, user.image);

  // Transform the results to handle empty labels and JSON parsing
  return decks.map(deck => ({
    ...deck,
    labels: deck.labels[0] === null ? [] 
      : Array.from(new Set(JSON.parse(deck.labels.toString())))
  }));
}

================
File: lib/error-handler.ts
================
export class TranslationError extends Error {
  constructor(
    message: string,
    public readonly statusCode: number = 500,
    public readonly context?: Record<string, any>
  ) {
    super(message);
    this.name = 'TranslationError';

    console.error('Translation Error:', {
      message,
      statusCode,
      context,
      stack: this.stack
    });
  }

  static isServiceUnavailable(error: unknown): boolean {
    return error instanceof TranslationError && error.statusCode === 503;
  }

  static isBadRequest(error: unknown): boolean {
    return error instanceof TranslationError && error.statusCode === 400;
  }
}

export class ErrorHandler {
  static async handle(error: unknown) {
    console.error('Raw error:', error);

    if (error instanceof TranslationError) {
      return {
        error: error.message,
        statusCode: error.statusCode,
        context: error.context
      };
    }

    if (error instanceof Error) {
      if (error.message.includes('503')) {
        return {
          error: 'Translation service is temporarily unavailable. Please try again.',
          statusCode: 503
        };
      }
      if (error.message.includes('400')) {
        return {
          error: 'Invalid translation request. Please check your input.',
          statusCode: 400
        };
      }

      return {
        error: `Translation error: ${error.message}`,
        statusCode: 500
      };
    }

    return {
      error: 'An unexpected error occurred',
      statusCode: 500
    };
  }

  static async logError(error: unknown, context?: Record<string, any>) {
    console.error('Translation error:', {
      error,
      context,
      timestamp: new Date().toISOString()
    });
  }
}

================
File: lib/fsrs.ts
================
interface FSRSParameters {
  w: [number, number, number, number];
  requestRetention: number;
}

export interface Rating {
  rating: 'again' | 'hard' | 'good' | 'easy';
  value: 1 | 2 | 3 | 4;
}

export interface CardState {
  state: 'new' | 'learning' | 'review' | 'relearning';
  stability: number;
  difficulty: number;
  elapsedDays: number;
  scheduledDays: number;
  reps: number;
  lapses: number;
}

const DEFAULT_PARAMETERS: FSRSParameters = {
  w: [1.0, 1.0, 5.0, -1.0],
  requestRetention: 0.9,
};

export class FSRS {
  private parameters: FSRSParameters;

  constructor(parameters: Partial<FSRSParameters> = {}) {
    this.parameters = { ...DEFAULT_PARAMETERS, ...parameters };
  }

  private getInitialInterval(rating: Rating): number {
    switch (rating.rating) {
      case 'again': return 1/1440;  // 1 minute in days
      case 'hard': return 5/1440;   // 5 minutes
      case 'good': return 10/1440;  // 10 minutes
      case 'easy': return 1;        // 1 day
    }
  }

  private retrievabilityToStability(R: number, S: number): number {
    const w = this.parameters.w;
    const newStability = Math.min(
      S * (1 + Math.exp(w[0]) * (11 - R) + w[1] * (Math.log(S) - Math.log(1))),
      180 
    );
    return Math.max(1, newStability); 
  }

  private calculateRetrievability(S: number, t: number): number {
    return Math.exp(Math.log(0.9) * t / Math.max(1, S));
  }

  private intervalFromStability(S: number): number {
    return Math.min(
      Math.max(1, Math.round(S * Math.log(this.parameters.requestRetention) / Math.log(0.9))),
      180
    );
  }

  public updateState(
    currentState: CardState,
    rating: Rating,
    now: number = Date.now()
  ): CardState {
    const elapsedDays = Math.max(0, (now - (currentState.scheduledDays || now)) / (24 * 60 * 60 * 1000));
    const R = this.calculateRetrievability(currentState.stability, elapsedDays);

    let newState: CardState = { ...currentState };
    
    if (currentState.state === 'new' || currentState.reps === 0) {
      newState.scheduledDays = this.getInitialInterval(rating);
      newState.stability = 1;
      newState.state = rating.rating === 'again' ? 'learning' : 'review';
      newState.reps = 1;
      return newState;
    }

    if (currentState.state === 'learning' || currentState.state === 'relearning') {
      if (rating.rating === 'again') {
        newState.scheduledDays = 1/1440; 
      } else if (rating.rating === 'good' || rating.rating === 'easy') {
        newState.scheduledDays = 1; 
        newState.state = 'review';
      } else {
        newState.scheduledDays = 10/1440; 
      }
      newState.reps += 1;
      return newState;
    }

    // Handle review cards
    switch (rating.rating) {
      case 'again':
        newState.state = 'relearning';
        newState.stability = Math.max(1, currentState.stability * 0.5);
        newState.difficulty = Math.min(10, currentState.difficulty + 1);
        newState.scheduledDays = 1/1440; 
        newState.lapses += 1;
        break;

      case 'hard':
        newState.state = 'review';
        newState.stability = this.retrievabilityToStability(R, currentState.stability) * 0.8;
        newState.difficulty = Math.max(1, currentState.difficulty - 0.5);
        newState.scheduledDays = Math.min(
          currentState.scheduledDays * 1.2,
          this.intervalFromStability(newState.stability)
        );
        break;

      case 'good':
        newState.state = 'review';
        newState.stability = this.retrievabilityToStability(R, currentState.stability);
        // More conservative interval increase
        newState.scheduledDays = Math.min(
          currentState.scheduledDays * 2,
          this.intervalFromStability(newState.stability)
        );
        break;

      case 'easy':
        newState.state = 'review';
        newState.stability = this.retrievabilityToStability(R, currentState.stability) * 1.3;
        newState.difficulty = Math.max(1, currentState.difficulty - 1);
        // More conservative interval increase for 'easy' responses
        newState.scheduledDays = Math.min(
          currentState.scheduledDays * 2.5,
          this.intervalFromStability(newState.stability)
        );
        break;
    }

    // Cap the maximum interval to 180 days (6 months)
    newState.scheduledDays = Math.min(newState.scheduledDays, 180);
    newState.reps += 1;
    newState.elapsedDays = 0;

    return newState;
  }

  // Get next review date
  public getNextReviewDate(state: CardState): Date {
    const now = new Date();
    // Convert scheduledDays to milliseconds and add to current time
    const nextDate = new Date(now.getTime() + (state.scheduledDays * 24 * 60 * 60 * 1000));
    return nextDate;
  }

  // Get initial state for a new card
  public getInitialState(): CardState {
    return {
      state: 'new',
      stability: 1,
      difficulty: 5,
      elapsedDays: 0,
      scheduledDays: 0,
      reps: 0,
      lapses: 0,
    };
  }
}

export const fsrs = new FSRS();

================
File: lib/huggingface.ts
================
// lib/huggingface.ts
import { TranslationResult } from './types';

const MAX_RETRIES = 5;
const BASE_DELAY = 2000;

interface TranslationResponse {
  translation_text: string;
}

function delay(ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Implements exponential backoff with jitter
 */
function getBackoffDelay(attempt: number) {
  const exponentialDelay = BASE_DELAY * Math.pow(2, attempt);
  const jitter = Math.random() * 1000; // Add up to 1 second of random jitter
  return exponentialDelay + jitter;
}

/**
 * Makes a request to the Hugging Face model API with retries
 */
async function makeModelRequest(
  model: string,
  apiToken: string,
  body: any,
  attempt: number = 0
): Promise<Response> {
  const response = await fetch(
    `https://api-inference.huggingface.co/models/${model}`,
    {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(body),
      // Increase timeout for initial model loading
      signal: AbortSignal.timeout(30000)
    }
  );

  // Handle specific response codes
  if (response.status === 503) {
    if (attempt >= MAX_RETRIES) {
      throw new Error(`Model ${model} failed to load after ${MAX_RETRIES} attempts`);
    }

    console.log(`Model ${model} is loading (attempt ${attempt + 1}/${MAX_RETRIES})`);
    const backoffDelay = getBackoffDelay(attempt);
    await delay(backoffDelay);
    
    return makeModelRequest(model, apiToken, body, attempt + 1);
  }

  return response;
}

async function translateText(
  text: string,
  model: string,
  apiToken: string
): Promise<string> {
  try {
    const response = await makeModelRequest(model, apiToken, { inputs: text });

    if (!response.ok) {
      throw new Error(`Translation failed: ${response.statusText}`);
    }

    const data: TranslationResponse[] = await response.json();
    
    if (!Array.isArray(data) || !data[0]?.translation_text) {
      throw new Error('Invalid response format from translation service');
    }

    return data[0].translation_text;
  } catch (error) {
    if (error instanceof Error) {
      // Check if it's a timeout error
      if (error.name === 'TimeoutError' || error.name === 'AbortError') {
        throw new Error('Translation service timed out. Please try again.');
      }
    }
    throw error;
  }
}

export async function getTranslation(
  text: string,
  sourceLang: string,
  targetLang: string,
  apiToken: string
): Promise<TranslationResult> {
  const modelKey = `${sourceLang}-${targetLang}`;
  const model = TRANSLATION_MODEL_MAP[modelKey];

  if (!model) {
    throw new Error(`Unsupported language pair: ${sourceLang} to ${targetLang}`);
  }

  try {
    // Pre-validate the input
    if (!text.trim()) {
      throw new Error('Translation text cannot be empty');
    }

    if (text.length > 500) {
      throw new Error('Text too long. Maximum length is 500 characters.');
    }

    console.log(`Starting translation from ${sourceLang} to ${targetLang}...`);
    const translatedText = await translateText(text, model, apiToken);

    return {
      source: text,
      target: translatedText,
      sourceExample: '',
      targetExample: ''
    };
  } catch (error) {
    console.error('Translation error:', error);
    
    // Provide user-friendly error messages based on error type
    if (error instanceof Error) {
      if (error.message.includes('failed to load')) {
        throw new Error('Translation service is currently initializing. Please try again in a few moments.');
      }
      if (error.message.includes('timed out')) {
        throw new Error('Request timed out. The service might be experiencing high load.');
      }
      if (error.message.includes('Maximum length')) {
        throw new Error(error.message);
      }
    }
    
    // Generic error for other cases
    throw new Error('Translation service is temporarily unavailable. Please try again in a few moments.');
  }
}

export const TRANSLATION_MODEL_MAP: { [key: string]: string } = {
  'en-de': 'Helsinki-NLP/opus-mt-en-de',
  'de-en': 'Helsinki-NLP/opus-mt-de-en',
  'en-fr': 'Helsinki-NLP/opus-mt-en-fr',
  'fr-en': 'Helsinki-NLP/opus-mt-fr-en',
  'en-es': 'Helsinki-NLP/opus-mt-en-es',
  'es-en': 'Helsinki-NLP/opus-mt-es-en',
  'en-it': 'Helsinki-NLP/opus-mt-en-it',
  'it-en': 'Helsinki-NLP/opus-mt-it-en',
  'en-pt': 'Helsinki-NLP/opus-mt-en-pt',
  'pt-en': 'Helsinki-NLP/opus-mt-pt-en',
  'en-ru': 'Helsinki-NLP/opus-mt-en-ru',
  'ru-en': 'Helsinki-NLP/opus-mt-ru-en'
};

export type SupportedLanguage = 'en' | 'de' | 'fr' | 'es' | 'it' | 'pt' | 'ru';

export const languageMapping: Record<SupportedLanguage, string> = {
  'en': 'English',
  'de': 'German',
  'fr': 'French',
  'es': 'Spanish',
  'it': 'Italian',
  'pt': 'Portuguese',
  'ru': 'Russian'
};

export function isLanguagePairSupported(sourceLang: string, targetLang: string): boolean {
  return `${sourceLang}-${targetLang}` in TRANSLATION_MODEL_MAP;
}

================
File: lib/migrate.ts
================
import { drizzle } from 'drizzle-orm/libsql';
import { migrate } from 'drizzle-orm/libsql/migrator';
import { createClient } from '@libsql/client';
import * as schema from './schema';

const runMigrations = async () => {
  if (!process.env.NEXT_PUBLIC_TURSO_DATABASE_URL || !process.env.NEXT_PUBLIC_TURSO_AUTH_TOKEN) {
    throw new Error('Database credentials are not properly configured');
  }

  const client = createClient({
    url: process.env.NEXT_PUBLIC_TURSO_DATABASE_URL,
    authToken: process.env.NEXT_PUBLIC_TURSO_AUTH_TOKEN,
  });

  const db = drizzle(client, { schema });

  try {
    await migrate(db, {
      migrationsFolder: 'migrations'
    });
  } finally {
    await client.close();
  }
};

runMigrations().catch((err) => {
  console.error('Migration failed:', err);
  process.exit(1);
});

================
File: lib/rate-limiter.ts
================
import { getDb } from './db';
import { userRateLimit } from './schema';
import { eq, sql } from 'drizzle-orm';

interface RateLimitResponse {
  isLimited: boolean;
  remaining: number;
  resetIn?: number;
  message?: string;
}

export const RATE_LIMITS = {
  TRANSLATIONS_PER_HOUR: 35,      
  TRANSLATIONS_PER_DAY: 100,      
  TRANSLATIONS_PER_MONTH: 500,   
} as const;

const HOUR = 3600000;   
const DAY = 86400000;   
const MONTH = 2592000000; 

export class RateLimiter {
  private static async initializeUserData(userId: string) {
    const now = Date.now();
    const db = await getDb();

    const newRateLimit = {
      id: crypto.randomUUID(),
      userId,
      translationCount: 0,
      translationResetTime: now + HOUR,
      dailyCount: 0,
      dailyResetTime: now + DAY,
      monthlyCount: 0,
      monthlyResetTime: now + MONTH,
      lastUpdated: now
    };

    await db.insert(userRateLimit).values(newRateLimit);
    return newRateLimit;
  }

  private static async cleanupExpiredData(userId: string) {
    const db = await getDb();
    const now = Date.now();

    const data = await db
      .select()
      .from(userRateLimit)
      .where(eq(userRateLimit.userId, userId))
      .get();

    if (!data) return null;

    const updates: Partial<typeof data> = {
      lastUpdated: now
    };

    if (now >= data.translationResetTime) {
      updates.translationCount = 0;
      updates.translationResetTime = now + HOUR;
    }

    if (now >= data.dailyResetTime) {
      updates.dailyCount = 0;
      updates.dailyResetTime = now + DAY;
    }

    if (now >= data.monthlyResetTime) {
      updates.monthlyCount = 0;
      updates.monthlyResetTime = now + MONTH;
    }

    if (Object.keys(updates).length > 1) { 
      await db
        .update(userRateLimit)
        .set(updates)
        .where(eq(userRateLimit.userId, userId));

      return {
        ...data,
        ...updates
      };
    }

    return data;
  }

  static async getRemainingTranslations(userId: string): Promise<RateLimitResponse> {
    const db = await getDb();
    
    let data = await db
      .select()
      .from(userRateLimit)
      .where(eq(userRateLimit.userId, userId))
      .get();

    if (!data) {
      data = await this.initializeUserData(userId);
    } else {
      data = await this.cleanupExpiredData(userId) || data;
    }

    const now = Date.now();
    
    // Check limits and find the most restrictive one
    const hourlyRemaining = Math.max(0, RATE_LIMITS.TRANSLATIONS_PER_HOUR - data.translationCount);
    const dailyRemaining = Math.max(0, RATE_LIMITS.TRANSLATIONS_PER_DAY - data.dailyCount);
    const monthlyRemaining = Math.max(0, RATE_LIMITS.TRANSLATIONS_PER_MONTH - data.monthlyCount);
    
    const remaining = Math.min(hourlyRemaining, dailyRemaining, monthlyRemaining);
    
    if (remaining === 0) {
      const resetIn = Math.min(
        data.translationResetTime - now,
        data.dailyResetTime - now,
        data.monthlyResetTime - now
      );
      
      let message = 'Rate limit reached. ';
      if (resetIn <= HOUR) {
        message += `Resets in ${Math.ceil(resetIn / 60000)} minutes.`;
      } else if (resetIn <= DAY) {
        message += `Resets in ${Math.ceil(resetIn / HOUR)} hours.`;
      } else {
        message += `Resets in ${Math.ceil(resetIn / DAY)} days.`;
      }

      return {
        isLimited: true,
        remaining: 0,
        resetIn,
        message
      };
    }

    return {
      isLimited: false,
      remaining
    };
  }

  static async checkTranslationLimit(userId: string): Promise<RateLimitResponse> {
    const db = await getDb();
    
    const status = await this.getRemainingTranslations(userId);
    
    if (!status.isLimited) {
      await db
        .update(userRateLimit)
        .set({
          translationCount: sql`${userRateLimit.translationCount} + 1`,
          dailyCount: sql`${userRateLimit.dailyCount} + 1`,
          monthlyCount: sql`${userRateLimit.monthlyCount} + 1`,
          lastUpdated: Date.now()
        })
        .where(eq(userRateLimit.userId, userId));
    }

    return status;
  }
}

================
File: lib/schema.ts
================
import { sqliteTable, text, integer, real, foreignKey } from 'drizzle-orm/sqlite-core';
import { type InferSelectModel, type InferInsertModel } from 'drizzle-orm';


export const user = sqliteTable('user', {
  id: text('id').notNull().primaryKey(),

  name: text('name'),
  email: text('email').unique(),
  emailVerified: integer('emailVerified', { mode: 'timestamp_ms' }),
  image: text('image'),
});

export const account = sqliteTable('account', {
  id: text('id').notNull().primaryKey(),
  userId: text('userId')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
  type: text('type').notNull(),
  provider: text('provider').notNull(),
  providerAccountId: text('providerAccountId').notNull(),
  refresh_token: text('refresh_token'),
  access_token: text('access_token'),
  expires_at: integer('expires_at'),
  token_type: text('token_type'),
  scope: text('scope'),
  id_token: text('id_token'),
  session_state: text('session_state'),
});


export const deck = sqliteTable('deck', {
  id: text('id').notNull().primaryKey(),
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
  title: text('title').notNull(),
  description: text('description'),
  createdAt: integer('created_at').notNull(),
  updatedAt: integer('updated_at').notNull(),
  originalSharedDeckId: text('original_shared_deck_id'),
});


export const flashcard = sqliteTable('flashcard', {
  id: text('id').notNull().primaryKey(),
  deckId: text('deck_id')
    .notNull()
    .references(() => deck.id, { onDelete: 'cascade' }),
  front: text('front').notNull(),
  back: text('back').notNull(),
  audio: text('audio'),
  
  // Core timestamps
  createdAt: integer('created_at').notNull(),
  updatedAt: integer('updated_at').notNull(),
  lastReviewed: integer('last_reviewed'),
  nextReview: integer('next_review'),

  // FSRS fields
  state: text('state', { 
    enum: ['new', 'learning', 'review', 'relearning'] 
  }).notNull().default('new'),
  stability: real('stability').notNull().default(1),
  difficulty: real('difficulty').notNull().default(5),
  elapsedDays: integer('elapsed_days').notNull().default(0),
  scheduledDays: integer('scheduled_days').notNull().default(0),
  reps: integer('reps').notNull().default(0),
  lapses: integer('lapses').notNull().default(0),
  interval: integer('interval').notNull().default(0),
  easeFactor: integer('ease_factor').notNull().default(250),
});

export const studySession = sqliteTable('study_session', {
  id: text('id').notNull().primaryKey(),
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
  cardsStudied: integer('cards_studied').notNull(),
  startTime: integer('start_time').notNull(),
  endTime: integer('end_time').notNull(),
  createdAt: integer('created_at').notNull(),
  correctCount: integer('correct_count').notNull().default(0),
  incorrectCount: integer('incorrect_count').notNull().default(0),
  averageTime: integer('average_time').notNull().default(0),
});

export const reviewLog = sqliteTable('review_log', {
  id: text('id').notNull().primaryKey(),
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
  flashcardId: text('flashcard_id')
    .notNull()
    .references(() => flashcard.id, { onDelete: 'cascade' }),
  rating: integer('rating').notNull(),
  reviewedAt: integer('reviewed_at').notNull(),
  stability: real('stability').notNull(),
  difficulty: real('difficulty').notNull(),
  elapsedDays: integer('elapsed_days').notNull(),
  scheduledDays: integer('scheduled_days').notNull(),
  responseTime: integer('response_time').notNull(),
});


export const sharedDeck = sqliteTable('shared_deck', {
  id: text('id').notNull().primaryKey(),
  originalDeckId: text('original_deck_id')
    .notNull()
    .references(() => deck.id, { onDelete: 'cascade' }),
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
  title: text('title').notNull(),
  description: text('description'),
  createdAt: integer('created_at').notNull(),
  updatedAt: integer('updated_at').notNull(),
  downloads: integer('downloads').notNull().default(0),
  isPublic: integer('is_public', { mode: 'boolean' }).notNull().default(true),
});


export const deckRating = sqliteTable('deck_rating', {
  id: text('id').notNull().primaryKey(),
  sharedDeckId: text('shared_deck_id').notNull().references(() => sharedDeck.id, { onDelete: 'cascade' }),
  userId: text('user_id').notNull().references(() => user.id, { onDelete: 'cascade' }),
  rating: real('rating').notNull(), // Allows half stars (0.5, 1.0, 1.5, etc.)
  createdAt: integer('created_at').notNull(),
  updatedAt: integer('updated_at').notNull(),
});

export const deckComment = sqliteTable('deck_comment', {
  id: text('id').notNull().primaryKey(),
  sharedDeckId: text('shared_deck_id').notNull().references(() => sharedDeck.id, { onDelete: 'cascade' }),
  userId: text('user_id').notNull().references(() => user.id, { onDelete: 'cascade' }),
  content: text('content').notNull(),
  createdAt: integer('created_at').notNull(),
  updatedAt: integer('updated_at').notNull(),
});

export const label = sqliteTable('label', {
  id: text('id').primaryKey(),
  name: text('name').notNull(),
  createdAt: integer('created_at').notNull(),
});

export const deckLabel = sqliteTable('deck_label', {
  id: text('id').primaryKey(),
  deckId: text('deck_id')
    .notNull()
    .references(() => deck.id, { onDelete: 'cascade' }),
  labelId: text('label_id')
    .notNull()
    .references(() => label.id, { onDelete: 'cascade' }),
});

export const userRateLimit = sqliteTable('user_rate_limit', {
  id: text('id').primaryKey(),
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
  translationCount: integer('translation_count').notNull().default(0),
  translationResetTime: integer('translation_reset_time').notNull(),
  dailyCount: integer('daily_count').notNull().default(0),
  dailyResetTime: integer('daily_reset_time').notNull(),
  monthlyCount: integer('monthly_count').notNull().default(0),
  monthlyResetTime: integer('monthly_reset_time').notNull(),
  lastUpdated: integer('last_updated').notNull()
});

export type User = InferSelectModel<typeof user>;
export type NewUser = InferInsertModel<typeof user>;

export type Account = InferSelectModel<typeof account>;
export type NewAccount = InferInsertModel<typeof account>;

export type Deck = InferSelectModel<typeof deck>;
export type NewDeck = InferInsertModel<typeof deck>;

export type Flashcard = InferSelectModel<typeof flashcard>;
export type NewFlashcard = InferInsertModel<typeof flashcard>;

export type StudySession = InferSelectModel<typeof studySession>;
export type NewStudySession = InferInsertModel<typeof studySession>;

export type ReviewLog = InferSelectModel<typeof reviewLog>;
export type NewReviewLog = InferInsertModel<typeof reviewLog>;

export type CardState = 'new' | 'learning' | 'review' | 'relearning';

export type SharedDeck = InferSelectModel<typeof sharedDeck>;
export type DeckRating = InferSelectModel<typeof deckRating>;
export type DeckComment = InferSelectModel<typeof deckComment>;

export type UserRateLimit = typeof userRateLimit.$inferSelect;
export type NewUserRateLimit = typeof userRateLimit.$inferInsert;

================
File: lib/types.ts
================
// lib/types.ts
import { Session, DefaultSession } from "next-auth"
import { pipeline, PipelineType } from '@huggingface/transformers';
import type { 
  Flashcard as DrizzleFlashcard,
  StudySession as DrizzleStudySession,
} from './schema';

export interface Deck {
  id: string;
  title: string;
  description: string | null;
  userId: string;
  createdAt: Date;
  updatedAt: Date;
  labels?: string[];
  originalSharedDeckId?: string | null;
}

export interface StudyData {
  date: string;
  count: number;
  studyTime: number;
}

export type Config = {
  schema: string
  out: string
  dialect: "sqlite"
  driver: "d1-http" | "expo" | "turso" | undefined
  dbCredentials: {
    url: string
    authToken: string | undefined
  }
}


export interface Flashcard {
  id: string;
  deckId: string;
  front: string;
  back: string;
  audio?: string | null;
  createdAt: number;
  updatedAt: number;
  lastReviewed: number | null;
  nextReview: number | null;  // Allow null here
  state: 'new' | 'learning' | 'review' | 'relearning';
  stability: number;
  difficulty: number;
  elapsedDays: number;
  scheduledDays: number;
  reps: number;
  lapses: number;
  interval: number;
  easeFactor: number;
}


export interface ReviewData {
  lastReviewed: number;
  nextReview: number | null;  // Allow null here
  state: 'new' | 'learning' | 'review' | 'relearning';
  stability: number;
  difficulty: number;
  elapsedDays: number;
  scheduledDays: number;
  reps: number;
  lapses: number;
}


export interface ExtendedUser {
  id: string
  name?: string | null
  email?: string | null
  image?: string | null
}

export interface ExtendedSession extends DefaultSession {
  user: ExtendedUser
}

export interface RouteHandlerContext<T = Record<string, string>> {
  params: T;
}

export interface ApiResponse<T = any> {
  data?: T;
  error?: string;
  message?: string;
}

export interface StudySessionStats {
  totalCardsToday: number;
  studyTimeToday: number;
  streak: number;
  lastThirtyDays: StudyData[];
}

export interface TranslationResponse {
  source: string;
  target: string;
  sourceExample: string;
  targetExample: string;
  audio?: string;
}

export interface Language {
  code: string;
  name: string;
}

export interface TranslationResult {
  source: string;
  target: string;
  sourceExample: string;
  targetExample: string;
}

export interface TTSOptions {
  speaker_embeddings?: null | string;
  speed_ratio?: number;
  pitch_ratio?: number;
  energy_ratio?: number;
}

export interface TranslationResponse {
  translation_text: string;
}

export interface TranslationWorkerMessage {
  task: PipelineType;
  modelId: string;
  inputs: string;
  options?: Record<string, any>;
}

export type FlashcardUpdateData = {
  front: string;
  back: string;
  reviewData?: {
    lastReviewed: number;
    nextReview: number;
    state?: 'new' | 'learning' | 'review' | 'relearning';
    stability?: number;
    difficulty?: number;
    elapsedDays?: number;
    scheduledDays?: number;
    reps?: number;
    lapses?: number;
  };
};

export interface TranslationWorkerResponse {
  type: 'progress' | 'result' | 'error';
  progress?: number;
  result?: TranslationResponse;
  error?: string;
}


export interface Deck {
  id: string;
  userId: string;
  title: string;
  description: string | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface CardState {
  state: 'new' | 'learning' | 'review' | 'relearning';
  stability: number;
  difficulty: number;
  elapsedDays: number;
  scheduledDays: number;
  reps: number;
  lapses: number;
}

export type StudySession = DrizzleStudySession;

================
File: lib/utils.ts
================
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function formatDate(date: Date): string {
  return date.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric'
  });
}

export function formatTimestamp(timestamp: number | null): string {
  if (!timestamp) return 'Not reviewed yet';
  return `Last reviewed ${formatDate(new Date(timestamp))}`;
}

export function formatStudyTime(minutes: number) {
  return {
    hours: Math.floor(minutes / 60),
    minutes: Math.floor(minutes % 60)
  };
}

export function formatTimeString(time: { hours: number; minutes: number }): string {
  return `${time.hours}h ${time.minutes}m`;
}

export function calculateDueDate(
  interval: number,
  easeFactor: number,
  lastReviewed: number | null = null
): number {
  if (!lastReviewed) return Date.now();
  
  const nextInterval = Math.round(interval * (easeFactor / 100));
  return lastReviewed + (nextInterval * 24 * 60 * 60 * 1000);
}

export function getDueStatus(nextReview: number | null): 'due' | 'today' | 'future' {
  if (!nextReview) return 'due';
  
  const now = Date.now();
  const tomorrow = now + (24 * 60 * 60 * 1000);
  
  if (nextReview <= now) return 'due';
  if (nextReview <= tomorrow) return 'today';
  return 'future';
}

export function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  
  if (hours > 0) {
    return `${hours}h ${minutes % 60}m`;
  }
  if (minutes > 0) {
    return `${minutes}m ${seconds % 60}s`;
  }
  return `${seconds}s`;
}

export function shuffle<T>(array: T[]): T[] {
  const newArray = [...array];
  for (let i = newArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
}

export function calculateRetentionScore(
  stability: number,
  difficulty: number,
  elapsed: number
): number {
  // Using the FSRS retention score formula
  const retention = Math.exp(Math.log(0.9) * elapsed / stability);
  return Math.min(Math.max(retention * (1.0 - difficulty / 10.0), 0), 1);
}

export function getReviewIntervals(stability: number): {
  again: number;
  hard: number;
  good: number;
  easy: number;
} {
  // Calculate intervals based on FSRS algorithm
  const again = Math.max(1, Math.round(stability * 0.2));
  const hard = Math.max(1, Math.round(stability * 0.8));
  const good = Math.max(1, Math.round(stability * 1.0));
  const easy = Math.max(1, Math.round(stability * 1.3));

  return { again, hard, good, easy };
}

export function formatInterval(days: number): string {
  if (days === 0) return 'Same day';
  if (days === 1) return 'Tomorrow';
  
  const months = Math.floor(days / 30);
  const remainingDays = days % 30;
  
  if (months > 0) {
    if (remainingDays === 0) {
      return `${months} month${months > 1 ? 's' : ''}`;
    }
    return `${months} month${months > 1 ? 's' : ''} ${remainingDays} day${remainingDays > 1 ? 's' : ''}`;
  }
  
  return `${days} day${days > 1 ? 's' : ''}`;
}

export function getGradingButtonColors(grade: 'again' | 'hard' | 'good' | 'easy') {
  const colors = {
    again: {
      base: 'border-red-200 dark:border-red-500/20',
      hover: 'hover:border-red-300 dark:hover:border-red-500/30',
      text: 'text-red-600 dark:text-red-400',
    },
    hard: {
      base: 'border-yellow-200 dark:border-yellow-500/20',
      hover: 'hover:border-yellow-300 dark:hover:border-yellow-500/30',
      text: 'text-yellow-600 dark:text-yellow-400',
    },
    good: {
      base: 'border-green-200 dark:border-green-500/20',
      hover: 'hover:border-green-300 dark:hover:border-green-500/30',
      text: 'text-green-600 dark:text-green-400',
    },
    easy: {
      base: 'border-blue-200 dark:border-blue-500/20',
      hover: 'hover:border-blue-300 dark:hover:border-blue-500/30',
      text: 'text-blue-600 dark:text-blue-400',
    },
  };

  return colors[grade];
}

export function calculateStreak(studyDates: Date[]): number {
  if (!studyDates.length) return 0;

  const sortedDates = studyDates
    .map(date => new Date(date).setHours(0, 0, 0, 0))
    .sort((a, b) => b - a);

  let streak = 1;
  let currentDate = sortedDates[0];
  const oneDayMs = 24 * 60 * 60 * 1000;

  for (let i = 1; i < sortedDates.length; i++) {
    const prevDate = currentDate;
    currentDate = sortedDates[i];
    
    if (prevDate - currentDate === oneDayMs) {
      streak++;
    } else {
      break;
    }
  }

  return streak;
}

export function getStudyGoalProgress(
  cardsStudied: number,
  dailyGoal: number
): {
  progress: number;
  status: 'behind' | 'on-track' | 'ahead';
  remaining: number;
} {
  const progress = Math.min((cardsStudied / dailyGoal) * 100, 100);
  const remaining = Math.max(dailyGoal - cardsStudied, 0);
  
  let status: 'behind' | 'on-track' | 'ahead';
  if (progress >= 100) {
    status = 'ahead';
  } else if (progress >= 80) {
    status = 'on-track';
  } else {
    status = 'behind';
  }

  return { progress, status, remaining };
}

export function generateReviewSchedule(
  cards: Array<{ nextReview: number | null; difficulty: number }>
): Array<{ date: Date; count: number }> {
  const schedule: Map<number, number> = new Map();
  const now = Date.now();
  const thirtyDaysMs = 30 * 24 * 60 * 60 * 1000;

  cards.forEach(card => {
    if (!card.nextReview) return;
    
    const reviewDate = new Date(card.nextReview);
    const dateKey = reviewDate.setHours(0, 0, 0, 0);
    
    if (dateKey >= now && dateKey <= now + thirtyDaysMs) {
      schedule.set(dateKey, (schedule.get(dateKey) || 0) + 1);
    }
  });

  return Array.from(schedule.entries())
    .map(([date, count]) => ({
      date: new Date(date),
      count
    }))
    .sort((a, b) => a.date.getTime() - b.date.getTime());
}

export function sanitizeHtml(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout;

  return function executedFunction(...args: Parameters<T>) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };

    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

export function throttle<T extends (...args: any[]) => any>(
  func: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle: boolean;
  
  return function(...args: Parameters<T>) {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  }
}

================
File: migrations/meta/_journal.json
================
{
  "version": "5",
  "dialect": "sqlite",
  "entries": [
    {
      "idx": 0,
      "version": "5",
      "when": 1730030342142,
      "tag": "0000_low_silver_fox",
      "breakpoints": true
    },
    {
      "idx": 1,
      "version": "5",
      "when": 1730204801029,
      "tag": "0001_outstanding_typhoid_mary",
      "breakpoints": true
    },
    {
      "idx": 2,
      "version": "5",
      "when": 1730216968479,
      "tag": "0002_cold_quentin_quire",
      "breakpoints": true
    },
    {
      "idx": 3,
      "version": "5",
      "when": 1730376324967,
      "tag": "0003_chubby_morph",
      "breakpoints": true
    },
    {
      "idx": 4,
      "version": "5",
      "when": 1730376694624,
      "tag": "0004_supreme_rocket_raccoon",
      "breakpoints": true
    },
    {
      "idx": 5,
      "version": "5",
      "when": 1730389431785,
      "tag": "0005_striped_ultron",
      "breakpoints": true
    },
    {
      "idx": 6,
      "version": "5",
      "when": 1730556322281,
      "tag": "0006_condemned_terror",
      "breakpoints": true
    }
  ]
}

================
File: migrations/meta/0000_snapshot.json
================
{
  "version": "5",
  "dialect": "sqlite",
  "id": "96f46dd7-7941-4d27-82a3-bd6ec16c68f3",
  "prevId": "00000000-0000-0000-0000-000000000000",
  "tables": {
    "account": {
      "name": "account",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "type": {
          "name": "type",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "provider": {
          "name": "provider",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "providerAccountId": {
          "name": "providerAccountId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "refresh_token": {
          "name": "refresh_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "access_token": {
          "name": "access_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "expires_at": {
          "name": "expires_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "token_type": {
          "name": "token_type",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "scope": {
          "name": "scope",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "id_token": {
          "name": "id_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "session_state": {
          "name": "session_state",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "account_userId_user_id_fk": {
          "name": "account_userId_user_id_fk",
          "tableFrom": "account",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "deck": {
      "name": "deck",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "title": {
          "name": "title",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "deck_user_id_user_id_fk": {
          "name": "deck_user_id_user_id_fk",
          "tableFrom": "deck",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "flashcard": {
      "name": "flashcard",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "deck_id": {
          "name": "deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "front": {
          "name": "front",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "back": {
          "name": "back",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "last_reviewed": {
          "name": "last_reviewed",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "next_review": {
          "name": "next_review",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "ease_factor": {
          "name": "ease_factor",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 250
        },
        "interval": {
          "name": "interval",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        }
      },
      "indexes": {},
      "foreignKeys": {
        "flashcard_deck_id_deck_id_fk": {
          "name": "flashcard_deck_id_deck_id_fk",
          "tableFrom": "flashcard",
          "tableTo": "deck",
          "columnsFrom": [
            "deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "study_session": {
      "name": "study_session",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "cards_studied": {
          "name": "cards_studied",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "start_time": {
          "name": "start_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "end_time": {
          "name": "end_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "study_session_user_id_user_id_fk": {
          "name": "study_session_user_id_user_id_fk",
          "tableFrom": "study_session",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "user": {
      "name": "user",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "email": {
          "name": "email",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "emailVerified": {
          "name": "emailVerified",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "image": {
          "name": "image",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "user_email_unique": {
          "name": "user_email_unique",
          "columns": [
            "email"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  }
}

================
File: migrations/meta/0001_snapshot.json
================
{
  "version": "5",
  "dialect": "sqlite",
  "id": "4800a2b7-8301-4e72-afc2-14102281288f",
  "prevId": "96f46dd7-7941-4d27-82a3-bd6ec16c68f3",
  "tables": {
    "account": {
      "name": "account",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "type": {
          "name": "type",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "provider": {
          "name": "provider",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "providerAccountId": {
          "name": "providerAccountId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "refresh_token": {
          "name": "refresh_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "access_token": {
          "name": "access_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "expires_at": {
          "name": "expires_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "token_type": {
          "name": "token_type",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "scope": {
          "name": "scope",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "id_token": {
          "name": "id_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "session_state": {
          "name": "session_state",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "account_userId_user_id_fk": {
          "name": "account_userId_user_id_fk",
          "tableFrom": "account",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "deck": {
      "name": "deck",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "title": {
          "name": "title",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "deck_user_id_user_id_fk": {
          "name": "deck_user_id_user_id_fk",
          "tableFrom": "deck",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "flashcard": {
      "name": "flashcard",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "deck_id": {
          "name": "deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "front": {
          "name": "front",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "back": {
          "name": "back",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "audio": {
          "name": "audio",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "last_reviewed": {
          "name": "last_reviewed",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "next_review": {
          "name": "next_review",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "state": {
          "name": "state",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'new'"
        },
        "stability": {
          "name": "stability",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        },
        "difficulty": {
          "name": "difficulty",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 5
        },
        "elapsed_days": {
          "name": "elapsed_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "scheduled_days": {
          "name": "scheduled_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "reps": {
          "name": "reps",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "lapses": {
          "name": "lapses",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "interval": {
          "name": "interval",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "ease_factor": {
          "name": "ease_factor",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 250
        }
      },
      "indexes": {},
      "foreignKeys": {
        "flashcard_deck_id_deck_id_fk": {
          "name": "flashcard_deck_id_deck_id_fk",
          "tableFrom": "flashcard",
          "tableTo": "deck",
          "columnsFrom": [
            "deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "review_log": {
      "name": "review_log",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "flashcard_id": {
          "name": "flashcard_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "rating": {
          "name": "rating",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "reviewed_at": {
          "name": "reviewed_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "stability": {
          "name": "stability",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "difficulty": {
          "name": "difficulty",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "elapsed_days": {
          "name": "elapsed_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "scheduled_days": {
          "name": "scheduled_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "response_time": {
          "name": "response_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "review_log_user_id_user_id_fk": {
          "name": "review_log_user_id_user_id_fk",
          "tableFrom": "review_log",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "review_log_flashcard_id_flashcard_id_fk": {
          "name": "review_log_flashcard_id_flashcard_id_fk",
          "tableFrom": "review_log",
          "tableTo": "flashcard",
          "columnsFrom": [
            "flashcard_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "study_session": {
      "name": "study_session",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "cards_studied": {
          "name": "cards_studied",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "start_time": {
          "name": "start_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "end_time": {
          "name": "end_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "correct_count": {
          "name": "correct_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "incorrect_count": {
          "name": "incorrect_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "average_time": {
          "name": "average_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        }
      },
      "indexes": {},
      "foreignKeys": {
        "study_session_user_id_user_id_fk": {
          "name": "study_session_user_id_user_id_fk",
          "tableFrom": "study_session",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "user": {
      "name": "user",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "email": {
          "name": "email",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "emailVerified": {
          "name": "emailVerified",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "image": {
          "name": "image",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "user_email_unique": {
          "name": "user_email_unique",
          "columns": [
            "email"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  }
}

================
File: migrations/meta/0002_snapshot.json
================
{
  "version": "5",
  "dialect": "sqlite",
  "id": "07e05080-6c26-40af-82f7-aeb6baf1dbb7",
  "prevId": "4800a2b7-8301-4e72-afc2-14102281288f",
  "tables": {
    "account": {
      "name": "account",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "type": {
          "name": "type",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "provider": {
          "name": "provider",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "providerAccountId": {
          "name": "providerAccountId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "refresh_token": {
          "name": "refresh_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "access_token": {
          "name": "access_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "expires_at": {
          "name": "expires_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "token_type": {
          "name": "token_type",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "scope": {
          "name": "scope",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "id_token": {
          "name": "id_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "session_state": {
          "name": "session_state",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "account_userId_user_id_fk": {
          "name": "account_userId_user_id_fk",
          "tableFrom": "account",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "deck": {
      "name": "deck",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "title": {
          "name": "title",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "deck_user_id_user_id_fk": {
          "name": "deck_user_id_user_id_fk",
          "tableFrom": "deck",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "deck_comment": {
      "name": "deck_comment",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "shared_deck_id": {
          "name": "shared_deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "content": {
          "name": "content",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "deck_comment_shared_deck_id_shared_deck_id_fk": {
          "name": "deck_comment_shared_deck_id_shared_deck_id_fk",
          "tableFrom": "deck_comment",
          "tableTo": "shared_deck",
          "columnsFrom": [
            "shared_deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "deck_comment_user_id_user_id_fk": {
          "name": "deck_comment_user_id_user_id_fk",
          "tableFrom": "deck_comment",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "deck_rating": {
      "name": "deck_rating",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "shared_deck_id": {
          "name": "shared_deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "rating": {
          "name": "rating",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "deck_rating_shared_deck_id_shared_deck_id_fk": {
          "name": "deck_rating_shared_deck_id_shared_deck_id_fk",
          "tableFrom": "deck_rating",
          "tableTo": "shared_deck",
          "columnsFrom": [
            "shared_deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "deck_rating_user_id_user_id_fk": {
          "name": "deck_rating_user_id_user_id_fk",
          "tableFrom": "deck_rating",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "flashcard": {
      "name": "flashcard",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "deck_id": {
          "name": "deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "front": {
          "name": "front",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "back": {
          "name": "back",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "audio": {
          "name": "audio",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "last_reviewed": {
          "name": "last_reviewed",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "next_review": {
          "name": "next_review",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "state": {
          "name": "state",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'new'"
        },
        "stability": {
          "name": "stability",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        },
        "difficulty": {
          "name": "difficulty",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 5
        },
        "elapsed_days": {
          "name": "elapsed_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "scheduled_days": {
          "name": "scheduled_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "reps": {
          "name": "reps",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "lapses": {
          "name": "lapses",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "interval": {
          "name": "interval",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "ease_factor": {
          "name": "ease_factor",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 250
        }
      },
      "indexes": {},
      "foreignKeys": {
        "flashcard_deck_id_deck_id_fk": {
          "name": "flashcard_deck_id_deck_id_fk",
          "tableFrom": "flashcard",
          "tableTo": "deck",
          "columnsFrom": [
            "deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "review_log": {
      "name": "review_log",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "flashcard_id": {
          "name": "flashcard_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "rating": {
          "name": "rating",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "reviewed_at": {
          "name": "reviewed_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "stability": {
          "name": "stability",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "difficulty": {
          "name": "difficulty",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "elapsed_days": {
          "name": "elapsed_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "scheduled_days": {
          "name": "scheduled_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "response_time": {
          "name": "response_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "review_log_user_id_user_id_fk": {
          "name": "review_log_user_id_user_id_fk",
          "tableFrom": "review_log",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "review_log_flashcard_id_flashcard_id_fk": {
          "name": "review_log_flashcard_id_flashcard_id_fk",
          "tableFrom": "review_log",
          "tableTo": "flashcard",
          "columnsFrom": [
            "flashcard_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "shared_deck": {
      "name": "shared_deck",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "original_deck_id": {
          "name": "original_deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "title": {
          "name": "title",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "downloads": {
          "name": "downloads",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "is_public": {
          "name": "is_public",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": true
        }
      },
      "indexes": {},
      "foreignKeys": {
        "shared_deck_original_deck_id_deck_id_fk": {
          "name": "shared_deck_original_deck_id_deck_id_fk",
          "tableFrom": "shared_deck",
          "tableTo": "deck",
          "columnsFrom": [
            "original_deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "shared_deck_user_id_user_id_fk": {
          "name": "shared_deck_user_id_user_id_fk",
          "tableFrom": "shared_deck",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "study_session": {
      "name": "study_session",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "cards_studied": {
          "name": "cards_studied",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "start_time": {
          "name": "start_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "end_time": {
          "name": "end_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "correct_count": {
          "name": "correct_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "incorrect_count": {
          "name": "incorrect_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "average_time": {
          "name": "average_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        }
      },
      "indexes": {},
      "foreignKeys": {
        "study_session_user_id_user_id_fk": {
          "name": "study_session_user_id_user_id_fk",
          "tableFrom": "study_session",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "user": {
      "name": "user",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "email": {
          "name": "email",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "emailVerified": {
          "name": "emailVerified",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "image": {
          "name": "image",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "user_email_unique": {
          "name": "user_email_unique",
          "columns": [
            "email"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  }
}

================
File: migrations/meta/0003_snapshot.json
================
{
  "version": "5",
  "dialect": "sqlite",
  "id": "d209e998-27fc-40ea-a613-efbf556de79f",
  "prevId": "07e05080-6c26-40af-82f7-aeb6baf1dbb7",
  "tables": {
    "account": {
      "name": "account",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "type": {
          "name": "type",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "provider": {
          "name": "provider",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "providerAccountId": {
          "name": "providerAccountId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "refresh_token": {
          "name": "refresh_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "access_token": {
          "name": "access_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "expires_at": {
          "name": "expires_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "token_type": {
          "name": "token_type",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "scope": {
          "name": "scope",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "id_token": {
          "name": "id_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "session_state": {
          "name": "session_state",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "account_userId_user_id_fk": {
          "name": "account_userId_user_id_fk",
          "tableFrom": "account",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "deck": {
      "name": "deck",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "title": {
          "name": "title",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "original_shared_deck_id": {
          "name": "original_shared_deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "deck_user_id_user_id_fk": {
          "name": "deck_user_id_user_id_fk",
          "tableFrom": "deck",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "deck_comment": {
      "name": "deck_comment",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "shared_deck_id": {
          "name": "shared_deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "content": {
          "name": "content",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "deck_comment_shared_deck_id_shared_deck_id_fk": {
          "name": "deck_comment_shared_deck_id_shared_deck_id_fk",
          "tableFrom": "deck_comment",
          "tableTo": "shared_deck",
          "columnsFrom": [
            "shared_deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "deck_comment_user_id_user_id_fk": {
          "name": "deck_comment_user_id_user_id_fk",
          "tableFrom": "deck_comment",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "deck_rating": {
      "name": "deck_rating",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "shared_deck_id": {
          "name": "shared_deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "rating": {
          "name": "rating",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "deck_rating_shared_deck_id_shared_deck_id_fk": {
          "name": "deck_rating_shared_deck_id_shared_deck_id_fk",
          "tableFrom": "deck_rating",
          "tableTo": "shared_deck",
          "columnsFrom": [
            "shared_deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "deck_rating_user_id_user_id_fk": {
          "name": "deck_rating_user_id_user_id_fk",
          "tableFrom": "deck_rating",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "flashcard": {
      "name": "flashcard",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "deck_id": {
          "name": "deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "front": {
          "name": "front",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "back": {
          "name": "back",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "audio": {
          "name": "audio",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "last_reviewed": {
          "name": "last_reviewed",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "next_review": {
          "name": "next_review",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "state": {
          "name": "state",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'new'"
        },
        "stability": {
          "name": "stability",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        },
        "difficulty": {
          "name": "difficulty",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 5
        },
        "elapsed_days": {
          "name": "elapsed_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "scheduled_days": {
          "name": "scheduled_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "reps": {
          "name": "reps",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "lapses": {
          "name": "lapses",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "interval": {
          "name": "interval",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "ease_factor": {
          "name": "ease_factor",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 250
        }
      },
      "indexes": {},
      "foreignKeys": {
        "flashcard_deck_id_deck_id_fk": {
          "name": "flashcard_deck_id_deck_id_fk",
          "tableFrom": "flashcard",
          "tableTo": "deck",
          "columnsFrom": [
            "deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "shared_deck": {
      "name": "shared_deck",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "original_deck_id": {
          "name": "original_deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "title": {
          "name": "title",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "downloads": {
          "name": "downloads",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "is_public": {
          "name": "is_public",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": true
        }
      },
      "indexes": {},
      "foreignKeys": {
        "shared_deck_original_deck_id_deck_id_fk": {
          "name": "shared_deck_original_deck_id_deck_id_fk",
          "tableFrom": "shared_deck",
          "tableTo": "deck",
          "columnsFrom": [
            "original_deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "shared_deck_user_id_user_id_fk": {
          "name": "shared_deck_user_id_user_id_fk",
          "tableFrom": "shared_deck",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "user": {
      "name": "user",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "email": {
          "name": "email",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "emailVerified": {
          "name": "emailVerified",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "image": {
          "name": "image",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "user_email_unique": {
          "name": "user_email_unique",
          "columns": [
            "email"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  }
}

================
File: migrations/meta/0004_snapshot.json
================
{
  "version": "5",
  "dialect": "sqlite",
  "id": "87faf853-8869-4741-aa96-71b2513df8f8",
  "prevId": "d209e998-27fc-40ea-a613-efbf556de79f",
  "tables": {
    "account": {
      "name": "account",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "type": {
          "name": "type",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "provider": {
          "name": "provider",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "providerAccountId": {
          "name": "providerAccountId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "refresh_token": {
          "name": "refresh_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "access_token": {
          "name": "access_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "expires_at": {
          "name": "expires_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "token_type": {
          "name": "token_type",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "scope": {
          "name": "scope",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "id_token": {
          "name": "id_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "session_state": {
          "name": "session_state",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "account_userId_user_id_fk": {
          "name": "account_userId_user_id_fk",
          "tableFrom": "account",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "deck": {
      "name": "deck",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "title": {
          "name": "title",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "original_shared_deck_id": {
          "name": "original_shared_deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "deck_comment": {
      "name": "deck_comment",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "shared_deck_id": {
          "name": "shared_deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "content": {
          "name": "content",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "deck_comment_shared_deck_id_shared_deck_id_fk": {
          "name": "deck_comment_shared_deck_id_shared_deck_id_fk",
          "tableFrom": "deck_comment",
          "tableTo": "shared_deck",
          "columnsFrom": [
            "shared_deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "deck_comment_user_id_user_id_fk": {
          "name": "deck_comment_user_id_user_id_fk",
          "tableFrom": "deck_comment",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "deck_rating": {
      "name": "deck_rating",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "shared_deck_id": {
          "name": "shared_deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "rating": {
          "name": "rating",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "deck_rating_shared_deck_id_shared_deck_id_fk": {
          "name": "deck_rating_shared_deck_id_shared_deck_id_fk",
          "tableFrom": "deck_rating",
          "tableTo": "shared_deck",
          "columnsFrom": [
            "shared_deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "deck_rating_user_id_user_id_fk": {
          "name": "deck_rating_user_id_user_id_fk",
          "tableFrom": "deck_rating",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "flashcard": {
      "name": "flashcard",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "deck_id": {
          "name": "deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "front": {
          "name": "front",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "back": {
          "name": "back",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "audio": {
          "name": "audio",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "last_reviewed": {
          "name": "last_reviewed",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "next_review": {
          "name": "next_review",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "state": {
          "name": "state",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'new'"
        },
        "stability": {
          "name": "stability",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        },
        "difficulty": {
          "name": "difficulty",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 5
        },
        "elapsed_days": {
          "name": "elapsed_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "scheduled_days": {
          "name": "scheduled_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "reps": {
          "name": "reps",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "lapses": {
          "name": "lapses",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "interval": {
          "name": "interval",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "ease_factor": {
          "name": "ease_factor",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 250
        }
      },
      "indexes": {},
      "foreignKeys": {
        "flashcard_deck_id_deck_id_fk": {
          "name": "flashcard_deck_id_deck_id_fk",
          "tableFrom": "flashcard",
          "tableTo": "deck",
          "columnsFrom": [
            "deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "review_log": {
      "name": "review_log",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "flashcard_id": {
          "name": "flashcard_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "rating": {
          "name": "rating",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "reviewed_at": {
          "name": "reviewed_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "stability": {
          "name": "stability",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "difficulty": {
          "name": "difficulty",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "elapsed_days": {
          "name": "elapsed_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "scheduled_days": {
          "name": "scheduled_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "response_time": {
          "name": "response_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "review_log_user_id_user_id_fk": {
          "name": "review_log_user_id_user_id_fk",
          "tableFrom": "review_log",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "review_log_flashcard_id_flashcard_id_fk": {
          "name": "review_log_flashcard_id_flashcard_id_fk",
          "tableFrom": "review_log",
          "tableTo": "flashcard",
          "columnsFrom": [
            "flashcard_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "shared_deck": {
      "name": "shared_deck",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "original_deck_id": {
          "name": "original_deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "title": {
          "name": "title",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "downloads": {
          "name": "downloads",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "is_public": {
          "name": "is_public",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": true
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "study_session": {
      "name": "study_session",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "cards_studied": {
          "name": "cards_studied",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "start_time": {
          "name": "start_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "end_time": {
          "name": "end_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "correct_count": {
          "name": "correct_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "incorrect_count": {
          "name": "incorrect_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "average_time": {
          "name": "average_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        }
      },
      "indexes": {},
      "foreignKeys": {
        "study_session_user_id_user_id_fk": {
          "name": "study_session_user_id_user_id_fk",
          "tableFrom": "study_session",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "user": {
      "name": "user",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "email": {
          "name": "email",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "emailVerified": {
          "name": "emailVerified",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "image": {
          "name": "image",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "user_email_unique": {
          "name": "user_email_unique",
          "columns": [
            "email"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  }
}

================
File: migrations/meta/0005_snapshot.json
================
{
  "version": "5",
  "dialect": "sqlite",
  "id": "314a6599-2333-44f9-a32b-3e733fe98b01",
  "prevId": "87faf853-8869-4741-aa96-71b2513df8f8",
  "tables": {
    "account": {
      "name": "account",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "type": {
          "name": "type",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "provider": {
          "name": "provider",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "providerAccountId": {
          "name": "providerAccountId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "refresh_token": {
          "name": "refresh_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "access_token": {
          "name": "access_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "expires_at": {
          "name": "expires_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "token_type": {
          "name": "token_type",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "scope": {
          "name": "scope",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "id_token": {
          "name": "id_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "session_state": {
          "name": "session_state",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "account_userId_user_id_fk": {
          "name": "account_userId_user_id_fk",
          "tableFrom": "account",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "deck": {
      "name": "deck",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "title": {
          "name": "title",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "original_shared_deck_id": {
          "name": "original_shared_deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "deck_user_id_user_id_fk": {
          "name": "deck_user_id_user_id_fk",
          "tableFrom": "deck",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "deck_comment": {
      "name": "deck_comment",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "shared_deck_id": {
          "name": "shared_deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "content": {
          "name": "content",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "deck_comment_shared_deck_id_shared_deck_id_fk": {
          "name": "deck_comment_shared_deck_id_shared_deck_id_fk",
          "tableFrom": "deck_comment",
          "tableTo": "shared_deck",
          "columnsFrom": [
            "shared_deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "deck_comment_user_id_user_id_fk": {
          "name": "deck_comment_user_id_user_id_fk",
          "tableFrom": "deck_comment",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "deck_label": {
      "name": "deck_label",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "deck_id": {
          "name": "deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "label_id": {
          "name": "label_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "deck_label_deck_id_deck_id_fk": {
          "name": "deck_label_deck_id_deck_id_fk",
          "tableFrom": "deck_label",
          "tableTo": "deck",
          "columnsFrom": [
            "deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "deck_label_label_id_label_id_fk": {
          "name": "deck_label_label_id_label_id_fk",
          "tableFrom": "deck_label",
          "tableTo": "label",
          "columnsFrom": [
            "label_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "deck_rating": {
      "name": "deck_rating",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "shared_deck_id": {
          "name": "shared_deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "rating": {
          "name": "rating",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "deck_rating_shared_deck_id_shared_deck_id_fk": {
          "name": "deck_rating_shared_deck_id_shared_deck_id_fk",
          "tableFrom": "deck_rating",
          "tableTo": "shared_deck",
          "columnsFrom": [
            "shared_deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "deck_rating_user_id_user_id_fk": {
          "name": "deck_rating_user_id_user_id_fk",
          "tableFrom": "deck_rating",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "flashcard": {
      "name": "flashcard",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "deck_id": {
          "name": "deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "front": {
          "name": "front",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "back": {
          "name": "back",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "audio": {
          "name": "audio",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "last_reviewed": {
          "name": "last_reviewed",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "next_review": {
          "name": "next_review",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "state": {
          "name": "state",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'new'"
        },
        "stability": {
          "name": "stability",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        },
        "difficulty": {
          "name": "difficulty",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 5
        },
        "elapsed_days": {
          "name": "elapsed_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "scheduled_days": {
          "name": "scheduled_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "reps": {
          "name": "reps",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "lapses": {
          "name": "lapses",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "interval": {
          "name": "interval",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "ease_factor": {
          "name": "ease_factor",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 250
        }
      },
      "indexes": {},
      "foreignKeys": {
        "flashcard_deck_id_deck_id_fk": {
          "name": "flashcard_deck_id_deck_id_fk",
          "tableFrom": "flashcard",
          "tableTo": "deck",
          "columnsFrom": [
            "deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "label": {
      "name": "label",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "review_log": {
      "name": "review_log",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "flashcard_id": {
          "name": "flashcard_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "rating": {
          "name": "rating",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "reviewed_at": {
          "name": "reviewed_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "stability": {
          "name": "stability",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "difficulty": {
          "name": "difficulty",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "elapsed_days": {
          "name": "elapsed_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "scheduled_days": {
          "name": "scheduled_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "response_time": {
          "name": "response_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "review_log_user_id_user_id_fk": {
          "name": "review_log_user_id_user_id_fk",
          "tableFrom": "review_log",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "review_log_flashcard_id_flashcard_id_fk": {
          "name": "review_log_flashcard_id_flashcard_id_fk",
          "tableFrom": "review_log",
          "tableTo": "flashcard",
          "columnsFrom": [
            "flashcard_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "shared_deck": {
      "name": "shared_deck",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "original_deck_id": {
          "name": "original_deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "title": {
          "name": "title",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "downloads": {
          "name": "downloads",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "is_public": {
          "name": "is_public",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": true
        }
      },
      "indexes": {},
      "foreignKeys": {
        "shared_deck_original_deck_id_deck_id_fk": {
          "name": "shared_deck_original_deck_id_deck_id_fk",
          "tableFrom": "shared_deck",
          "tableTo": "deck",
          "columnsFrom": [
            "original_deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "shared_deck_user_id_user_id_fk": {
          "name": "shared_deck_user_id_user_id_fk",
          "tableFrom": "shared_deck",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "study_session": {
      "name": "study_session",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "cards_studied": {
          "name": "cards_studied",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "start_time": {
          "name": "start_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "end_time": {
          "name": "end_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "correct_count": {
          "name": "correct_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "incorrect_count": {
          "name": "incorrect_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "average_time": {
          "name": "average_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        }
      },
      "indexes": {},
      "foreignKeys": {
        "study_session_user_id_user_id_fk": {
          "name": "study_session_user_id_user_id_fk",
          "tableFrom": "study_session",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "user": {
      "name": "user",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "email": {
          "name": "email",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "emailVerified": {
          "name": "emailVerified",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "image": {
          "name": "image",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "user_email_unique": {
          "name": "user_email_unique",
          "columns": [
            "email"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  }
}

================
File: migrations/meta/0006_snapshot.json
================
{
  "version": "5",
  "dialect": "sqlite",
  "id": "4d869a66-6bd9-481a-8127-36ac901e053a",
  "prevId": "314a6599-2333-44f9-a32b-3e733fe98b01",
  "tables": {
    "account": {
      "name": "account",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "type": {
          "name": "type",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "provider": {
          "name": "provider",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "providerAccountId": {
          "name": "providerAccountId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "refresh_token": {
          "name": "refresh_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "access_token": {
          "name": "access_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "expires_at": {
          "name": "expires_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "token_type": {
          "name": "token_type",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "scope": {
          "name": "scope",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "id_token": {
          "name": "id_token",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "session_state": {
          "name": "session_state",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "account_userId_user_id_fk": {
          "name": "account_userId_user_id_fk",
          "tableFrom": "account",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "deck": {
      "name": "deck",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "title": {
          "name": "title",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "original_shared_deck_id": {
          "name": "original_shared_deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "deck_user_id_user_id_fk": {
          "name": "deck_user_id_user_id_fk",
          "tableFrom": "deck",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "deck_comment": {
      "name": "deck_comment",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "shared_deck_id": {
          "name": "shared_deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "content": {
          "name": "content",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "deck_comment_shared_deck_id_shared_deck_id_fk": {
          "name": "deck_comment_shared_deck_id_shared_deck_id_fk",
          "tableFrom": "deck_comment",
          "tableTo": "shared_deck",
          "columnsFrom": [
            "shared_deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "deck_comment_user_id_user_id_fk": {
          "name": "deck_comment_user_id_user_id_fk",
          "tableFrom": "deck_comment",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "deck_label": {
      "name": "deck_label",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "deck_id": {
          "name": "deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "label_id": {
          "name": "label_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "deck_label_deck_id_deck_id_fk": {
          "name": "deck_label_deck_id_deck_id_fk",
          "tableFrom": "deck_label",
          "tableTo": "deck",
          "columnsFrom": [
            "deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "deck_label_label_id_label_id_fk": {
          "name": "deck_label_label_id_label_id_fk",
          "tableFrom": "deck_label",
          "tableTo": "label",
          "columnsFrom": [
            "label_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "deck_rating": {
      "name": "deck_rating",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "shared_deck_id": {
          "name": "shared_deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "rating": {
          "name": "rating",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "deck_rating_shared_deck_id_shared_deck_id_fk": {
          "name": "deck_rating_shared_deck_id_shared_deck_id_fk",
          "tableFrom": "deck_rating",
          "tableTo": "shared_deck",
          "columnsFrom": [
            "shared_deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "deck_rating_user_id_user_id_fk": {
          "name": "deck_rating_user_id_user_id_fk",
          "tableFrom": "deck_rating",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "flashcard": {
      "name": "flashcard",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "deck_id": {
          "name": "deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "front": {
          "name": "front",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "back": {
          "name": "back",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "audio": {
          "name": "audio",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "last_reviewed": {
          "name": "last_reviewed",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "next_review": {
          "name": "next_review",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "state": {
          "name": "state",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'new'"
        },
        "stability": {
          "name": "stability",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        },
        "difficulty": {
          "name": "difficulty",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 5
        },
        "elapsed_days": {
          "name": "elapsed_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "scheduled_days": {
          "name": "scheduled_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "reps": {
          "name": "reps",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "lapses": {
          "name": "lapses",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "interval": {
          "name": "interval",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "ease_factor": {
          "name": "ease_factor",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 250
        }
      },
      "indexes": {},
      "foreignKeys": {
        "flashcard_deck_id_deck_id_fk": {
          "name": "flashcard_deck_id_deck_id_fk",
          "tableFrom": "flashcard",
          "tableTo": "deck",
          "columnsFrom": [
            "deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "label": {
      "name": "label",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "review_log": {
      "name": "review_log",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "flashcard_id": {
          "name": "flashcard_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "rating": {
          "name": "rating",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "reviewed_at": {
          "name": "reviewed_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "stability": {
          "name": "stability",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "difficulty": {
          "name": "difficulty",
          "type": "real",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "elapsed_days": {
          "name": "elapsed_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "scheduled_days": {
          "name": "scheduled_days",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "response_time": {
          "name": "response_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "review_log_user_id_user_id_fk": {
          "name": "review_log_user_id_user_id_fk",
          "tableFrom": "review_log",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "review_log_flashcard_id_flashcard_id_fk": {
          "name": "review_log_flashcard_id_flashcard_id_fk",
          "tableFrom": "review_log",
          "tableTo": "flashcard",
          "columnsFrom": [
            "flashcard_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "shared_deck": {
      "name": "shared_deck",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "original_deck_id": {
          "name": "original_deck_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "title": {
          "name": "title",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "downloads": {
          "name": "downloads",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "is_public": {
          "name": "is_public",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": true
        }
      },
      "indexes": {},
      "foreignKeys": {
        "shared_deck_original_deck_id_deck_id_fk": {
          "name": "shared_deck_original_deck_id_deck_id_fk",
          "tableFrom": "shared_deck",
          "tableTo": "deck",
          "columnsFrom": [
            "original_deck_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        },
        "shared_deck_user_id_user_id_fk": {
          "name": "shared_deck_user_id_user_id_fk",
          "tableFrom": "shared_deck",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "study_session": {
      "name": "study_session",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "cards_studied": {
          "name": "cards_studied",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "start_time": {
          "name": "start_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "end_time": {
          "name": "end_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "correct_count": {
          "name": "correct_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "incorrect_count": {
          "name": "incorrect_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "average_time": {
          "name": "average_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        }
      },
      "indexes": {},
      "foreignKeys": {
        "study_session_user_id_user_id_fk": {
          "name": "study_session_user_id_user_id_fk",
          "tableFrom": "study_session",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "user": {
      "name": "user",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "email": {
          "name": "email",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "emailVerified": {
          "name": "emailVerified",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "image": {
          "name": "image",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "user_email_unique": {
          "name": "user_email_unique",
          "columns": [
            "email"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "user_rate_limit": {
      "name": "user_rate_limit",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "translation_count": {
          "name": "translation_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "translation_reset_time": {
          "name": "translation_reset_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "daily_count": {
          "name": "daily_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "daily_reset_time": {
          "name": "daily_reset_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "monthly_count": {
          "name": "monthly_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "monthly_reset_time": {
          "name": "monthly_reset_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "last_updated": {
          "name": "last_updated",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "user_rate_limit_user_id_user_id_fk": {
          "name": "user_rate_limit_user_id_user_id_fk",
          "tableFrom": "user_rate_limit",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "cascade",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  }
}

================
File: migrations/0000_low_silver_fox.sql
================
CREATE TABLE `account` (
	`id` text PRIMARY KEY NOT NULL,
	`userId` text NOT NULL,
	`type` text NOT NULL,
	`provider` text NOT NULL,
	`providerAccountId` text NOT NULL,
	`refresh_token` text,
	`access_token` text,
	`expires_at` integer,
	`token_type` text,
	`scope` text,
	`id_token` text,
	`session_state` text,
	FOREIGN KEY (`userId`) REFERENCES `user`(`id`) ON UPDATE no action ON DELETE cascade
);
--> statement-breakpoint
CREATE TABLE `deck` (
	`id` text PRIMARY KEY NOT NULL,
	`user_id` text NOT NULL,
	`title` text NOT NULL,
	`description` text,
	`created_at` integer NOT NULL,
	`updated_at` integer NOT NULL,
	FOREIGN KEY (`user_id`) REFERENCES `user`(`id`) ON UPDATE no action ON DELETE cascade
);
--> statement-breakpoint
CREATE TABLE `flashcard` (
	`id` text PRIMARY KEY NOT NULL,
	`deck_id` text NOT NULL,
	`front` text NOT NULL,
	`back` text NOT NULL,
	`created_at` integer NOT NULL,
	`updated_at` integer NOT NULL,
	`last_reviewed` integer,
	`next_review` integer,
	`ease_factor` integer DEFAULT 250 NOT NULL,
	`interval` integer DEFAULT 0 NOT NULL,
	FOREIGN KEY (`deck_id`) REFERENCES `deck`(`id`) ON UPDATE no action ON DELETE cascade
);
--> statement-breakpoint
CREATE TABLE `study_session` (
	`id` text PRIMARY KEY NOT NULL,
	`user_id` text NOT NULL,
	`cards_studied` integer NOT NULL,
	`start_time` integer NOT NULL,
	`end_time` integer NOT NULL,
	`created_at` integer NOT NULL,
	FOREIGN KEY (`user_id`) REFERENCES `user`(`id`) ON UPDATE no action ON DELETE cascade
);
--> statement-breakpoint
CREATE TABLE `user` (
	`id` text PRIMARY KEY NOT NULL,
	`name` text,
	`email` text,
	`emailVerified` integer,
	`image` text
);
--> statement-breakpoint
CREATE UNIQUE INDEX `user_email_unique` ON `user` (`email`);

================
File: migrations/0001_outstanding_typhoid_mary.sql
================
CREATE TABLE `review_log` (
	`id` text PRIMARY KEY NOT NULL,
	`user_id` text NOT NULL,
	`flashcard_id` text NOT NULL,
	`rating` integer NOT NULL,
	`reviewed_at` integer NOT NULL,
	`stability` real NOT NULL,
	`difficulty` real NOT NULL,
	`elapsed_days` integer NOT NULL,
	`scheduled_days` integer NOT NULL,
	`response_time` integer NOT NULL,
	FOREIGN KEY (`user_id`) REFERENCES `user`(`id`) ON UPDATE no action ON DELETE cascade,
	FOREIGN KEY (`flashcard_id`) REFERENCES `flashcard`(`id`) ON UPDATE no action ON DELETE cascade
);
--> statement-breakpoint
ALTER TABLE flashcard ADD `audio` text;--> statement-breakpoint
ALTER TABLE flashcard ADD `state` text DEFAULT 'new' NOT NULL;--> statement-breakpoint
ALTER TABLE flashcard ADD `stability` real DEFAULT 1 NOT NULL;--> statement-breakpoint
ALTER TABLE flashcard ADD `difficulty` real DEFAULT 5 NOT NULL;--> statement-breakpoint
ALTER TABLE flashcard ADD `elapsed_days` integer DEFAULT 0 NOT NULL;--> statement-breakpoint
ALTER TABLE flashcard ADD `scheduled_days` integer DEFAULT 0 NOT NULL;--> statement-breakpoint
ALTER TABLE flashcard ADD `reps` integer DEFAULT 0 NOT NULL;--> statement-breakpoint
ALTER TABLE flashcard ADD `lapses` integer DEFAULT 0 NOT NULL;--> statement-breakpoint
ALTER TABLE study_session ADD `correct_count` integer DEFAULT 0 NOT NULL;--> statement-breakpoint
ALTER TABLE study_session ADD `incorrect_count` integer DEFAULT 0 NOT NULL;--> statement-breakpoint
ALTER TABLE study_session ADD `average_time` integer DEFAULT 0 NOT NULL;

================
File: migrations/0002_cold_quentin_quire.sql
================
CREATE TABLE `deck_comment` (
	`id` text PRIMARY KEY NOT NULL,
	`shared_deck_id` text NOT NULL,
	`user_id` text NOT NULL,
	`content` text NOT NULL,
	`created_at` integer NOT NULL,
	`updated_at` integer NOT NULL,
	FOREIGN KEY (`shared_deck_id`) REFERENCES `shared_deck`(`id`) ON UPDATE no action ON DELETE cascade,
	FOREIGN KEY (`user_id`) REFERENCES `user`(`id`) ON UPDATE no action ON DELETE cascade
);
--> statement-breakpoint
CREATE TABLE `deck_rating` (
	`id` text PRIMARY KEY NOT NULL,
	`shared_deck_id` text NOT NULL,
	`user_id` text NOT NULL,
	`rating` real NOT NULL,
	`created_at` integer NOT NULL,
	`updated_at` integer NOT NULL,
	FOREIGN KEY (`shared_deck_id`) REFERENCES `shared_deck`(`id`) ON UPDATE no action ON DELETE cascade,
	FOREIGN KEY (`user_id`) REFERENCES `user`(`id`) ON UPDATE no action ON DELETE cascade
);
--> statement-breakpoint
CREATE TABLE `shared_deck` (
	`id` text PRIMARY KEY NOT NULL,
	`original_deck_id` text NOT NULL,
	`user_id` text NOT NULL,
	`title` text NOT NULL,
	`description` text,
	`created_at` integer NOT NULL,
	`updated_at` integer NOT NULL,
	`downloads` integer DEFAULT 0 NOT NULL,
	`is_public` integer DEFAULT true NOT NULL,
	FOREIGN KEY (`original_deck_id`) REFERENCES `deck`(`id`) ON UPDATE no action ON DELETE cascade,
	FOREIGN KEY (`user_id`) REFERENCES `user`(`id`) ON UPDATE no action ON DELETE cascade
);

================
File: migrations/0003_chubby_morph.sql
================
DROP TABLE `review_log`;--> statement-breakpoint
DROP TABLE `study_session`;--> statement-breakpoint
ALTER TABLE deck ADD `original_shared_deck_id` text;

================
File: migrations/0004_supreme_rocket_raccoon.sql
================
CREATE TABLE `review_log` (
	`id` text PRIMARY KEY NOT NULL,
	`user_id` text NOT NULL,
	`flashcard_id` text NOT NULL,
	`rating` integer NOT NULL,
	`reviewed_at` integer NOT NULL,
	`stability` real NOT NULL,
	`difficulty` real NOT NULL,
	`elapsed_days` integer NOT NULL,
	`scheduled_days` integer NOT NULL,
	`response_time` integer NOT NULL,
	FOREIGN KEY (`user_id`) REFERENCES `user`(`id`) ON UPDATE no action ON DELETE cascade,
	FOREIGN KEY (`flashcard_id`) REFERENCES `flashcard`(`id`) ON UPDATE no action ON DELETE cascade
);
--> statement-breakpoint
CREATE TABLE `study_session` (
	`id` text PRIMARY KEY NOT NULL,
	`user_id` text NOT NULL,
	`cards_studied` integer NOT NULL,
	`start_time` integer NOT NULL,
	`end_time` integer NOT NULL,
	`created_at` integer NOT NULL,
	`correct_count` integer DEFAULT 0 NOT NULL,
	`incorrect_count` integer DEFAULT 0 NOT NULL,
	`average_time` integer DEFAULT 0 NOT NULL,
	FOREIGN KEY (`user_id`) REFERENCES `user`(`id`) ON UPDATE no action ON DELETE cascade
);
--> statement-breakpoint
/*
 SQLite does not support "Dropping foreign key" out of the box, we do not generate automatic migration for that, so it has to be done manually
 Please refer to: https://www.techonthenet.com/sqlite/tables/alter_table.php
                  https://www.sqlite.org/lang_altertable.html

 Due to that we don't generate migration automatically and it has to be done manually
*/

================
File: migrations/0005_striped_ultron.sql
================
CREATE TABLE `deck_label` (
	`id` text PRIMARY KEY NOT NULL,
	`deck_id` text NOT NULL,
	`label_id` text NOT NULL,
	FOREIGN KEY (`deck_id`) REFERENCES `deck`(`id`) ON UPDATE no action ON DELETE cascade,
	FOREIGN KEY (`label_id`) REFERENCES `label`(`id`) ON UPDATE no action ON DELETE cascade
);
--> statement-breakpoint
CREATE TABLE `label` (
	`id` text PRIMARY KEY NOT NULL,
	`name` text NOT NULL,
	`created_at` integer NOT NULL
);
--> statement-breakpoint
/*
 SQLite does not support "Creating foreign key on existing column" out of the box, we do not generate automatic migration for that, so it has to be done manually
 Please refer to: https://www.techonthenet.com/sqlite/tables/alter_table.php
                  https://www.sqlite.org/lang_altertable.html

 Due to that we don't generate migration automatically and it has to be done manually
*/

================
File: migrations/0006_condemned_terror.sql
================
CREATE TABLE `user_rate_limit` (
	`id` text PRIMARY KEY NOT NULL,
	`user_id` text NOT NULL,
	`translation_count` integer DEFAULT 0 NOT NULL,
	`translation_reset_time` integer NOT NULL,
	`daily_count` integer DEFAULT 0 NOT NULL,
	`daily_reset_time` integer NOT NULL,
	`monthly_count` integer DEFAULT 0 NOT NULL,
	`monthly_reset_time` integer NOT NULL,
	`last_updated` integer NOT NULL,
	FOREIGN KEY (`user_id`) REFERENCES `user`(`id`) ON UPDATE no action ON DELETE cascade
);

================
File: test-utils/db-mocks.ts
================
import { vi } from 'vitest';
import type { Deck, Flashcard } from '@/lib/types';

export const mockDeck: Deck = {
  id: 'test-deck-id',
  userId: 'test-user-id',
  title: 'Test Deck',
  description: 'Test Description',
  createdAt: new Date(),
  updatedAt: new Date(),
  labels: []
};

export const mockFlashcard: Flashcard = {
  id: 'test-card-id',
  deckId: 'test-deck-id',
  front: 'Test Front',
  back: 'Test Back',
  createdAt: Date.now(),
  updatedAt: Date.now(),
  state: 'new',
  stability: 1,
  difficulty: 5,
  elapsedDays: 0,
  scheduledDays: 0,
  reps: 0,
  lapses: 0,
  lastReviewed: null,
  nextReview: null,
  audio: null,
  interval: 0,
  easeFactor: 250
};

================
File: test-utils/mocks.ts
================
import { vi } from 'vitest';
import { Session } from 'next-auth';

export const mockSession: Session = {
  user: { id: 'test-user', name: 'Test User', email: 'test@example.com' },
  expires: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
};

export const mockNextRouter = {
  push: vi.fn(),
  replace: vi.fn(),
  prefetch: vi.fn(),
  query: {},
  pathname: '/',
  route: '/',
  asPath: '/',
  events: {
    on: vi.fn(),
    off: vi.fn(),
    emit: vi.fn()
  }
};

================
File: test-utils/setup.tsx
================
import React from 'react';
import { render as rtlRender } from '@testing-library/react';
import { SessionProvider } from 'next-auth/react';
import { ThemeProvider } from 'next-themes';
import { mockSession, mockNextRouter } from './mocks';

function render(ui: React.ReactElement, { session = mockSession, ...renderOptions } = {}) {
  function Wrapper({ children }: { children: React.ReactNode }) {
    return (
      <SessionProvider session={session}>
        <ThemeProvider
          attribute="class"
          defaultTheme="system"
          enableSystem
        >
          {children}
        </ThemeProvider>
      </SessionProvider>
    );
  }
  return rtlRender(ui, { wrapper: Wrapper, ...renderOptions });
}

// re-export everything
export * from '@testing-library/react';

// override render method
export { render };

================
File: test-utils/wrapper.tsx
================
import React from 'react';
import { render } from '@testing-library/react';
import { SessionProvider } from 'next-auth/react';
import { ThemeProvider } from 'next-themes';
import { Toaster } from '@/components/ui/toaster';

interface WrapperProps {
  children: React.ReactNode;
}

const mockSession = {
  user: { id: 'test-user', name: 'Test User', email: 'test@example.com' },
  expires: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
};

export const Wrapper = ({ children }: WrapperProps) => {
  return (
    <ThemeProvider 
      attribute="class" 
      defaultTheme="light" 
      enableSystem={false} 
      disableTransitionOnChange
    >
      <SessionProvider session={mockSession}>
        {children}
        <Toaster />
      </SessionProvider>
    </ThemeProvider>
  );
};

const customRender = (ui: React.ReactElement, options = {}) =>
  render(ui, { wrapper: Wrapper, ...options });

// Re-export everything
export * from '@testing-library/react';

// Override render method
export { customRender as render };

================
File: types/vitest.d.ts
================
/// <reference types="vitest" />
/// <reference types="@testing-library/jest-dom" />

import '@testing-library/jest-dom';
import type { TestingLibraryMatchers } from '@testing-library/jest-dom/matchers';

declare global {
  namespace Vi {
    interface JestAssertion<T = any>
      extends jest.Matchers<void, T>,
        TestingLibraryMatchers<T, void> {}
  }
}

================
File: .eslintrc.json
================
{
  "extends": [
    "next/core-web-vitals",
    "plugin:react-hooks/recommended"
  ],
  "rules": {
    "react/no-unescaped-entities": [
      "error",
      {
        "forbid": [
          {
            "char": "'",
            "alternatives": ["&apos;"]
          }
        ]
      }
    ],
    "react-hooks/exhaustive-deps": "warn"
  }
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local
.env.local
# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
repopack-output.txt

================
File: .npmrc
================
registry=https://registry.npmjs.org/
strict-peer-dependencies=false
auto-install-peers=true
legacy-peer-deps=true

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}

================
File: drizzle.config.ts
================
import type { Config } from 'drizzle-kit';
import * as dotenv from 'dotenv';

dotenv.config({ path: '.env.local' });

if (!process.env.NEXT_PUBLIC_TURSO_DATABASE_URL) {
  throw new Error('NEXT_PUBLIC_TURSO_DATABASE_URL is not defined');
}

if (!process.env.NEXT_PUBLIC_TURSO_AUTH_TOKEN) {
  throw new Error('NEXT_PUBLIC_TURSO_AUTH_TOKEN is not defined');
}

export default {
  schema: './lib/schema.ts',
  out: './migrations',
  driver: 'turso',
  dbCredentials: {
    url: process.env.NEXT_PUBLIC_TURSO_DATABASE_URL,
    authToken: process.env.NEXT_PUBLIC_TURSO_AUTH_TOKEN,
  },
  verbose: true,
  strict: true,
} satisfies Config;

================
File: LICENSE
================
MIT License

Copyright (c) 2024 Sarp Kaya

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: next.config.js
================
/** @type {import('next').NextConfig} */
const nextConfig = {
  env: {
    HUGGINGFACE_API_TOKEN: process.env.HUGGINGFACE_API_TOKEN
  },
  reactStrictMode: true,
  experimental: {
    forceSwcTransforms: true,
  },
  webpack: (config) => {
    config.resolve.alias = {
        ...config.resolve.alias,
        "sharp$": false,
        "onnxruntime-node$": false,
    }
    config.module.rules.push({
      test: /\.worker\.(js|ts)$/,
      loader: 'worker-loader',
      options: {
        filename: 'static/[hash].worker.js',
      },
    });
    return config;
  },
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          {
            key: 'X-DNS-Prefetch-Control',
            value: 'on'
          },
          {
            key: 'Strict-Transport-Security',
            value: 'max-age=31536000; includeSubDomains'
          },
          {
            key: 'X-Frame-Options',
            value: 'SAMEORIGIN'
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff'
          },
          {
            key: 'Referrer-Policy',
            value: 'origin-when-cross-origin'
          }
        ]
      }
    ];
    
  },
};

module.exports = nextConfig;

================
File: package.json
================
{
  "name": "flashcard-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start"
  },
  "dependencies": {
    "@auth/core": "0.37.2",
    "@auth/drizzle-adapter": "1.7.2",
    "@hookform/resolvers": "3.3.2",
    "@libsql/client": "0.3.6",
    "@radix-ui/react-accordion": "1.1.2",
    "@radix-ui/react-alert-dialog": "1.0.5",
    "@radix-ui/react-aspect-ratio": "1.0.3",
    "@radix-ui/react-avatar": "1.0.4",
    "@radix-ui/react-checkbox": "1.0.4",
    "@radix-ui/react-collapsible": "1.0.3",
    "@radix-ui/react-context-menu": "2.1.5",
    "@radix-ui/react-dialog": "1.0.5",
    "@radix-ui/react-dropdown-menu": "2.0.6",
    "@radix-ui/react-hover-card": "1.0.7",
    "@radix-ui/react-label": "2.0.2",
    "@radix-ui/react-menubar": "1.0.4",
    "@radix-ui/react-navigation-menu": "1.1.4",
    "@radix-ui/react-popover": "1.0.7",
    "@radix-ui/react-progress": "1.0.3",
    "@radix-ui/react-radio-group": "1.1.3",
    "@radix-ui/react-scroll-area": "1.0.5",
    "@radix-ui/react-select": "1.2.2",
    "@radix-ui/react-separator": "1.0.3",
    "@radix-ui/react-slider": "1.1.2",
    "@radix-ui/react-slot": "1.0.2",
    "@radix-ui/react-switch": "1.0.3",
    "@radix-ui/react-tabs": "1.0.4",
    "@radix-ui/react-toast": "1.1.5",
    "@radix-ui/react-toggle": "1.0.3",
    "@radix-ui/react-toggle-group": "1.0.4",
    "@radix-ui/react-tooltip": "1.0.7",
    "class-variance-authority": "0.7.0",
    "clsx": "2.0.0",
    "cmdk": "0.2.0",
    "date-fns": "2.30.0",
    "drizzle-orm": "0.36.0",
    "embla-carousel-react": "8.0.0-rc14",
    "framer-motion": "10.16.4",
    "lucide-react": "0.292.0",
    "next": "13.5.6",
    "next-auth": "4.24.10",
    "next-themes": "0.2.1",
    "react": "18.2.0",
    "react-day-picker": "8.9.1",
    "react-dom": "18.2.0",
    "react-hook-form": "7.48.2",
    "recharts": "2.9.3",
    "sonner": "1.2.0",
    "tailwind-merge": "2.0.0",
    "tailwindcss-animate": "1.0.7",
    "vaul": "^1.1.1",
    "zod": "3.22.4"
  },
  "devDependencies": {
    "@types/node": "20.6.2",
    "@types/react": "18.2.22",
    "@types/react-dom": "18.2.7",
    "@typescript-eslint/eslint-plugin": "^6.21.0",
    "@typescript-eslint/parser": "^6.21.0",
    "autoprefixer": "10.4.16",
    "eslint": "^8.55.0",
    "eslint-config-next": "^13.5.7",
    "postcss": "8.4.31",
    "tailwindcss": "3.3.5",
    "typescript": "5.2.2"
  }
}

================
File: postcss.config.js
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

================
File: README.md
================
# Cervello Flashcards

A modern spaced repetition flashcard app built with Next.js 13, featuring an intelligent learning algorithm and a clean, minimalist design.

<img width="1677" alt="Screenshot 2024-11-02 at 02 51 34" src="https://github.com/user-attachments/assets/49fcf940-9426-4df7-8af4-77198871fa9b">

## Features

- **Smart Learning Algorithm**: Implements the Free Spaced Repetition Scheduler (FSRS) algorithm for optimal retention
- **Clean, Minimalist Design**: Focus on what matters - learning
- **Cross-Platform**: Works seamlessly across desktop and mobile devices
- **Dark Mode Support**: Easy on the eyes, day or night
- **Translation Support**: Built-in translation capabilities for language learning
- **Community Features**: Share and discover flashcard decks from other users
- **Progress Tracking**: Detailed statistics and learning analytics


## Tech Stack

- **Frontend**: Next.js 13, React, TailwindCSS, Framer Motion
- **Backend**: Next.js API Routes, Drizzle ORM
- **Database**: Turso (SQLite)
- **Authentication**: NextAuth.js with Google Provider
- **Testing**: Vitest, React Testing Library
- **AI Integration**: Hugging Face for translations

## Getting Started

### Prerequisites

- Node.js 18.0 or later
- pnpm (preferred) or npm
- A Turso database
- Google OAuth credentials
- Hugging Face API token

### Environment Variables

Create a `.env.local` file in the root directory with the following variables:

```bash
NEXT_PUBLIC_TURSO_DATABASE_URL=your_turso_database_url
NEXT_PUBLIC_TURSO_AUTH_TOKEN=your_turso_auth_token
GOOGLE_CLIENT_ID=your_google_client_id
GOOGLE_CLIENT_SECRET=your_google_client_secret
NEXTAUTH_SECRET=your_nextauth_secret
HUGGINGFACE_API_TOKEN=your_huggingface_token
```

### Installation

1. Clone the repository:
```bash
git clone https://github.com/srpkya/cervello_flashcards.git
```

2. Install dependencies:
```bash
pnpm install
```

3. Run database migrations:
```bash
pnpm migrate
```

4. Start the development server:
```bash
pnpm dev
```

## Testing

Run the test suite:

```bash
# Run all tests
pnpm test

# Run tests in watch mode
pnpm test:watch

# Run tests with coverage
pnpm test:coverage
```

## Key Features Overview

### Spaced Repetition System
- Implements FSRS algorithm for optimal review scheduling
- Adapts to individual learning pace
- Intelligent card scheduling based on performance

<img width="1678" alt="Screenshot 2024-11-02 at 02 54 03" src="https://github.com/user-attachments/assets/0a835a8a-e841-464f-8732-255bde80d11c">


### Collection Management
- Create and organize flashcard collections
- Add labels for better organization

### Marketplace
- Share collections with the community
- Rate and comment on shared collections
- Clone collections from other users

<img width="1680" alt="Screenshot 2024-11-02 at 02 55 15" src="https://github.com/user-attachments/assets/396f6765-0cce-45c5-842d-da303f233568">

### Translation Cards

- Generate translation cards with ease 
Supports multiple language pairs:

- English  German
- English  French
- English  Spanish
- English  Italian
- English  Portuguese
- English  Russian

Powered by Helsinki-NLP's OPUS-MT models via Hugging Face

<img width="1677" alt="Screenshot 2024-11-02 at 03 16 35" src="https://github.com/user-attachments/assets/b3bfab8f-3173-4b62-813f-ca581e4b5cee">
<img width="528" alt="Screenshot 2024-11-02 at 03 17 29" src="https://github.com/user-attachments/assets/1d0fe7cf-05cc-42d0-aac6-c77aad29ffcb">

### Study Statistics
- Detailed learning analytics
- Progress tracking
- Study streaks
- Performance metrics

<img width="1679" alt="Screenshot 2024-11-02 at 02 51 09" src="https://github.com/user-attachments/assets/70454a94-e1b6-4074-94ab-076d8ae48d4b">

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Support

If you encounter any issues or have questions, please file an issue in the GitHub repository.

================
File: tailwind.config.ts
================
import type { Config } from 'tailwindcss';
import { fontFamily } from "tailwindcss/defaultTheme";

const config = {
  darkMode: ["class"],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      fontFamily: {
        sans: ["var(--font-inter)", ...fontFamily.sans],
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config;

export default config;

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    },
    "baseUrl": "."
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts"
  ],
  "exclude": ["node_modules"]
}

================
File: tsconfig.test.json
================
{
    "extends": "./tsconfig.json",
    "compilerOptions": {
      "jsx": "react-jsx",
      "module": "commonjs",
      "target": "es2017",
      "esModuleInterop": true,
      "allowJs": true,
      "noEmit": true,
      "moduleResolution": "node",
      "isolatedModules": true,
      "types": [
        "vite/client", 
        "vitest",
        "jest",
        "node",
        "@testing-library/jest-dom"
      ],
      "typeRoots": [
        "./node_modules/@types",
        "./types"
      ],
      "skipLibCheck": true,
      "strict": true
    },
    "include": [
      "**/*.ts",
      "**/*.tsx",
      "__tests__/**/*",
      "jest.setup.ts",
      "jest.config.ts",
      "jest.environment.ts",
      "jest.polyfills.ts",
      "types/**/*"
    ],
    "exclude": [
      "node_modules"
    ]
  }

================
File: vercel.json
================
{
  
  "git": {
    "deploymentEnabled": {
      "main": true
    }
  }
}

================
File: vite.config.ts
================
/// <reference types="vitest" />
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import type { UserConfigExport, UserConfig } from 'vite';
import { resolve } from 'node:path';

export default defineConfig(async (): Promise<UserConfig> => {
  const tsconfigPaths = (await import('vite-tsconfig-paths')).default;

  return {
    plugins: [
      react(),
      tsconfigPaths(),
    ],
    resolve: {
      alias: [{ find: "@", replacement: resolve(__dirname, "./src") }]
    },
    test: {
      globals: true,
      environment: 'jsdom',
      setupFiles: './vitest.setup.ts',
      include: ['**/*.{test,spec}.{ts,tsx}'],
      exclude: ['**/node_modules/**', '**/dist/**', '**/cypress/**'],
      coverage: {
        provider: 'v8',
        reporter: ['text', 'json', 'html'],
        exclude: [
          'node_modules/',
          'test{,-*}.{js,cjs,mjs,ts,tsx,jsx}',
          '**/*.d.ts',
        ],
      },
      deps: {
        inline: [/@testing-library\/jest-dom/]
      }
    },
  };
});

================
File: vitest.setup.ts
================
/// <reference types="@testing-library/jest-dom" />
import '@testing-library/jest-dom'
import { server } from './__mocks__/msw/server';
import { beforeAll, afterEach, afterAll, vi } from 'vitest';
import { cleanup } from '@testing-library/react';

Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  }))
});

const mockDb = {
  select: vi.fn().mockReturnThis(),
  from: vi.fn().mockReturnThis(),
  where: vi.fn().mockReturnThis(),
  get: vi.fn(),
  insert: vi.fn().mockReturnThis(),
  values: vi.fn().mockReturnThis(),
  transaction: vi.fn().mockImplementation(async (callback) => {
    return callback(mockDb); // This ensures the transaction callback gets executed
  }),
  update: vi.fn().mockReturnThis(),
  set: vi.fn().mockResolvedValue({}),
  delete: vi.fn().mockResolvedValue({}),
};

vi.mock('@/lib/db', () => ({
  getDb: vi.fn().mockResolvedValue(mockDb),
  createDbClient: vi.fn().mockResolvedValue(mockDb),
}));

// Mock next-auth/adapters
vi.mock('@auth/drizzle-adapter', () => ({
  DrizzleAdapter: vi.fn().mockReturnValue({})
}));



// Create the fetch mock
const mockFetch = vi.fn().mockResolvedValue({
  ok: true,
  json: async () => ({ success: true })
}) as unknown as typeof fetch;

// Assign it to global fetch
global.fetch = mockFetch;

// Mock next-auth
vi.mock('next-auth/react', () => ({
  useSession: vi.fn(() => ({
    data: { user: { id: 'test-user' } },
    status: 'authenticated'
  })),
  signIn: vi.fn(),
  signOut: vi.fn(),
  SessionProvider: ({ children }: { children: React.ReactNode }) => children
}));

// Mock next-auth
vi.mock('next-auth', () => ({
  getServerSession: vi.fn(() => Promise.resolve({
    user: { id: 'test-user' }
  }))
}));

// Mock next/navigation
vi.mock('next/navigation', () => ({
  useRouter: vi.fn(() => ({
    push: vi.fn(),
    replace: vi.fn(),
    back: vi.fn(),
    forward: vi.fn(),
    refresh: vi.fn(),
    prefetch: vi.fn()
  })),
  usePathname: vi.fn(() => '/'),
  useSearchParams: vi.fn(() => new URLSearchParams())
}));

beforeAll(() => {
  server.listen({ onUnhandledRequest: 'error' });
});

beforeEach(() => {
  vi.clearAllMocks();
});

afterEach(() => {
  cleanup();
  server.resetHandlers();
  vi.clearAllMocks();
});

afterAll(() => {
  server.close();
});

export { mockFetch, mockDb };
